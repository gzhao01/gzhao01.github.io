<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>biliBara_liveStreaming</title>
    <url>/biliBara-liveStreaming/</url>
    <content><![CDATA[<p>记录实现对b站直播间弹幕的爬取和统计过程</p>
<p>网页浏览如下：</p>
<p><a href="http://47.96.227.33:8084/" target="_blank" rel="noopener">http://47.96.227.33:8084/</a></p>
<a id="more"></a>

<h1 id="1-分析包"><a href="#1-分析包" class="headerlink" title="1. 分析包"></a>1. 分析包</h1><h3 id="1-使用chrome"><a href="#1-使用chrome" class="headerlink" title="1.使用chrome"></a>1.使用chrome</h3><p>使用chrome对包的preview一个一个查看后，发现一个gethistory的包符合要查找的对象</p>
<img src="/biliBara-liveStreaming/1590517175355.png" class="" width="1590517175355">

<p>点开headers进行分析</p>
<p>发现是post请求，所以需要headers和request body</p>
<p>也就复制headers和form data部分</p>
<h3 id="2-使用fiddle-optional"><a href="#2-使用fiddle-optional" class="headerlink" title="2. 使用fiddle(optional)"></a>2. 使用fiddle(optional)</h3><p>因为fiddle默认无法获取https请求，所以要先对fiddle进行设置</p>
<p>打开tools-&gt;option，设置成这样</p>
<img src="/biliBara-liveStreaming/1590517433674.png" class="" width="1590517433674">

<p>再打开actions，点击trust root certificate，关闭并保存</p>
<p>然后使用find查找gethistory，并拖入composer里</p>
<p>最后可以发现fiddle获得的信息和chrome相同</p>
<img src="/biliBara-liveStreaming/1590517308512.png" class="" width="1590517308512">

<p>那么requests请求的代码可以表示为</p>
<p>（<strong>！！！注意：</strong> post请求要有headers和data）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line">url = <span class="string">"https://api.live.bilibili.com/xlive/web-room/v1/dM/gethistory"</span></span><br><span class="line"><span class="comment"># headers</span></span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="string">'accept'</span>: <span class="string">'application/json, text/plain, */*'</span>,</span><br><span class="line"><span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line"><span class="string">'accept-language'</span>: <span class="string">'en'</span>,</span><br><span class="line"><span class="string">'content-length'</span>: <span class="string">'107'</span>,</span><br><span class="line"><span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line"><span class="string">'cookie'</span>: <span class="string">r"_uuid=D16D0A02-421C-2253-9AD8-FADD9A976C1144289infoc; CURRENT_FNVAL=16; buvid3=A3D7CCA8-0D9B-43D8-B56A-614F12447787155833infoc; LIVE_BUVID=AUTO8315677851506285; rpdid=|(YuJm~|)lJ0J'ulY~~)lu)|; stardustvideo=1; sid=ih8yqv5n; laboratory=1-1; im_notify_type_6692208=0; LIVE_PLAYER_TYPE=2; dy_spec_agreed=1; DedeUserID=6692208; DedeUserID__ckMd5=c56ad702aa91db1e; SESSDATA=c04b7a1f%2C1603258212%2C356e9*41; bili_jct=2f70ab6c72811e66d8aa2c213b66527c; CURRENT_QUALITY=116; bsource=seo_baidu; deviceFingerprint=76d922916b398d424d70e37a93a1c417; kfcSource=Mdynamic; msource=Mdynamic; bp_t_offset_6692208=393673472539036962; _dfcaptcha=587eada633263e36dac94ac17ca97527; bp_video_offset_6692208=393691816342365508; Hm_lvt_8a6e55dbd2870f0f5bc9194cddf32a02=1590502278,1590503295; Hm_lpvt_8a6e55dbd2870f0f5bc9194cddf32a02=1590503295; PVID=14"</span>,</span><br><span class="line"><span class="string">'origin'</span>: <span class="string">'https://live.bilibili.com'</span>,</span><br><span class="line"><span class="string">'referer'</span>: <span class="string">'https://live.bilibili.com/21129786'</span>,</span><br><span class="line"><span class="string">'sec-fetch-dest'</span>: <span class="string">'empty'</span>,</span><br><span class="line"><span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line"><span class="string">'sec-fetch-site'</span>: <span class="string">'same-site'</span>,</span><br><span class="line"><span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#formdata</span></span><br><span class="line">formdata=&#123;</span><br><span class="line"><span class="string">'roomid'</span>: <span class="string">'21129786'</span>,</span><br><span class="line"><span class="string">'csrf_token'</span>: <span class="string">'2f70ab6c72811e66d8aa2c213b66527c'</span>,</span><br><span class="line"><span class="string">'csrf'</span>: <span class="string">'2f70ab6c72811e66d8aa2c213b66527c'</span></span><br><span class="line">    &#125;</span><br><span class="line">headers2 = &#123;</span><br><span class="line"><span class="string">'Host'</span>: <span class="string">'api.live.bilibili.com:443'</span>,</span><br><span class="line"><span class="string">'Proxy-Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line"><span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">resp = requests.post(url, headers=headers, data=formdata)</span><br></pre></td></tr></table></figure>

<p>但是返回结果之中有编码</p>
<img src="/biliBara-liveStreaming/1590517726858.png" class="" width="1590517726858">

<p>查看chrome中的元素后发现这是&gt;的unicode编码</p>
<p>那么接着添加上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp.encoding = <span class="string">"unicode_escape"</span></span><br></pre></td></tr></table></figure>

<p>最后编码也就显示正常了</p>
<h1 id="2-Websocket分析"><a href="#2-Websocket分析" class="headerlink" title="2. Websocket分析"></a>2. Websocket分析</h1><h3 id="1-站在巨人的肩膀上（偷懒）"><a href="#1-站在巨人的肩膀上（偷懒）" class="headerlink" title="1. 站在巨人的肩膀上（偷懒）"></a>1. 站在巨人的肩膀上（偷懒）</h3><p>b站的websocket已经有人写成了接口，也就是bilibili-live-ws, 可以使用npm安装</p>
<p><a href="https://github.com/simon300000/bilibili-live-ws" target="_blank" rel="noopener">https://github.com/simon300000/bilibili-live-ws</a></p>
<p>使用express的测试代码如下</p>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> LiveWS = <span class="built_in">require</span>(<span class="string">'bilibili-live-ws'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="built_in">require</span>(<span class="string">'nodejs-websocket'</span>);</span><br><span class="line"></span><br><span class="line"> app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// res.send('Hello World!')</span></span><br><span class="line"></span><br><span class="line">    connection.on(<span class="string">"text"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(str)</span><br><span class="line">      <span class="keyword">const</span> live = <span class="keyword">new</span> LiveWS(<span class="number">21129786</span>)</span><br><span class="line">      live.on(<span class="string">'open'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Connection is established'</span>))</span><br><span class="line">      <span class="comment">// Connection is established</span></span><br><span class="line">      live.on(<span class="string">'live'</span>, () =&gt; &#123;</span><br><span class="line">        live.on(<span class="string">'heartbeat'</span>, online=&gt;&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"heartbeat"</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(online)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;) </span><br><span class="line">      live.on(<span class="string">"msg"</span>, (data)=&gt;&#123;</span><br><span class="line">        <span class="comment">//返回给前端</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data"</span>)</span><br><span class="line">        data = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">        connection.sendText(data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data suc"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure>

<p>打开控制台之后，就能接收到b站直播房间推送的json消息了。</p>
<p>但是这里的数据只能在nodejs中使用，原生的html和vue都不能使用，浏览器会报错</p>
<p>这是因为nodejs使用的websocket和原生的websocket是不一样的</p>
<p>所以就要用websocket把nodejs和前端连接起来了</p>
<p><strong>和连接前端</strong></p>
<p>nodejs的websocket包是nodejs-websocket</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i nodejs-websocket -S</span><br></pre></td></tr></table></figure>

<p>代码改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> LiveWS = <span class="built_in">require</span>(<span class="string">'bilibili-live-ws'</span>)<span class="comment">// import pack</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="built_in">require</span>(<span class="string">'nodejs-websocket'</span>); <span class="comment">//import pack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.get('/', (req, res) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">// res.send('Hello World!')</span></span><br><span class="line">  <span class="keyword">const</span> server = ws.createServer(<span class="function"><span class="params">connection</span> =&gt;</span> &#123;</span><br><span class="line">    connection.on(<span class="string">"text"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(str)</span><br><span class="line">      <span class="keyword">const</span> live = <span class="keyword">new</span> LiveWS(<span class="number">21129786</span>)</span><br><span class="line">      live.on(<span class="string">'open'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Connection is established'</span>))</span><br><span class="line">      <span class="comment">// Connection is established</span></span><br><span class="line">      live.on(<span class="string">'live'</span>, () =&gt; &#123;</span><br><span class="line">        live.on(<span class="string">'heartbeat'</span>, online=&gt;&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"heartbeat"</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(online)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;) </span><br><span class="line">      live.on(<span class="string">"msg"</span>, (data)=&gt;&#123;</span><br><span class="line">        <span class="comment">//返回给前端</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data"</span>)</span><br><span class="line">        <span class="comment">//转化为json格式</span></span><br><span class="line">        data = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">        connection.sendText(data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data suc"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).listen(port) <span class="comment">//监听端口3000</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`))</span></span><br></pre></td></tr></table></figure>

<p>前端接收的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">      <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:3000"</span>)</span><br><span class="line">      ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ws open"</span>)</span><br><span class="line">        ws.send(<span class="string">"vue send message"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ws.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"receive msh"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样子一登录到vue页面，就会和后台建立websocket连接，之后后台就会和b站直播建立连接，最后反向将消息推送到前段之中。</p>
<p>这里要注意的是在后端要进项数据的转化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; JSON.stringify(data)</span><br></pre></td></tr></table></figure>

<p>否则浏览器会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first argument must be one of type string or Buffer.</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/mn6364/p/10698056.html" target="_blank" rel="noopener">https://www.cnblogs.com/mn6364/p/10698056.html</a></p>
<h3 id="2-协议分析"><a href="#2-协议分析" class="headerlink" title="2.协议分析"></a>2.协议分析</h3><p>网上也有一些协议的分析</p>
<p><a href="https://blog.csdn.net/xfgryujk/article/details/80306776" target="_blank" rel="noopener">https://blog.csdn.net/xfgryujk/article/details/80306776</a></p>
<p><a href="http://www.lyyyuna.com/2016/03/14/bilibili-danmu01/" target="_blank" rel="noopener">http://www.lyyyuna.com/2016/03/14/bilibili-danmu01/</a></p>
<p>下面这个讲的比较详细，也有相关node代码的教程</p>
<p><a href="https://github.com/lovelyyoshino/Bilibili-Live-API/blob/master/API.WebSocket.md" target="_blank" rel="noopener">https://github.com/lovelyyoshino/Bilibili-Live-API/blob/master/API.WebSocket.md</a></p>
<h3 id="3-websocket教程"><a href="#3-websocket教程" class="headerlink" title="3. websocket教程"></a>3. websocket教程</h3><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>
<h3 id="4-抓包"><a href="#4-抓包" class="headerlink" title="4. 抓包"></a>4. 抓包</h3><p>websocket可以使用wireshark或者fiddler进行抓包</p>
<h5 id="1-fiddler抓包"><a href="#1-fiddler抓包" class="headerlink" title="1. fiddler抓包"></a>1. fiddler抓包</h5><p>因为fiddler只能抓取http和https，websocket只有第一次握手是http协议，所以内容都集中在第一次握手的包里了。</p>
<p>直接在fiddler中搜索websocket，就会出现sub包</p>
<img src="/biliBara-liveStreaming/1590707236199.png" class="" width="1590707236199">

<p>点击sub包就会出现右边的内容</p>
<p>发现第一个包是连接时发送的包</p>
<img src="/biliBara-liveStreaming/1590707331539.png" class="" width="1590707331539">

<p>发送一个测试弹幕，但发现内容加密了</p>
<img src="/biliBara-liveStreaming/1590707452590.png" class="" width="1590707452590">

<p>只好再用wireshark</p>
<h5 id="2-wireshark"><a href="#2-wireshark" class="headerlink" title="2. wireshark"></a>2. wireshark</h5>]]></content>
      <categories>
        <category>biliBara</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
        <tag>web</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>bilibili弹幕爬取</title>
    <url>/biliBara/</url>
    <content><![CDATA[<p>flask+vue的b站弹幕爬虫统计数据</p>
<img src="/biliBara/1590339415849.png" class="" width="1590339415849">

<a id="more"></a>

<h1 id="1-FLASK"><a href="#1-FLASK" class="headerlink" title="1.FLASK"></a>1.FLASK</h1><h3 id="1-requirement文件"><a href="#1-requirement文件" class="headerlink" title="1. requirement文件"></a>1. requirement文件</h3><p>生成</p>
<figure class="highlight plain"><figcaption><span>freeze > requirements.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>



<h1 id="2-PYTHON"><a href="#2-PYTHON" class="headerlink" title="2.PYTHON"></a>2.PYTHON</h1><h3 id="1-jieba提词和echarts-wordcloud"><a href="#1-jieba提词和echarts-wordcloud" class="headerlink" title="1.jieba提词和echarts wordcloud"></a>1.jieba提词和echarts wordcloud</h3><p><a href="https://www.jianshu.com/p/8490b46473a5" target="_blank" rel="noopener">https://www.jianshu.com/p/8490b46473a5</a><br>一般词云都是要使用词语的权重，这个权重的计算可以使用jieba提词轻松实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"><span class="comment">#获得一个元祖的数组[("中国", 0.234),("人", 0.4613)]</span></span><br><span class="line">tags = jieba.analyse.extract_tags(content, topK=<span class="number">100</span>, withWeight=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> tex, weight <span class="keyword">in</span> tags:</span><br><span class="line">   tagsList[tex] += int(weight*<span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-flask接受请求的参数"><a href="#2-flask接受请求的参数" class="headerlink" title="2.flask接受请求的参数"></a>2.flask接受请求的参数</h3><p><a href="https://www.cnblogs.com/shangpolu/p/7106922.html" target="_blank" rel="noopener">https://www.cnblogs.com/shangpolu/p/7106922.html</a><br>1.get请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.post请求</span><br><span class="line">&#96;&#96;&#96;request.form.get(&quot;key&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3-python原始爬虫"><a href="#3-python原始爬虫" class="headerlink" title="3.python原始爬虫"></a>3.python原始爬虫</h3><p><a href="https://blog.csdn.net/weixin_41429999/article/details/105781775" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41429999/article/details/105781775</a></p>
<h1 id="3-VUE"><a href="#3-VUE" class="headerlink" title="3.VUE"></a>3.VUE</h1><h3 id="1-vuex，localStorage和sessionStorage"><a href="#1-vuex，localStorage和sessionStorage" class="headerlink" title="1.vuex，localStorage和sessionStorage"></a>1.vuex，localStorage和sessionStorage</h3><p><a href="https://www.cnblogs.com/liangtao999/p/12623617.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangtao999/p/12623617.html</a></p>
<p>veux主要用于页面跳转间的传值，储存在内存之中，页面刷新就会丢失</p>
<p>localStorage会永久储存在浏览器中，不丢失</p>
<p>sessionStorage临时储存在浏览器中，浏览器关闭便会丢失</p>
<h3 id="2-页面无跳闪刷新"><a href="#2-页面无跳闪刷新" class="headerlink" title="2.页面无跳闪刷新"></a>2.页面无跳闪刷新</h3><p><a href="https://blog.csdn.net/weixin_43885417/article/details/91310674" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43885417/article/details/91310674</a></p>
<h3 id="3-echarts"><a href="#3-echarts" class="headerlink" title="3.echarts"></a>3.echarts</h3><p>可以直接卸载mounted之中<br><strong>impotant！</strong>但要注意的是，在使用axiso获取数据时，要将设置项（setOption）放在axios的请求处理之中，否则图表将不会显示数据</p>
<h3 id="4-vue-config-js配置"><a href="#4-vue-config-js配置" class="headerlink" title="4.vue.config.js配置"></a>4.vue.config.js配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const debug &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line"> </span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 访问资源的基本路径，一般不需要进行修改，此处还有疑问，正在验证中</span><br><span class="line">    &#x2F;&#x2F; baseUrl: &#39;&#x2F;&#39;,&lt;br&gt;        publicPath: &#39;&#x2F;&#39;,  &#x2F;&#x2F;publicPath取代了baseUrl</span><br><span class="line">    &#x2F;&#x2F; 打包之后输出文件目录</span><br><span class="line">    outputDir: &#39;dist&#39;,</span><br><span class="line">    assetsDir: &#39;assets&#39;, &#x2F;&#x2F; 打包之后静态资源目录 (js, css, img, fonts)</span><br><span class="line">    &#x2F;&#x2F; eslint-loader 是否在保存的时候检查</span><br><span class="line">    lintOnSave: true,</span><br><span class="line">    &#x2F;&#x2F; use the full build with in-browser compiler?</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;vuejs.org&#x2F;v2&#x2F;guide&#x2F;installation.html#Runtime-Compiler-vs-Runtime-only</span><br><span class="line">    &#x2F;&#x2F; runtimeCompiler: true, &#x2F;&#x2F;关键点在这  原来的 Compiler 换成了 runtimeCompiler</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; webpack配置</span><br><span class="line">    &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-cli&#x2F;blob&#x2F;dev&#x2F;docs&#x2F;webpack.md   webpack链接API，用于生成和修改webapck配置</span><br><span class="line">    chainWebpack: () &#x3D;&gt; &#123;</span><br><span class="line">        if(debug) &#123;</span><br><span class="line">            &#x2F;&#x2F; 本地开发配置</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 生产开发配置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: (config) &#x3D;&gt; &#123; &#x2F;&#x2F; webpack配置，值位对象时会合并配置，为方法时会改写配置</span><br><span class="line">        if(debug) &#123; &#x2F;&#x2F; 开发环境配置</span><br><span class="line">            config.devtool &#x3D; &#39;cheap-module-eval-source-map&#39;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 生产环境配置</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        Object.assign(config, &#123; &#x2F;&#x2F; 开发生产共同配置</span><br><span class="line">            resolve: &#123;</span><br><span class="line">                alias: &#123;</span><br><span class="line">                    &#39;@&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#39;) &#x2F;&#x2F;设置路径别名</span><br><span class="line">                    &#x2F;&#x2F;...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; vue-loader 配置项</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;vue-loader.vuejs.org&#x2F;en&#x2F;options.html</span><br><span class="line">    &#x2F;&#x2F; vueLoader: &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 生产环境是否生成 sourceMap 文件</span><br><span class="line">    productionSourceMap: true,</span><br><span class="line">    &#x2F;&#x2F; css相关配置 配置高于chainWebpack中关于css loader的配置</span><br><span class="line">    css: &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否使用css分离插件 ExtractTextPlugin</span><br><span class="line">        extract: true,</span><br><span class="line">        &#x2F;&#x2F; 开启 CSS source maps?是否在构建样式地图，false将提高构建速度</span><br><span class="line">        sourceMap: false,</span><br><span class="line">        &#x2F;&#x2F; css预设器配置项</span><br><span class="line">        loaderOptions: &#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 启用 CSS modules for all css &#x2F; pre-processor files.</span><br><span class="line">        modules: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; use thread-loader for babel &amp; TS in production build</span><br><span class="line">    &#x2F;&#x2F; enabled by default if the machine has more than 1 cores 构建时开启多进程处理babel编译</span><br><span class="line">    parallel: require(&#39;os&#39;).cpus().length &gt; 1,</span><br><span class="line">    &#x2F;&#x2F; 是否启用dll</span><br><span class="line">    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-cli&#x2F;blob&#x2F;dev&#x2F;docs&#x2F;cli-service.md#dll-mode</span><br><span class="line">    &#x2F;&#x2F; dll: false,</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; PWA 插件相关配置</span><br><span class="line">    &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-cli&#x2F;tree&#x2F;dev&#x2F;packages&#x2F;%40vue&#x2F;cli-plugin-pwa</span><br><span class="line">    pwa: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; webpack-dev-server 相关配置</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: true,</span><br><span class="line">        host: &#39;localhost&#39;,</span><br><span class="line">        port: 8084,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">          &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">            target: &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#39;,</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,</span><br><span class="line">            pathRewrite:&#123;</span><br><span class="line">              &quot;^&#x2F;api&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; &#x2F;&#x2F; 设置代理</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的代理设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    host: &#39;localhost&#39;,</span><br><span class="line">    port: 8084,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#39;,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        secure: false,</span><br><span class="line">        pathRewrite:&#123;</span><br><span class="line">          &quot;^&#x2F;api&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; &#x2F;&#x2F; 设置代理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-部署"><a href="#4-部署" class="headerlink" title="4.部署"></a>4.部署</h1><h3 id="1-screen"><a href="#1-screen" class="headerlink" title="1. screen"></a>1. screen</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">screen -S yourname  #新建一个叫yourname的session</span><br><span class="line">screen -ls          #列出当前所有的session</span><br><span class="line">screen -r [yourname&#x2F;scrren-id]  #回到yourname这个session</span><br><span class="line">ctrl+a -&gt; d  #detach当前screen回到原本窗口</span><br><span class="line">ctrel+a -&gt; n #显示下一个窗口（next）</span><br><span class="line">screen -X -s [screenname] #关闭会话</span><br></pre></td></tr></table></figure>

<h3 id="2-Gunicorn"><a href="#2-Gunicorn" class="headerlink" title="2. Gunicorn"></a>2. Gunicorn</h3><p><a href="https://www.cnblogs.com/luyuze95/p/11696534.html" target="_blank" rel="noopener">https://www.cnblogs.com/luyuze95/p/11696534.html</a></p>
<p>Web框架致力于如何生成HTML代码，而Web服务器用于处理和响应HTTP请求。Web框架和Web服务器之间的通信，需要一套双方都遵守的接口协议。WSGI协议就是用来统一这两者的接口的。</p>
<p><strong>1.</strong> 安装gunicorn</p>
<p>要在虚拟状态激活的情况下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install gunicorn   #阿里云自带python2，pip3可以确保调用python3</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> 启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -w 4 -b 127.0.0.1:5000 [app_name]:app</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> 查找gunicorn进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep gunicorn</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/freinds/p/8074651.html" target="_blank" rel="noopener">https://www.cnblogs.com/freinds/p/8074651.html</a></p>
<p>ps-ef用于查看全格式的全部进程，其中“ps”是在抄Linux中是查看进程的命令，“-e”参数代表显示所有进程，“-f”参数代表全格式。</p>
<p>ps命令将某个进程显示出来</p>
<p>grep命令是查找</p>
<p>中间的|是管道命令 是指ps命令与grep同时执行</p>
<p>PS是LINUX下最常用的也是非常强大的进程查看命令</p>
<p>grep命令是查找，是一种强大的文本搜索工具，它能<a href="https://www.baidu.com/s?wd=%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9uWD3PhP9n1b4m1nduAcz0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjfvrHnzPWT3" target="_blank" rel="noopener">使用正则表达式</a>搜索文本，并把匹配的行打印出来。</p>
<p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
<p>以下这条命令是检查java 进程是否存在：ps -ef |grep java</p>
<p>*<em>3. *</em>杀死进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 [id]</span><br></pre></td></tr></table></figure>

<h3 id="3-nginx"><a href="#3-nginx" class="headerlink" title="3.nginx"></a>3.nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload   #重新加载nginx配置</span><br><span class="line">sudo service nginx restart  #启动nginx</span><br></pre></td></tr></table></figure>

<p>nginx的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#networkproject</span><br><span class="line"> server &#123;</span><br><span class="line">    listen       8084 default_server;</span><br><span class="line">    listen       [::]:8084 default_server;</span><br><span class="line">    server_name  47.96.227.33;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">            ## stitp的目录</span><br><span class="line">            # the direction of the stitp project</span><br><span class="line">            root &#x2F;myfiles&#x2F;blibiliBarrage&#x2F;dist;</span><br><span class="line">            index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    # 路径代理</span><br><span class="line">    location &#x2F;api&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">        location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line"></span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>biliBara</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>python</tag>
        <tag>flask</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>blender烘焙（multiple-into-one）</title>
    <url>/blender-bake-multiple-into-one/</url>
    <content><![CDATA[<p>本文是讲解将多物体的多材质烘焙到一个贴图上的方法。</p>
<p>要说明的是，这里小白一个，首先可以先看一下视频，如果做不出来再看本文，因为本文只是指出了要注意的细节，此外如有错误也欢迎指出和讨论..<br><a href="https://www.youtube.com/watch?v=9airvjDaVh4&list=PLj6G-3M0NXNXGGPSPXBTC1H04NPxk96Eo&index=18&t=0s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=9airvjDaVh4&amp;list=PLj6G-3M0NXNXGGPSPXBTC1H04NPxk96Eo&amp;index=18&amp;t=0s</a></p>
<a id="more"></a>

<h1 id="1-页面布局"><a href="#1-页面布局" class="headerlink" title="1.页面布局"></a>1.页面布局</h1><p>blender烘焙需要用到shader、UV editor以及3dviewport界面，将界面布置好更有利于操作</p>
<img src="/blender-bake-multiple-into-one/17071720-263c377d587b4a51.png" class="" title="图片.png">
<h1 id="2-烘焙前的准备"><a href="#2-烘焙前的准备" class="headerlink" title="2.烘焙前的准备"></a>2.烘焙前的准备</h1><p>烘焙需要准备三点</p>
<ol>
<li>一个全新的UV贴图</li>
<li>图像用来保存烘焙机结果</li>
<li>一个Image Texture节点用来指定导出到的图像</li>
</ol>
<h3 id="1-创建新图像"><a href="#1-创建新图像" class="headerlink" title="1.创建新图像"></a>1.创建新图像</h3><p>首先要创建一个新的图像，要注意的是这个<strong>图像要进行save as和save两步操作</strong>，让其保存在电脑的硬盘上，否则最后的烘焙会报”circular depandancy…”的信息，这个信息就是没找到需要导出的图像而导致图像载入到自己身上。原因大概是因为，不这样做，blender会无法检测到新图像。</p>
<h3 id="2-UV展开"><a href="#2-UV展开" class="headerlink" title="2.UV展开"></a>2.UV展开</h3><p>进行UV展开前，先新建一个UV贴图，并将该新贴图选定。</p>
<img src="/blender-bake-multiple-into-one/17071720-7a4a06a4528bfd41.png" class="" title="图片.png">
<p>然后进入edit模式，按u键进行UV展开。</p>
<img src="/blender-bake-multiple-into-one/17071720-52ffa5918c59dc3b.png" class="" title="图片.png">
<p>UV展开这里因为是高模，可以选择unwrap或者smart UV project。二者的区别在于，smart UV project可以进行个性化的展开。此外，低模也可以选择lightmap pack。<br>然后就可以发现，图片上出现了UV展开的节点，其实这里这些UV节点就保存到了刚刚新建的UV贴图里面了。</p>
<img src="/blender-bake-multiple-into-one/17071720-9a9c11a5dbc295e9.png" class="" title="图片.png">
<h3 id="3-node节点设置"><a href="#3-node节点设置" class="headerlink" title="3.node节点设置"></a>3.node节点设置</h3><p>之后在每个材质的shader界面里，新增一个image texture节点，该节点的图片就指向你要导出的那个图片。<br><strong>注意</strong>：</p>
<ol>
<li>该节点要给每个要导出的材质添加</li>
<li>该节点必须要激活（active）！！！，也就是有白色边框 <img src="/blender-bake-multiple-into-one/17071720-001343e738e56ff2.png" class="" title="图片.png">
 因为这样子操作非常麻烦，所以我写了一个脚本给每个模型的每个材质都添加这个节点，只要白get后的图片名称改成自己的即可。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.data.objects:</span><br><span class="line">    <span class="keyword">for</span> material <span class="keyword">in</span> obj.data.materials:</span><br><span class="line">        tochangeNode = material.node_tree.nodes.new(<span class="string">"ShaderNodeTexImage"</span>)</span><br><span class="line">        tochangeNode.image = bpy.data.images.get(<span class="string">"kokoro2"</span>) //change name here </span><br><span class="line">        tochangeNode.location = Vector((<span class="number">377</span>,<span class="number">-141</span>))</span><br><span class="line">//active the node</span><br><span class="line">        material.node_tree.nodes.active = tochangeNode</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="3-开始烘焙"><a href="#3-开始烘焙" class="headerlink" title="3.开始烘焙"></a>3.开始烘焙</h1><p>烘焙必须在cycle下进行</p>
<img src="/blender-bake-multiple-into-one/17071720-48304b0d4f8277a2.png" class="" title="图片.png">
<p>比较常用的烘焙模式为combined,diffuse,normal模式。<br>combined模式就是讲光影效果、阴影效果等等全部烘焙到贴图上。<br>diffuse可以选择只烘焙材质的颜色。<br>normal是法线贴图，可以给贴图丰富细节的同时又不消耗性能。<br>这里要导出到unity中，所以选择diffuse和normal模式</p>
<h3 id="1-diffuse"><a href="#1-diffuse" class="headerlink" title="1.diffuse"></a>1.diffuse</h3><p>按下面的选项勾选，margin在贴图烘焙重叠时，可以改的小一些。此外如果是多个物体烘焙需要勾选selected to active，我这里用ctrl+j合并了物体，所以不能勾选。</p>
<img src="/blender-bake-multiple-into-one/17071720-80df83722164165b.png" class="" title="图片.png">

<h3 id="2-normal"><a href="#2-normal" class="headerlink" title="2.normal"></a>2.normal</h3><p>因为要新建个图片烘焙，所以这里用另一个脚本更改节点的图片名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for obj in bpy.data.objects:</span><br><span class="line">    for material in obj.data.materials:</span><br><span class="line">        tochangeNode &#x3D; material.node_tree.nodes[-1]</span><br><span class="line">        tochangeNode.image &#x3D; bpy.data.images.get(&quot;kokoro_normal&quot;)</span><br></pre></td></tr></table></figure>

<p>最后烘焙结束后，要记住点击save保存，烘焙才会生效</p>
<img src="/blender-bake-multiple-into-one/17071720-abee8e933c37ff58.png" class="">

<h1 id="4-其他设定"><a href="#4-其他设定" class="headerlink" title="4.其他设定"></a>4.其他设定</h1><p>复制刚才的模型，并且删除所有模型，将刚刚的贴图制作成材质来测试一下烘焙效果。发现hair、eyelash、eyeball都全黑了。</p>
<img src="/blender-bake-multiple-into-one/17071720-91b11c63053de14a.png" class="" title="图片.png">
<p>再看贴图，这是因为本该透明的部分被黑色填充的结果。这个问题可以用gloss烘焙来解决。</p>
<img src="/blender-bake-multiple-into-one/17071720-23a8308842ba6637.png" class="" title="图片.png">

<p>按照之前的步骤，再进行gloss烘焙，得到的就是alpha通道的结果。白色代表要显示的部分，黑色的代表透明部分。</p>
<img src="/blender-bake-multiple-into-one/17071720-9563b93276465948.png" class="">
<p>打开ps将diffuse和gloss贴图导入。<br>给diffuse贴图添加一个蒙版，然后点击gloss贴图ctrl+a全选，ctrl+c复制，按住alt键点击多出来的蒙版，然后ctrl+v粘贴。最后就会得到两者合并的结果</p>
<img src="/blender-bake-multiple-into-one/17071720-7834a1b7165fa29b.png" class="" title="图片.png">
<p>然后到处PNG格式图片（PNG支持alpha通道）</p>
<p>回到blender，如图所示设置，即可完成结果</p>
<img src="/blender-bake-multiple-into-one/17071720-01b9981002df842e.png" class="" title="图片.png">
<img src="/blender-bake-multiple-into-one/17071720-3ec35fd8263aab9b.png" class="" title="图片.png">

<h1 id="5-导入unity"><a href="#5-导入unity" class="headerlink" title="5.导入unity"></a>5.导入unity</h1><p>将模型导出为fbx格式，如图所示勾选，即可将材质放入导出的fbx文件中</p>
<img src="/blender-bake-multiple-into-one/17071720-224fb2c541ece681.png" class="" title="图片.png">
<p>在unity中打开，但发现人物的眼睛、睫毛、头发仍然存在刚才的问题。<br>这是因为render mode中选择了opaque模式，这个模式是不考虑alpha通道的，之后选择cutoff模式即可。<br>不过这种模式下，发现睫毛和头发部分表现效果并不理想。解决方法是将这两个部分单独拎出来烘焙，然后选择fade效果。此外如果眼睛部分选择transparent效果，还可以实现眼睛的反光。</p>
<p>参考：<br><a href="https://blender.stackexchange.com/questions/44525/cycles-bake-script-error-circular-dependency" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/44525/cycles-bake-script-error-circular-dependency</a><br><a href="https://blender.stackexchange.com/questions/47052/what-is-the-difference-between-unwrap-and-smart-uv-project" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/47052/what-is-the-difference-between-unwrap-and-smart-uv-project</a><br><a href="https://blenderartists.org/t/texture-bake-alpha/407849/5" target="_blank" rel="noopener">https://blenderartists.org/t/texture-bake-alpha/407849/5</a></p>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>blender</tag>
        <tag>unity</tag>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-lecture13</title>
    <url>/GAMES101-lecture13/</url>
    <content><![CDATA[<p>GAMES101 lecture13 Ray Tracing1  Whitted-style ray tracing</p>
<a id="more"></a>

<h1 id="why-ray-tracing"><a href="#why-ray-tracing" class="headerlink" title="why ray tracing"></a>why ray tracing</h1><img src="/GAMES101-lecture13/1619427149908.png" class="" width="1619427149908">

<h1 id="hypothesis"><a href="#hypothesis" class="headerlink" title="hypothesis"></a>hypothesis</h1><img src="/GAMES101-lecture13/1619429019716.png" class="" width="1619429019716">

]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-Lecture12_Geometry3</title>
    <url>/GAMES101-Lecture12-Geometry3/</url>
    <content><![CDATA[<p>GAMES101- LECTURE12</p>
<a id="more"></a>

<h1 id="subdivision"><a href="#subdivision" class="headerlink" title="subdivision"></a>subdivision</h1><h3 id="loop-subdivision"><a href="#loop-subdivision" class="headerlink" title="loop subdivision"></a>loop subdivision</h3><p>不是循环细分！！！</p>
<p>只是family name叫loop</p>
<img src="/GAMES101-Lecture12-Geometry3/1619235625598.png" class="" width="1619235625598">



<h5 id="new-vertex"><a href="#new-vertex" class="headerlink" title="new vertex"></a>new vertex</h5><img src="/GAMES101-Lecture12-Geometry3/1619235955339.png" class="" width="1619235955339">

<img src="/GAMES101-Lecture12-Geometry3/1619236086015.png" class="" width="1619236086015">

<h5 id="old-vertex"><a href="#old-vertex" class="headerlink" title="old vertex"></a>old vertex</h5><p>u即权重</p>
<p>当degree越大，origin vertex自身的重要程度就越低，系数也就会越小</p>
<img src="/GAMES101-Lecture12-Geometry3/1619236380014.png" class="" width="1619236380014">



<h3 id="catmull-clark-subdivision"><a href="#catmull-clark-subdivision" class="headerlink" title="catmull-clark subdivision"></a>catmull-clark subdivision</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>non-quad face</p>
<p>extraordinary vertex</p>
<img src="/GAMES101-Lecture12-Geometry3/1619238176387.png" class="" width="1619238176387">

<img src="/GAMES101-Lecture12-Geometry3/1619238192779.png" class="" width="1619238192779">

<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><img src="/GAMES101-Lecture12-Geometry3/1619238105739.png" class="" width="1619238105739">

<p>catmull可以对非三角形的平面进行细分</p>
<img src="/GAMES101-Lecture12-Geometry3/1619240212498.png" class="" width="1619240212498">

<h1 id="mesh-simplification"><a href="#mesh-simplification" class="headerlink" title="mesh simplification"></a>mesh simplification</h1><h3 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h3><img src="/GAMES101-Lecture12-Geometry3/1619416091753.png" class="" width="1619416091753">

<h3 id="collapsing-the-edge（边坍缩）"><a href="#collapsing-the-edge（边坍缩）" class="headerlink" title="collapsing the edge（边坍缩）"></a>collapsing the edge（边坍缩）</h3><img src="/GAMES101-Lecture12-Geometry3/1619416290822.png" class="" width="1619416290822">



<h3 id="quadric-error-metrics"><a href="#quadric-error-metrics" class="headerlink" title="quadric error metrics"></a>quadric error metrics</h3><img src="/GAMES101-Lecture12-Geometry3/1619416438330.png" class="" width="1619416438330">

<h3 id="quadric-error-of-edge-collapse"><a href="#quadric-error-of-edge-collapse" class="headerlink" title="quadric error of edge collapse"></a>quadric error of edge collapse</h3><p>选择坍缩后，quadric error最小的边</p>
<p>可以使用优先队列来 维护最小的值对应的边</p>
<img src="/GAMES101-Lecture12-Geometry3/1619416677788.png" class="" width="1619416677788">



<h3 id="simplification-via-quadric-error"><a href="#simplification-via-quadric-error" class="headerlink" title="simplification via quadric error"></a>simplification via quadric error</h3><h1 id="shadow-mapping"><a href="#shadow-mapping" class="headerlink" title="shadow mapping"></a>shadow mapping</h1><p>非阴影处的点既可以被光源看达到，也可以被相机看到</p>
<p>阴影处的点只能被相机看到，不能被光源看到</p>
<img src="/GAMES101-Lecture12-Geometry3/1619417244177.png" class="" width="1619417244177">

<h3 id="pass1：render-from-light"><a href="#pass1：render-from-light" class="headerlink" title="pass1：render from  light"></a>pass1：render from  light</h3><p>从光源看向场景，记录下深度图</p>
<img src="/GAMES101-Lecture12-Geometry3/1619417510479.png" class="" width="1619417510479">

<h3 id="Pass2：-project-to-light"><a href="#Pass2：-project-to-light" class="headerlink" title="Pass2： project to light"></a>Pass2： project to light</h3><p>再从相机处渲染整个场景的深度图，然后从每个点投影回光源处得到另一个深度图。</p>
<p>和原来光源处的深度图进行比较，如果相同就不是阴影区域</p>
<img src="/GAMES101-Lecture12-Geometry3/1619422509594.png" class="" width="1619422509594">

<p>和原来光源处的深度图进行比较，如果不同，此处就是阴影区域</p>
<img src="/GAMES101-Lecture12-Geometry3/1619422320348.png" class="" width="1619422320348">

<h3 id="visualizing-shadow-map"><a href="#visualizing-shadow-map" class="headerlink" title="visualizing shadow map"></a>visualizing shadow map</h3><img src="/GAMES101-Lecture12-Geometry3/1619423495257.png" class="" width="1619423495257">

<p>深度图</p>
<img src="/GAMES101-Lecture12-Geometry3/1619423506262.png" class="" width="1619423506262">

<p>因为浮点数的相等判断问题，会出现噪点</p>
<img src="/GAMES101-Lecture12-Geometry3/1619423936199.png" class="" width="1619423936199">

<h3 id="problems"><a href="#problems" class="headerlink" title="problems"></a>problems</h3><img src="/GAMES101-Lecture12-Geometry3/1619424642873.png" class="" width="1619424642873">

<h1 id="soft-shadow-amp-hard-shadow"><a href="#soft-shadow-amp-hard-shadow" class="headerlink" title="soft shadow &amp; hard shadow"></a>soft shadow &amp; hard shadow</h1><img src="/GAMES101-Lecture12-Geometry3/1619424795630.png" class="" width="1619424795630">

]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture12_Geometry3</title>
    <url>/Lecture12-Geometry3/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>GAMES101-lecture11</title>
    <url>/GAMES101-lecture11/</url>
    <content><![CDATA[<p>GAMES101 lecture11 geometry2</p>
<a id="more"></a>

<h1 id="representation-of-model"><a href="#representation-of-model" class="headerlink" title="representation of model"></a>representation of model</h1><h3 id="Point-Cloud-Explicit"><a href="#Point-Cloud-Explicit" class="headerlink" title="Point Cloud(Explicit)"></a>Point Cloud(Explicit)</h3><img src="/GAMES101-lecture11/1619018446791.png" class="" width="1619018446791">

<h3 id="Polygon-Mesh-Explicit"><a href="#Polygon-Mesh-Explicit" class="headerlink" title="Polygon Mesh(Explicit)"></a>Polygon Mesh(Explicit)</h3><img src="/GAMES101-lecture11/1619018513626.png" class="" width="1619018513626">

<h3 id="Wavefront-Object-File-obj"><a href="#Wavefront-Object-File-obj" class="headerlink" title="Wavefront Object File(.obj)"></a>Wavefront Object File(.obj)</h3><img src="/GAMES101-lecture11/1619018856418.png" class="" width="1619018856418">

<h1 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h1><h3 id="Bezier-Curves-贝塞尔曲线"><a href="#Bezier-Curves-贝塞尔曲线" class="headerlink" title="Bezier Curves(贝塞尔曲线)"></a>Bezier Curves(贝塞尔曲线)</h3><p>曲线只要经过起止点。</p>
<p>控制点不一定要经过曲线</p>
<img src="/GAMES101-lecture11/1619019370515.png" class="" width="1619019370515">

<h3 id="Evaluating-Bezier-Curves（De-Casteljau-Algorithm）"><a href="#Evaluating-Bezier-Curves（De-Casteljau-Algorithm）" class="headerlink" title="Evaluating Bezier Curves（De Casteljau Algorithm）"></a>Evaluating Bezier Curves（De Casteljau Algorithm）</h3><p>quadratic Bezier 二次贝塞尔曲线</p>
<img src="/GAMES101-lecture11/1619218405365.png" class="" width="1619218405365">

<img src="/GAMES101-lecture11/1619219434547.png" class="" width="1619219434547">

<img src="/GAMES101-lecture11/1619219450234.png" class="" width="1619219450234">

<img src="/GAMES101-lecture11/1619219466767.png" class="" width="1619219466767">



<h3 id="Evaluating-Bezier-curves-Algebraic-Formula"><a href="#Evaluating-Bezier-curves-Algebraic-Formula" class="headerlink" title="Evaluating Bezier curves Algebraic Formula"></a>Evaluating Bezier curves Algebraic Formula</h3><img src="/GAMES101-lecture11/1619219657592.png" class="" width="1619219657592">

<img src="/GAMES101-lecture11/1619219726540.png" class="" width="1619219726540">

<p>Bernstein polynomial（伯恩茨坦多项式）</p>
<img src="/GAMES101-lecture11/1619221543670.png" class="" width="1619221543670">

<p>可以扩充到更高纬的空间</p>
<img src="/GAMES101-lecture11/1619221746903.png" class="" width="1619221746903">

<h3 id="properties-of-bezier-curves"><a href="#properties-of-bezier-curves" class="headerlink" title="properties of bezier curves"></a>properties of bezier curves</h3><img src="/GAMES101-lecture11/1619225143564.png" class="" width="1619225143564">

<p>1、贝塞尔曲线必定经过起止点</p>
<p>2、在有四个点定义的贝塞尔曲线中性质，切线方向</p>
<p>3、仿射变换前求贝塞尔曲线，和变换后求贝塞尔曲线得到的曲线相同</p>
<p>4、凸包性质，所有点得到的贝塞尔曲线一定在凸包中</p>
<img src="/GAMES101-lecture11/1619225468284.png" class="" width="1619225468284">



<h3 id="piecewise-bezier-curves"><a href="#piecewise-bezier-curves" class="headerlink" title="piecewise bezier curves"></a>piecewise bezier curves</h3><p>分段贝塞尔曲线</p>
<img src="/GAMES101-lecture11/1619225732487.png" class="" width="1619225732487">

<p>两端的分段贝塞尔曲线</p>
<img src="/GAMES101-lecture11/1619226903353.png" class="" width="1619226903353">

<p>C0连续：只要首位相连即可</p>
<img src="/GAMES101-lecture11/1619227017802.png" class="" width="1619227017802">

<p>C1连续：即两处的切线方向一样，根据性质也就是两端长度相同</p>
<img src="/GAMES101-lecture11/1619226994144.png" class="" width="1619226994144">

<h1 id="other-types-of-spline"><a href="#other-types-of-spline" class="headerlink" title="other types of spline"></a>other types of spline</h1><p>样条：用一系列的点控制的曲线</p>
<img src="/GAMES101-lecture11/1619227195107.png" class="" width="1619227195107">

<h3 id="B-spline"><a href="#B-spline" class="headerlink" title="B-spline"></a>B-spline</h3><img src="/GAMES101-lecture11/1619227713287.png" class="" width="1619227713287">

<h1 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h1><h3 id="bezier-srface"><a href="#bezier-srface" class="headerlink" title="bezier srface"></a>bezier srface</h3><img src="/GAMES101-lecture11/1619228035459.png" class="" width="1619228035459">

<h3 id="bicubic-bezier-furface-patch"><a href="#bicubic-bezier-furface-patch" class="headerlink" title="bicubic bezier furface patch"></a>bicubic bezier furface patch</h3><img src="/GAMES101-lecture11/1619228080803.png" class="" width="1619228080803">

<h3 id="evaluating-bezier-surface"><a href="#evaluating-bezier-surface" class="headerlink" title="evaluating bezier surface"></a>evaluating bezier surface</h3><img src="/GAMES101-lecture11/1619228359397.png" class="" width="1619228359397">

<h3 id="mesh-operation"><a href="#mesh-operation" class="headerlink" title="mesh operation"></a>mesh operation</h3><img src="/GAMES101-lecture11/1619228496219.png" class="" width="1619228496219">]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES202-lecture02</title>
    <url>/GAMES202-lecture02/</url>
    <content><![CDATA[<p>racap of basic cg</p>
<a id="more"></a>

<h1 id="graphics-pipline"><a href="#graphics-pipline" class="headerlink" title="graphics pipline"></a>graphics pipline</h1><img src="/GAMES202-lecture02/1616471672442.png" class="" width="1616471672442">

<h1 id="opengl"><a href="#opengl" class="headerlink" title="opengl"></a>opengl</h1><h3 id="do-what"><a href="#do-what" class="headerlink" title="do what"></a>do what</h3><p>store model in <strong>VBO</strong>（vertex buffer object）</p>
<p>create/use a <strong>framebuffer</strong></p>
<p>one rendering <strong>pass</strong> in oepngl</p>
<img src="/GAMES202-lecture02/1616489958687.png" class="" width="1616489958687">

<h1 id="GLSL-opengl-shading-language"><a href="#GLSL-opengl-shading-language" class="headerlink" title="GLSL(opengl shading language)"></a>GLSL(opengl shading language)</h1><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><img src="/GAMES202-lecture02/1616490196419.png" class="" width="1616490196419">

<h3 id="vertex-和-fragment"><a href="#vertex-和-fragment" class="headerlink" title="vertex 和 fragment"></a>vertex 和 fragment</h3><p>vertex中定义顶点并进行插值操作</p>
<p>fragment中进行着色</p>
<h1 id="rendering-equation"><a href="#rendering-equation" class="headerlink" title="rendering equation"></a>rendering equation</h1><img src="/GAMES202-lecture02/1616495293911.png" class="" width="1616495293911">

<p>in real time rendering</p>
<img src="/GAMES202-lecture02/1616495417829.png" class="" width="1616495417829">

]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-lecture09</title>
    <url>/GAMES101-lecture09/</url>
    <content><![CDATA[<p>GAMES101-lecture09</p>
<a id="more"></a>

<h1 id="Barycentric-coordinates（重心坐标）"><a href="#Barycentric-coordinates（重心坐标）" class="headerlink" title="Barycentric coordinates（重心坐标）"></a>Barycentric coordinates（重心坐标）</h1><p>三角形内任意一点，都可以被A,B,C表示。但条件是系数都是非负数。</p>
<img src="/GAMES101-lecture09/1615945473863.png" class="" width="1615945473863">

<p>重心坐标如何求取？可以使用面积比来求得各自的系数，从而得到。</p>
<img src="/GAMES101-lecture09/1615945803511.png" class="" width="1615945803511">

<p>重心坐标计算公式</p>
<img src="/GAMES101-lecture09/1615987514281.png" class="" width="1615987514281">



<h1 id="Using-Barycentric-Coordinates"><a href="#Using-Barycentric-Coordinates" class="headerlink" title="Using Barycentric Coordinates"></a>Using Barycentric Coordinates</h1><p>三个顶点有属性V_A,V_B,V_C,使用重心坐标进行插值</p>
<img src="/GAMES101-lecture09/1615987594923.png" class="" width="1615987594923">

<p>三维空间中，要在三维空间中进行插值操作，而不是投影变换后，在二维空间中进行插值操作。因为投影变化，会让重心坐标改变。</p>
<h1 id="diffuse-color-texture-mapping"><a href="#diffuse-color-texture-mapping" class="headerlink" title="diffuse color texture mapping"></a>diffuse color texture mapping</h1><img src="/GAMES101-lecture09/1615988136628.png" class="" width="1615988136628">



<h1 id="Texture-magnification（texture-too-small）"><a href="#Texture-magnification（texture-too-small）" class="headerlink" title="Texture magnification（texture too small）"></a>Texture magnification（texture too small）</h1><p>texel是纹理上的像素。</p>
<p>pixel是图像上的像素。</p>
<img src="/GAMES101-lecture09/1616154589572.png" class="" width="1616154589572">

<h3 id="nearest"><a href="#nearest" class="headerlink" title="nearest"></a>nearest</h3><p>nearst时候，因为纹理过小，每个像素就会取最近的纹理像素上的内容，也就导致会变成方格状的图。</p>
<h3 id="bilinear"><a href="#bilinear" class="headerlink" title="bilinear"></a>bilinear</h3><p>双线性插值，并且红点的颜色和距离其最近的点更相似。</p>
<img src="/GAMES101-lecture09/1616156331778.png" class="" width="1616156331778">

<h3 id="bicubic"><a href="#bicubic" class="headerlink" title="bicubic"></a>bicubic</h3><p>取周围十六个点</p>
<h1 id="Texture-magnification（texture-too-large）"><a href="#Texture-magnification（texture-too-large）" class="headerlink" title="Texture magnification（texture too large）"></a>Texture magnification（texture too large）</h1><h3 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h3><img src="/GAMES101-lecture09/1616156543926.png" class="" width="1616156543926">

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>近距离一个图像像素覆盖的纹理像素少，远距离一个图像像素覆盖的纹理像素多 。</p>
<p>即一个图像像素内的纹理像素变化多，也就是有高频信号。</p>
<img src="/GAMES101-lecture09/1616156616469.png" class="" width="1616156616469">

<h1 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h1><p>生成不同的分辨率的图，而且存储量为原来的4/3，即只多出来1/3</p>
<img src="/GAMES101-lecture09/1616157099011.png" class="" width="1616157099011">

<h3 id="compute-mipmap-level"><a href="#compute-mipmap-level" class="headerlink" title="compute mipmap level"></a>compute mipmap level</h3><img src="/GAMES101-lecture09/1616160862037.png" class="" width="1616160862037">

<img src="/GAMES101-lecture09/1616160967236.png" class="" width="1616160967236">

<img src="/GAMES101-lecture09/1616161026226.png" class="" width="1616161026226">

<p>求出第几层后，该方形区域会变成一个像素的大小，就能够得到mipmap的层数</p>
<h3 id="visualization"><a href="#visualization" class="headerlink" title="visualization"></a>visualization</h3><img src="/GAMES101-lecture09/1616161247833.png" class="" width="1616161247833">

<h3 id="trilinear-interpolation"><a href="#trilinear-interpolation" class="headerlink" title="trilinear interpolation"></a>trilinear interpolation</h3><p>三线性插值，在层与层之间进行插值，即可得到非整数层的mipmap了</p>
<img src="/GAMES101-lecture09/1616161278735.png" class="" width="1616161278735">

<img src="/GAMES101-lecture09/1616161377697.png" class="" width="1616161377697">



<h1 id="anisotropic-filtering各向异性过滤"><a href="#anisotropic-filtering各向异性过滤" class="headerlink" title="anisotropic filtering各向异性过滤"></a>anisotropic filtering各向异性过滤</h1><p>即各个方向不同</p>
<h3 id="mipmap-problem"><a href="#mipmap-problem" class="headerlink" title="mipmap problem"></a>mipmap problem</h3><img src="/GAMES101-lecture09/1616161405367.png" class="" width="1616161405367">

<h3 id="anisotropic-filtering"><a href="#anisotropic-filtering" class="headerlink" title="anisotropic filtering"></a>anisotropic filtering</h3><p>可以用来解决矩形区域的问题</p>
<img src="/GAMES101-lecture09/1616161504413.png" class="" width="1616161504413">

<p>但是斜方向的长条形区域则不行</p>
<img src="/GAMES101-lecture09/1616161514680.png" class="" width="1616161514680">



<h1 id="EWA-filtering"><a href="#EWA-filtering" class="headerlink" title="EWA filtering"></a>EWA filtering</h1><img src="/GAMES101-lecture09/1616161597057.png" class="" width="1616161597057">

]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-lecture08</title>
    <url>/GAMES101-lecture08/</url>
    <content><![CDATA[<p>GAMES101-lecture08</p>
<a id="more"></a>

<h1 id="Specular-Term（Blinn-Phong）"><a href="#Specular-Term（Blinn-Phong）" class="headerlink" title="Specular Term（Blinn-Phong）"></a>Specular Term（Blinn-Phong）</h1><h3 id="phong模型"><a href="#phong模型" class="headerlink" title="phong模型"></a>phong模型</h3><p>如果直接计算R和v的夹脚，来判断两者的靠近程度，这个模型就是phong</p>
<img src="/GAMES101-lecture08/1615738559335.png" class="" width="1615738559335">

<h3 id="blinn-phong模型"><a href="#blinn-phong模型" class="headerlink" title="blinn-phong模型"></a>blinn-phong模型</h3><p>高光出现的角度，和n与半程向量h的靠近程度有关。靠近程度和夹脚的余弦有关。两个单位向量的余弦直接使用点乘记得获得。</p>
<img src="/GAMES101-lecture08/1615738903055.png" class="" width="1615738903055">

<p>为什么有指数</p>
<img src="/GAMES101-lecture08/1615743018549.png" class="" width="1615743018549">

<img src="/GAMES101-lecture08/1615743128274.png" class="" width="1615743128274">

<h1 id="Ambient-Term"><a href="#Ambient-Term" class="headerlink" title="Ambient Term"></a>Ambient Term</h1><img src="/GAMES101-lecture08/1615743242709.png" class="" width="1615743242709">



<h1 id="Blinn-Phong-Reflection-Model"><a href="#Blinn-Phong-Reflection-Model" class="headerlink" title="Blinn-Phong Reflection Model"></a>Blinn-Phong Reflection Model</h1><p><strong><img src="/GAMES101-lecture08/1615743402968.png" class="" width="1615743402968"></strong></p>
<h1 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h1><h3 id="Flat-shading"><a href="#Flat-shading" class="headerlink" title="Flat shading"></a>Flat shading</h3><img src="/GAMES101-lecture08/1615793879709.png" class="" width="1615793879709">

<h3 id="Gouraud-Shadig（vertex-shading）"><a href="#Gouraud-Shadig（vertex-shading）" class="headerlink" title="Gouraud Shadig（vertex shading）"></a>Gouraud Shadig（vertex shading）</h3><img src="/GAMES101-lecture08/1615795652539.png" class="" width="1615795652539">

<h3 id="Shade-each-pixel（Phong-Shading）"><a href="#Shade-each-pixel（Phong-Shading）" class="headerlink" title="Shade each pixel（Phong Shading）"></a>Shade each pixel（Phong Shading）</h3><img src="/GAMES101-lecture08/1615795957504.png" class="" width="1615795957504">

<h3 id="frequency"><a href="#frequency" class="headerlink" title="frequency"></a>frequency</h3><img src="/GAMES101-lecture08/1615796492023.png" class="" width="1615796492023">



<h1 id="normal-vectors"><a href="#normal-vectors" class="headerlink" title="normal vectors"></a>normal vectors</h1><h3 id="per-vertex-normal-vectors"><a href="#per-vertex-normal-vectors" class="headerlink" title="per-vertex normal vectors"></a>per-vertex normal vectors</h3><img src="/GAMES101-lecture08/1615796716408.png" class="" width="1615796716408">

<h3 id="per-pixel-normal-vectors"><a href="#per-pixel-normal-vectors" class="headerlink" title="per-pixel normal vectors"></a>per-pixel normal vectors</h3><img src="/GAMES101-lecture08/1615797005039.png" class="" width="1615797005039">

<h1 id="graphics-pipeline"><a href="#graphics-pipeline" class="headerlink" title="graphics pipeline"></a>graphics pipeline</h1><img src="/GAMES101-lecture08/1615797325611.png" class="" width="1615797325611">

<p>vertex processing和fragment processing都可以进行shading</p>
<p>比如gouroud shading 可以在vertex阶段，phong shading可以在fragment阶段</p>
<h1 id="shader-program"><a href="#shader-program" class="headerlink" title="shader program"></a>shader program</h1><img src="/GAMES101-lecture08/1615798585948.png" class="" width="1615798585948">



<h1 id="Texture-mapping"><a href="#Texture-mapping" class="headerlink" title="Texture mapping"></a>Texture mapping</h1><img src="/GAMES101-lecture08/1615803197879.png" class="" width="1615803197879">

<p>u，v的范围是0到1</p>
]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>动画和绘画</title>
    <url>/%E5%8A%A8%E7%94%BB%E5%92%8C%E7%BB%98%E7%94%BB/</url>
    <content><![CDATA[<p>动画和绘画</p>
<a id="more"></a>

<h1 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h1><p>要了解视平线和地平线。一幅图中只能存在一个视平线，所有物体的灭点都要在视平线上。</p>
<p>比如下图中书本的灭点位置就错误。</p>
<img src="/%E5%8A%A8%E7%94%BB%E5%92%8C%E7%BB%98%E7%94%BB/1615460617265.png" class="" width="1615460617265">

<h1 id="人体面部结构"><a href="#人体面部结构" class="headerlink" title="人体面部结构"></a>人体面部结构</h1><p>三庭五眼</p>
<h3 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h3><img src="/%E5%8A%A8%E7%94%BB%E5%92%8C%E7%BB%98%E7%94%BB/1615461429474.png" class="" width="1615461429474">

<img src="/%E5%8A%A8%E7%94%BB%E5%92%8C%E7%BB%98%E7%94%BB/1615461568828.png" class="" width="1615461568828">



<h3 id="耳朵"><a href="#耳朵" class="headerlink" title="耳朵"></a>耳朵</h3><img src="/%E5%8A%A8%E7%94%BB%E5%92%8C%E7%BB%98%E7%94%BB/1615466479359.png" class="" width="1615466479359">

]]></content>
      <categories>
        <category>绘画</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-lecture07</title>
    <url>/GAMES101-lecture07/</url>
    <content><![CDATA[<p>GAMES101 lecture07</p>
<a id="more"></a>

<h1 id="painter’s-algorithm"><a href="#painter’s-algorithm" class="headerlink" title="painter’s algorithm"></a>painter’s algorithm</h1><img src="/GAMES101-lecture07/1615311403742.png" class="" width="1615311403742">

<p>problem</p>
<img src="/GAMES101-lecture07/1615311738632.png" class="" width="1615311738632">

<h1 id="Z-BUFFER"><a href="#Z-BUFFER" class="headerlink" title="Z-BUFFER"></a>Z-BUFFER</h1><img src="/GAMES101-lecture07/1615311868687.png" class="" width="1615311868687">

<img src="/GAMES101-lecture07/1615311959709.png" class="" width="1615311959709">

<img src="/GAMES101-lecture07/1615312345863.png" class="" width="1615312345863">

<h3 id="透明测试"><a href="#透明测试" class="headerlink" title="透明测试"></a>透明测试</h3><p>透明测试不关深度测试，而会关闭深度写入。</p>
<h3 id="compexity"><a href="#compexity" class="headerlink" title="compexity"></a>compexity</h3><p>z-buffer算法的复杂度不高，并且与物体的顺序无关</p>
<img src="/GAMES101-lecture07/1615312745653.png" class="" width="1615312745653">

<h1 id="what-we-have-learned"><a href="#what-we-have-learned" class="headerlink" title="what we have learned"></a>what we have learned</h1><img src="/GAMES101-lecture07/1615313146029.png" class="" width="1615313146029">



<h1 id="shading"><a href="#shading" class="headerlink" title="shading"></a>shading</h1><h3 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h3><p>apply material to object</p>
<h3 id="blinn-phong-model"><a href="#blinn-phong-model" class="headerlink" title="blinn-phong model"></a>blinn-phong model</h3><img src="/GAMES101-lecture07/1615313526064.png" class="" width="1615313526064">

<h3 id="shading-in-local"><a href="#shading-in-local" class="headerlink" title="shading in local"></a>shading in local</h3><p>因为只表示方向，所以这三个向量都是<strong>单位向量</strong></p>
<img src="/GAMES101-lecture07/1615728546317.png" class="" width="1615728546317">

<p>local shading will not consider shadow</p>
<img src="/GAMES101-lecture07/1615728836418.png" class="" width="1615728836418">

<h3 id="diffuse-reflection"><a href="#diffuse-reflection" class="headerlink" title="diffuse reflection"></a>diffuse reflection</h3><img src="/GAMES101-lecture07/1615731371554.png" class="" width="1615731371554">

<p>光传播时候，根据能量守恒，任意时刻的圈上的能量强度之和应该相等。</p>
<p>由此可以得出，<strong>光照的强度和距离的平方成反比</strong></p>
<img src="/GAMES101-lecture07/1615733982052.png" class="" width="1615733982052">

<h3 id="lambertian-diffuse-shading"><a href="#lambertian-diffuse-shading" class="headerlink" title="lambertian diffuse shading"></a>lambertian diffuse shading</h3><p>某一点处接受的能量 * 光源到达该点的能量</p>
<p>0值无意义，故使用max（0，n·l）</p>
<img src="/GAMES101-lecture07/1615734134641.png" class="" width="1615734134641">]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-lecture06</title>
    <url>/GAMES101-lecture06/</url>
    <content><![CDATA[<p>GAMES101-lecture06</p>
<a id="more"></a>

<h1 id="artifact"><a href="#artifact" class="headerlink" title="artifact"></a>artifact</h1><img src="/GAMES101-lecture06/1615138287755.png" class="" width="1615138287755">

<h1 id="采样的问题"><a href="#采样的问题" class="headerlink" title="采样的问题"></a>采样的问题</h1><h3 id="moire-patterns-摩尔纹"><a href="#moire-patterns-摩尔纹" class="headerlink" title="moire patterns(摩尔纹)"></a>moire patterns(摩尔纹)</h3><img src="/GAMES101-lecture06/1615138353449.png" class="" width="1615138353449">

<h3 id="wagon-wheel"><a href="#wagon-wheel" class="headerlink" title="wagon wheel"></a>wagon wheel</h3><img src="/GAMES101-lecture06/1615139216266.png" class="" width="1615139216266">

<h3 id="reasons"><a href="#reasons" class="headerlink" title="reasons"></a>reasons</h3><img src="/GAMES101-lecture06/1615139360600.png" class="" width="1615139360600">



<h1 id="antialising"><a href="#antialising" class="headerlink" title="antialising"></a>antialising</h1><h3 id="pre-filter"><a href="#pre-filter" class="headerlink" title="pre-filter"></a>pre-filter</h3><img src="/GAMES101-lecture06/1615139419233.png" class="" width="1615139419233">

<img src="/GAMES101-lecture06/1615139467769.png" class="" width="1615139467769">

<img src="/GAMES101-lecture06/1615139477857.png" class="" width="1615139477857">

<img src="/GAMES101-lecture06/1615139621881.png" class="" width="1615139621881">

<h1 id="fourier-transformation"><a href="#fourier-transformation" class="headerlink" title="fourier transformation"></a>fourier transformation</h1><p>傅里叶变化和逆傅里叶变换（能够在<strong>时域和频域之间转换</strong>）</p>
<img src="/GAMES101-lecture06/1615140020023.png" class="" width="1615140020023">

<p>比如下图，右图中间代表低频信息，越往外代表高频信息。这张图表明左图的低频信息多，高频信息少。</p>
<p>图中的两条垂线，是因为做傅里叶变化时，是多个相同的图周期性排列的。那么相邻的两张图的边界，变化明显，也就会产生一个高频信号（即一张图的左右两边，相差过大）。</p>
<img src="/GAMES101-lecture06/1615141051720.png" class="" width="1615141051720">

<h3 id="高通滤波（high-pass-filter）"><a href="#高通滤波（high-pass-filter）" class="headerlink" title="高通滤波（high-pass filter）"></a>高通滤波（high-pass filter）</h3><p>将低频信号滤除后，发现高频信号可以显示出图像的边界</p>
<img src="/GAMES101-lecture06/1615141375139.png" class="" width="1615141375139">

<h3 id="low-pass-filter"><a href="#low-pass-filter" class="headerlink" title="low pass filter"></a>low pass filter</h3><p>去除了很多图像的细节</p>
<img src="/GAMES101-lecture06/1615141635670.png" class="" width="1615141635670">



<h3 id="filter-convolution"><a href="#filter-convolution" class="headerlink" title="filter = convolution"></a>filter = convolution</h3><img src="/GAMES101-lecture06/1615141855938.png" class="" width="1615141855938">

<p>滑动窗口进行移动，其作用类似于滤波</p>
<img src="/GAMES101-lecture06/1615141910329.png" class="" width="1615141910329">





<h3 id="convolution-theorem"><a href="#convolution-theorem" class="headerlink" title="convolution theorem"></a>convolution theorem</h3><img src="/GAMES101-lecture06/1615142036458.png" class="" width="1615142036458">

<p>时域的卷积等于频域的乘积</p>
<img src="/GAMES101-lecture06/1615142258129.png" class="" width="1615142258129">



<h3 id="box-function"><a href="#box-function" class="headerlink" title="box function"></a>box function</h3><img src="/GAMES101-lecture06/1615142771336.png" class="" width="1615142771336">

<img src="/GAMES101-lecture06/1615142786042.png" class="" width="1615142786042">

<p>越大的盒子，其低频信息越多，这样子进行滤波的话，就能够保留图片的低频信息了 </p>
<h1 id="（重要）采样误差的原因"><a href="#（重要）采样误差的原因" class="headerlink" title="（重要）采样误差的原因"></a>（重要）采样误差的原因</h1><p>采样会使得高频信息丢失，根据采样得到的离散数值，难以回复原始信息</p>
<img src="/GAMES101-lecture06/1615140420033.png" class="" width="1615140420033">

<h3 id="什么是aliases"><a href="#什么是aliases" class="headerlink" title="什么是aliases"></a>什么是aliases</h3><p>同样的采样方法，采样不同频率的信号，却得到了相同的函数，这种现象就叫走样（混叠、aliases）</p>
<img src="/GAMES101-lecture06/1615140669241.png" class="" width="1615140669241">

<h3 id="什么是filtering（滤波）"><a href="#什么是filtering（滤波）" class="headerlink" title="什么是filtering（滤波）"></a>什么是filtering（滤波）</h3><img src="/GAMES101-lecture06/1615140908934.png" class="" width="1615140908934">

<h1 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h1><h3 id="what-is-sampling"><a href="#what-is-sampling" class="headerlink" title="what is sampling"></a>what is sampling</h3><img src="/GAMES101-lecture06/1615142862147.png" class="" width="1615142862147">

<h3 id="冲激函数"><a href="#冲激函数" class="headerlink" title="冲激函数"></a>冲激函数</h3><p>左边是时域，右边是频域。时域的乘积等于频域的卷积。</p>
<img src="/GAMES101-lecture06/1615214969526.png" class="" width="1615214969526">

<p>频域的走样，频率的混叠，产生的就是锯齿</p>
<img src="/GAMES101-lecture06/1615215258954.png" class="" width="1615215258954">

<h1 id="antialiasing"><a href="#antialiasing" class="headerlink" title="antialiasing"></a>antialiasing</h1><img src="/GAMES101-lecture06/1615215372192.png" class="" width="1615215372192">

<p>频率就不会混叠了</p>
<img src="/GAMES101-lecture06/1615215411390.png" class="" width="1615215411390">

<h1 id="MSAA-antialiasing-by-supersampling"><a href="#MSAA-antialiasing-by-supersampling" class="headerlink" title="MSAA(antialiasing by supersampling)"></a>MSAA(antialiasing by supersampling)</h1><img src="/GAMES101-lecture06/1615228542677.png" class="" width="1615228542677">

<img src="/GAMES101-lecture06/1615228557984.png" class="" width="1615228557984">

<img src="/GAMES101-lecture06/1615228573746.png" class="" width="1615228573746">



<h1 id="different-antialiasing"><a href="#different-antialiasing" class="headerlink" title="different antialiasing"></a>different antialiasing</h1><img src="/GAMES101-lecture06/1615228517151.png" class="" width="1615228517151">]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>unity_bardent_tutorial</title>
    <url>/unity-bardent-tutorial/</url>
    <content><![CDATA[<p><a href="https://www.youtube.com/watch?v=bZVqz_3_NmQ&amp;list=PLy78FINcVmjA0zDBhLuLNL1Jo6xNMMq-W&amp;index=2" target="_blank" rel="noopener">https://www.youtube.com/watch?v=bZVqz_3_NmQ&amp;list=PLy78FINcVmjA0zDBhLuLNL1Jo6xNMMq-W&amp;index=2</a></p>
<p>该教程代码和项目结构清晰，很适合进一步的学习。</p>
<a id="more"></a>

<h1 id="1-player-controller"><a href="#1-player-controller" class="headerlink" title="1. player controller"></a>1. player controller</h1><h1 id="structures"><a href="#structures" class="headerlink" title="structures"></a>structures</h1><p>文件名和函数名，首字母全部大写</p>
<p>Scripts、Tile Map、Sprites、Scene、Animations</p>
<h1 id="PS-skills"><a href="#PS-skills" class="headerlink" title="PS skills"></a>PS skills</h1><ol>
<li><p>将hierarchy层的物体进行管理，比如相机全部放在cameras下方，tile map全部放在grid下方。</p>
</li>
<li><p>update里进行check，然后fixed update中进行物理运算</p>
</li>
<li><p>collidor的数值要尽量让数值的小数点位数减小</p>
</li>
<li><p>判断isGround的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果不加后面一句的话，overlap可能会在空中触发</span><br><span class="line">isGround &#x3D; Physics2D.OverlapCircle(groundCheck.position, groundCheckRadius, ground) &amp;&amp; (rb.velocity.y &lt;&#x3D; 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修复tile map闪烁的问题：要创建一个新的材质，选择sprites-》default并勾选pixel snap</p>
</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>2d</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity2DGeneralLearning</title>
    <url>/Unity2DGeneralLearning/</url>
    <content><![CDATA[<p>Unity2D游戏入门</p>
<p><a href="https://www.youtube.com/watch?v=youIM9zcFbs&amp;list=PL_Pb2I110MfGAsoqtDs8-6kEU55wU8CnE&amp;index=2" target="_blank" rel="noopener">https://www.youtube.com/watch?v=youIM9zcFbs&amp;list=PL_Pb2I110MfGAsoqtDs8-6kEU55wU8CnE&amp;index=2</a></p>
<a id="more"></a>

<h1 id="1-asset-store"><a href="#1-asset-store" class="headerlink" title="1.asset store"></a>1.asset store</h1><p>shift+空格，全屏</p>
<h1 id="2-Tilemap"><a href="#2-Tilemap" class="headerlink" title="2. Tilemap"></a>2. Tilemap</h1><p>每个网格中含有的像素的数量</p>
<img src="/Unity2DGeneralLearning/1614020841244.png" class="" width="1614020841244">

<p>如下进行切分</p>
<img src="/Unity2DGeneralLearning/1614025017574.png" class="" width="1614025017574">

<p>此外tilemap碰撞是对每个方块进行检测，这样子可能会卡在某个位置，这时候就可以添加composite collidor组件，并且勾选它</p>
<img src="/Unity2DGeneralLearning/1614055536635.png" class="" width="1614055536635">

<p>然后将rigidbody的bodytype更改为static即可防止场景受物理效果影响。</p>
<h1 id="3-layer-amp-char"><a href="#3-layer-amp-char" class="headerlink" title="3. layer&amp;char"></a>3. layer&amp;char</h1><p>分图层进行前后排序</p>
<p>物体添加rigid和collidor</p>
<h1 id="4-角色移动"><a href="#4-角色移动" class="headerlink" title="4.角色移动"></a>4.角色移动</h1><p>设置输入的按键</p>
<img src="/Unity2DGeneralLearning/1614026832900.png" class="" width="1614026832900">

<p>在试玩过程中更改参数的话，结束时不会更改参数。这个时候可以点击右上方的设置键，将其copy下来，之后再paste。</p>
<h1 id="5-角色的转向-amp-跳跃"><a href="#5-角色的转向-amp-跳跃" class="headerlink" title="5.角色的转向&amp;跳跃"></a>5.角色的转向&amp;跳跃</h1><p>转向即将scale属性的x变为负数就可以把图像翻转了</p>
<p>跳跃则更改y轴上的velocity即可</p>
<h1 id="6-animation"><a href="#6-animation" class="headerlink" title="6.animation"></a>6.animation</h1><p>add component中添加animator，之后创建一个animator controller并赋给他</p>
<p>之后再window-》animation窗口中进行动画的创建</p>
<p>之后将刚刚添加的animator component添加到脚本的Animator变量那一栏</p>
<p>has exit time和tensition duration可以用来控制动画的切换</p>
<h1 id="7-跳跃动画"><a href="#7-跳跃动画" class="headerlink" title="7.跳跃动画"></a>7.跳跃动画</h1><p>给平台添加layer</p>
<img src="/Unity2DGeneralLearning/1614106278085.png" class="" width="1614106278085">

<h3 id="8、镜头控制"><a href="#8、镜头控制" class="headerlink" title="8、镜头控制"></a>8、镜头控制</h3><p>使用cinemachine</p>
<p>deadzone进行延时追踪</p>
<p>add component的cinemachine confiner可以控制相机移动的边界。注意要给背景添加polygon collidor并勾选is trigger（使用ctrl加鼠标左键来删除一个点）。</p>
<img src="/Unity2DGeneralLearning/1614123025954.png" class="" width="1614123025954">

<img src="/Unity2DGeneralLearning/1614123096945.png" class="" width="1614123096945">

<h1 id="9-物品收集-amp-prefabs"><a href="#9-物品收集-amp-prefabs" class="headerlink" title="9.物品收集&amp;prefabs"></a>9.物品收集&amp;prefabs</h1><h1 id="10-物理材质-amp-二段跳"><a href="#10-物理材质-amp-二段跳" class="headerlink" title="10. 物理材质&amp;二段跳"></a>10. 物理材质&amp;二段跳</h1><p>当人物从侧面撞击物体时会产生摩擦，这样会让角色卡在物体的侧边</p>
<p>这时候就要使用物理材质，并将摩擦系数变为0，就可以解决这个问题</p>
<h1 id="31、dash残影"><a href="#31、dash残影" class="headerlink" title="31、dash残影"></a>31、dash残影</h1><p><a href="https://www.bilibili.com/video/BV1gJ411E7gx" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1gJ411E7gx</a></p>
<h3 id="1-对象池-object-pool"><a href="#1-对象池-object-pool" class="headerlink" title="1.对象池 object pool"></a>1.对象池 object pool</h3><p>当大量重复的物体需要创建和销毁时，否则物品过多则会导致内存溢出</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h3 id="tilemap的分层"><a href="#tilemap的分层" class="headerlink" title="tilemap的分层"></a>tilemap的分层</h3>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-lecture04</title>
    <url>/GAMES101-lecture04/</url>
    <content><![CDATA[<p>GAMES101-lecture04</p>
<a id="more"></a>

<p>一个矩阵的<strong>逆矩阵</strong>正交矩阵和<strong>转置矩阵</strong>相同，那么这个矩阵就是正交矩阵。正交矩阵可以简化逆矩阵的计算过程。</p>
<p>比如旋转矩阵就是一个正交矩阵。</p>
<img src="/GAMES101-lecture04/1614017709080.png" class="" width="1614017709080">

<h1 id="1-3D-transformation"><a href="#1-3D-transformation" class="headerlink" title="1.3D transformation"></a>1.3D transformation</h1><img src="/GAMES101-lecture04/1614216091756.png" class="" width="1614216091756">

<p>绕x轴，x不变，其他的同理</p>
<img src="/GAMES101-lecture04/1614216118974.png" class="" width="1614216118974">

<p>循环对称，x叉乘z与y轴方向相反，所以绕y旋转的矩阵以其他的不同</p>
<h3 id="复杂旋转"><a href="#复杂旋转" class="headerlink" title="复杂旋转"></a>复杂旋转</h3><img src="/GAMES101-lecture04/1614216359230.png" class="" width="1614216359230">

<p>rotation by any angle</p>
<p>n默认过原点</p>
<img src="/GAMES101-lecture04/1614216503083.png" class="" width="1614216503083">

<p>如果要绕任意轴旋转，则可以先把物体移动到原点，然后旋转再移动回去原点。</p>
<h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><h1 id="2-View-Camera-Transformation"><a href="#2-View-Camera-Transformation" class="headerlink" title="2. View/Camera Transformation"></a>2. View/Camera Transformation</h1><h3 id="MVP-transformation"><a href="#MVP-transformation" class="headerlink" title="MVP transformation"></a>MVP transformation</h3><p>将三维空间投射到二维空间上</p>
<img src="/GAMES101-lecture04/1614935757322.png" class="" width="1614935757322">



<h3 id="define-the-camera"><a href="#define-the-camera" class="headerlink" title="define the camera"></a>define the camera</h3><img src="/GAMES101-lecture04/1614935934053.png" class="" width="1614935934053">

<p>therefore we regular that <strong>the camera is always looking at -Z，and its up is Y</strong></p>
<img src="/GAMES101-lecture04/1614936233659.png" class="" width="1614936233659">

<h3 id="modelview-transformation"><a href="#modelview-transformation" class="headerlink" title="modelview transformation"></a>modelview transformation</h3><p>steps to transform camera from current status to normal status</p>
<img src="/GAMES101-lecture04/1614937844589.png" class="" width="1614937844589">

<p>先使用平移矩阵，将相机移动到原点。然后在相机进行旋转。</p>
<p>这里考虑从标准坐标旋转到相机的坐标的矩阵，三个坐标分别使用了投影变化。</p>
<p>然后再考虑他的逆矩阵，同时<strong>旋转矩阵是正交矩阵，他的逆矩阵是他的转置</strong></p>
<p>最后也就得到了<strong>视图变化</strong>的矩阵</p>
<img src="/GAMES101-lecture04/1614937874900.png" class="" width="1614937874900">



<h1 id="3-Projection-Transformation"><a href="#3-Projection-Transformation" class="headerlink" title="3. Projection Transformation"></a>3. Projection Transformation</h1><h3 id="perspective-projection-amp-amp-orthographic-projection"><a href="#perspective-projection-amp-amp-orthographic-projection" class="headerlink" title="perspective projection &amp;&amp; orthographic projection"></a>perspective projection &amp;&amp; orthographic projection</h3><img src="/GAMES101-lecture04/1614938486315.png" class="" width="1614938486315">

<h3 id="orthographic-projection"><a href="#orthographic-projection" class="headerlink" title="orthographic projection"></a>orthographic projection</h3><img src="/GAMES101-lecture04/1614938582557.png" class="" width="1614938582557">

<h3 id="canonical-cube"><a href="#canonical-cube" class="headerlink" title="canonical  cube"></a>canonical  cube</h3><p>下图是将方块转化成<strong>canonical（标准）cube</strong></p>
<p>右边的矩阵将方块移动到原点，左边的矩阵将方块的边长转变为2（因为要变成范围是【-1,1】的立方体）</p>
<img src="/GAMES101-lecture04/1614939095955.png" class="" width="1614939095955">



<h1 id="perspective-projection"><a href="#perspective-projection" class="headerlink" title="perspective projection"></a>perspective projection</h1><h3 id="homogeneous-property"><a href="#homogeneous-property" class="headerlink" title="homogeneous property"></a>homogeneous property</h3><img src="/GAMES101-lecture04/1614939604962.png" class="" width="1614939604962">

<h3 id="how-to-do"><a href="#how-to-do" class="headerlink" title="how to do"></a>how to do</h3><img src="/GAMES101-lecture04/1614940865084.png" class="" width="1614940865084">

<img src="/GAMES101-lecture04/1614959231626.png" class="" width="1614959231626">]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>上交游戏实训</title>
    <url>/%E4%B8%8A%E4%BA%A4%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%AE%AD/</url>
    <content><![CDATA[<p>上交游戏实训</p>
<a id="more"></a>

<h1 id="1-day-one-（策划）"><a href="#1-day-one-（策划）" class="headerlink" title="1. day one （策划）"></a>1. day one （策划）</h1><p>游戏类型的考虑不该只限于电子游戏</p>
<p>棋类和牌类的区别在于位置、区域限制、信息差</p>
<p>游戏的<strong>障碍</strong>要根据角色的能力来设置。</p>
<p>成长系统可以帮助玩家更容易通过障碍。</p>
<p>策划过程可以使用思维导图进行头脑风暴，然后再进行适当的简化和省略</p>
<h1 id="2-day-two（计划制定）"><a href="#2-day-two（计划制定）" class="headerlink" title="2. day two（计划制定）"></a>2. day two（计划制定）</h1><p><strong>整体</strong></p>
<p>游戏类型：act</p>
<p>剧情：根据素材</p>
<p>世界观：根据素材</p>
<p><strong>功能方面</strong></p>
<p>角色：方向、跳跃、二段跳、近身攻击、远程攻击、攀爬</p>
<p>场景：场景切换、障碍、伤害判定、地图机关</p>
<p>敌人：敌人ai、敌人视野、敌人活动范围</p>
<p>ui：开始界面、菜单、游戏结束界面</p>
<p>美术：使用素材+自己补充</p>
<p><strong>资料方面</strong></p>
<p>basic</p>
<p><a href="https://space.bilibili.com/370283072/channel/detail?cid=85776" target="_blank" rel="noopener">https://space.bilibili.com/370283072/channel/detail?cid=85776</a></p>
<p>advance</p>
<p><a href="https://space.bilibili.com/370283072/channel/detail?cid=91017" target="_blank" rel="noopener">https://space.bilibili.com/370283072/channel/detail?cid=91017</a></p>
<p>water shader</p>
<p><a href="https://www.youtube.com/watch?v=ym1K3of3pys" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ym1K3of3pys</a></p>
<p>wall jump</p>
<p><a href="https://www.youtube.com/watch?v=uNJanDrjMgU&amp;list=PLj6G-3M0NXNVYrRh9By9J8m52Cydg8RBS&amp;index=5" target="_blank" rel="noopener">https://www.youtube.com/watch?v=uNJanDrjMgU&amp;list=PLj6G-3M0NXNVYrRh9By9J8m52Cydg8RBS&amp;index=5</a></p>
<h1 id="day-four"><a href="#day-four" class="headerlink" title="day four"></a>day four</h1><p>游戏要围绕<strong>核心玩法</strong></p>
<p>倾听能力</p>
<img src="/%E4%B8%8A%E4%BA%A4%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%AE%AD/1614219363326.png" class="" width="1614219363326">

<p>倾听团队内部人的声音</p>
<p>对投资人的钱负责</p>
<p>要对游戏进行测试</p>
<p>挖掘爱好</p>
<h3 id="游戏制作过程"><a href="#游戏制作过程" class="headerlink" title="游戏制作过程"></a>游戏制作过程</h3><img src="/%E4%B8%8A%E4%BA%A4%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%AE%AD/1614221354770.png" class="" width="1614221354770">

<p>国内由右向左发展了。</p>
<p>要接触预研阶段，因为后续的工业阶段比的是生产力。</p>
<p>ps：最好叫美术，而不是美工</p>
<h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><img src="/%E4%B8%8A%E4%BA%A4%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%AE%AD/1614222094549.png" class="" width="1614222094549">

<h3 id="技术中心"><a href="#技术中心" class="headerlink" title="技术中心"></a>技术中心</h3><img src="/%E4%B8%8A%E4%BA%A4%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%AE%AD/1614222162806.png" class="" width="1614222162806">

<h3 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h3><img src="/%E4%B8%8A%E4%BA%A4%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%AE%AD/1614222478755.png" class="" width="1614222478755">]]></content>
  </entry>
  <entry>
    <title>GAMES101-lecture03</title>
    <url>/GAMES101-lecture03/</url>
    <content><![CDATA[<p>GAMES101-lecture03</p>
<a id="more"></a>

<p>正运动学：已知各关节角度，求末端位姿</p>
<p>逆运动学（ik inverse kinematics）：已知末端的位姿，求各关节角度</p>
<h1 id="1-Scale-Transform"><a href="#1-Scale-Transform" class="headerlink" title="1. Scale Transform"></a>1. Scale Transform</h1><img src="/GAMES101-lecture03/1613952924942.png" class="" width="1613952924942">

<p>矩阵形式：</p>
<img src="/GAMES101-lecture03/1613952946188.png" class="" width="1613952946188">

<h1 id="2-reflection-matrix"><a href="#2-reflection-matrix" class="headerlink" title="2. reflection matrix"></a>2. reflection matrix</h1><p>翻转操作</p>
<img src="/GAMES101-lecture03/1613953170086.png" class="" width="1613953170086">

<h1 id="3-shear-matrix"><a href="#3-shear-matrix" class="headerlink" title="3.shear matrix"></a>3.shear matrix</h1><p>切变变化</p>
<img src="/GAMES101-lecture03/1613996992953.png" class="" width="1613996992953">

<h1 id="4-rotate"><a href="#4-rotate" class="headerlink" title="4.rotate"></a>4.rotate</h1><p>简单的带入推导</p>
<img src="/GAMES101-lecture03/1613998941741.png" class="" width="1613998941741">

<h1 id="5-translation"><a href="#5-translation" class="headerlink" title="5.translation"></a>5.translation</h1><p>向量平移不变，所以要把向量和点区分开来，所以最后一位不同。</p>
<img src="/GAMES101-lecture03/1614001015219.png" class="" width="1614001015219">

<p>扩充定义里两个点之和表示两个点的中点</p>
<img src="/GAMES101-lecture03/1614001288284.png" class="" width="1614001288284">

<h1 id="6-Affine-Transform（仿射变换）"><a href="#6-Affine-Transform（仿射变换）" class="headerlink" title="6. Affine Transform（仿射变换）"></a>6. Affine Transform（仿射变换）</h1><p>指经过一次变换并且平移的变换</p>
<img src="/GAMES101-lecture03/1614001407053.png" class="" width="1614001407053">

<img src="/GAMES101-lecture03/1614001547985.png" class="" width="1614001547985">

<h1 id="7-Inverse-matrix"><a href="#7-Inverse-matrix" class="headerlink" title="7.Inverse matrix"></a>7.Inverse matrix</h1><h1 id="8-composing-transform"><a href="#8-composing-transform" class="headerlink" title="8. composing transform"></a>8. composing transform</h1><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>为了<strong>效率</strong>，需要将矩阵先全部乘起来再计算。</p>
<img src="/GAMES101-lecture03/1614002003202.png" class="" width="1614002003202">

<h3 id="绕着给顶点旋转变换"><a href="#绕着给顶点旋转变换" class="headerlink" title="绕着给顶点旋转变换"></a>绕着给顶点旋转变换</h3><p>怪不得一个物体绕另一个物体旋转，都得先转到局部坐标系，再转会世界坐标系？</p>
<img src="/GAMES101-lecture03/1614002326532.png" class="" width="1614002326532">]]></content>
  </entry>
  <entry>
    <title>GAMES101-lecture02</title>
    <url>/GAMES101-lecture02/</url>
    <content><![CDATA[<p>GAMES101 lecture2</p>
<a id="more"></a>

<h1 id="1-dot-product"><a href="#1-dot-product" class="headerlink" title="1. dot product"></a>1. dot product</h1><img src="/GAMES101-lecture02/1613925737323.png" class="" width="1613925737323">

<h3 id="dot-product-for-projection"><a href="#dot-product-for-projection" class="headerlink" title="dot product for projection"></a>dot product for projection</h3><img src="/GAMES101-lecture02/1613925766266.png" class="" width="1613925766266">

<img src="/GAMES101-lecture02/1613925847563.png" class="" width="1613925847563">

<h3 id="measure-how-close"><a href="#measure-how-close" class="headerlink" title="measure how close"></a>measure how close</h3><img src="/GAMES101-lecture02/1613925916233.png" class="" width="1613925916233">

<h1 id="2-cross-product"><a href="#2-cross-product" class="headerlink" title="2. cross product"></a>2. cross product</h1><img src="/GAMES101-lecture02/1613925977092.png" class="" width="1613925977092">

<h3 id="矩阵表示叉乘和点乘"><a href="#矩阵表示叉乘和点乘" class="headerlink" title="矩阵表示叉乘和点乘"></a>矩阵表示叉乘和点乘</h3><img src="/GAMES101-lecture02/1613926158204.png" class="" width="1613926158204">

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>判定p是否在三角形内部（可以应用于技能范围的判定等）</p>
<img src="/GAMES101-lecture02/1613926017482.png" class="" width="1613926017482">

<h1 id="3-坐标系定义"><a href="#3-坐标系定义" class="headerlink" title="3. 坐标系定义"></a>3. 坐标系定义</h1><img src="/GAMES101-lecture02/1613926082718.png" class="" width="1613926082718">]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-lecture01</title>
    <url>/GAMES101-lecture01/</url>
    <content><![CDATA[<p>GAMES lecture01</p>
<a id="more"></a>

<h1 id="1、typography"><a href="#1、typography" class="headerlink" title="1、typography"></a>1、typography</h1><p>字体测试</p>
<p>英文测试：The quick brown fox jumps over the lazy dog</p>
<p>中文测试：我能吞下玻璃而不伤身体</p>
<h1 id="2、Course-topics"><a href="#2、Course-topics" class="headerlink" title="2、Course topics"></a>2、Course topics</h1><ul>
<li><p>Rasterization（光栅化）</p>
<p>光栅化即把三维空间的几何形体显示在屏幕上的过程</p>
<img src="/GAMES101-lecture01/1613784680482.png" class="" width="1613784680482">
</li>
<li><p>curves and meshes</p>
</li>
<li><p>ray tracing</p>
</li>
<li><p>animation/simulation</p>
</li>
</ul>
<h1 id="3-cg-amp-cv"><a href="#3-cg-amp-cv" class="headerlink" title="3. cg &amp; cv"></a>3. cg &amp; cv</h1><img src="/GAMES101-lecture01/1613785345655.png" class="" width="1613785345655">

]]></content>
      <categories>
        <category>computer graphics</category>
      </categories>
      <tags>
        <tag>computer graphics</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT整理</title>
    <url>/PAT%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>PAT题型的整理</p>
<a id="more"></a>

<h1 id="模拟题"><a href="#模拟题" class="headerlink" title="模拟题"></a>模拟题</h1><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h3 id="静态树"><a href="#静态树" class="headerlink" title="静态树"></a>静态树</h3><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><p>PAT1034</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> INF = <span class="number">10000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> weight[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visited[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//建立映射关系</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; string2int;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; int2string;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; gang;<span class="comment">//头目，人数</span></span><br><span class="line"><span class="comment">//number, weight threshold</span></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="comment">//编号,人数</span></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string2Int</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(string2int.<span class="built_in">find</span>(str)!=string2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> string2int[str];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        string2int[str] = idx;</span><br><span class="line">        int2string[idx] = str;</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">return</span> idx<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历连通块，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>&amp; head,<span class="keyword">int</span>&amp; memNum, <span class="keyword">int</span>&amp; totalVal)</span></span>&#123;</span><br><span class="line">    visited[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//比较点权，确认头目</span></span><br><span class="line">    <span class="keyword">if</span>(weight[i]&gt;weight[head]) head = i;</span><br><span class="line">    <span class="comment">//成员人数</span></span><br><span class="line">    memNum+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;idx;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//添加边权</span></span><br><span class="line">            totalVal+=G[i][j];</span><br><span class="line">            <span class="comment">//防止有环，删除边</span></span><br><span class="line">            G[i][j] = G[j][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                DFS(j,head,memNum,totalVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历图，获取每个连通块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traveDFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> head = i, memNum=<span class="number">0</span>, totalVal=<span class="number">0</span>;</span><br><span class="line">            DFS(i,head,memNum,totalVal);</span><br><span class="line">            <span class="built_in">string</span> headStr = int2string[head];</span><br><span class="line">            <span class="keyword">if</span>(totalVal&gt;k&amp;&amp;memNum&gt;<span class="number">2</span>)</span><br><span class="line">                gang[headStr] = memNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> name1, name2;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;name1&gt;&gt;name2&gt;&gt;time;</span><br><span class="line">        <span class="keyword">int</span> id1 = string2Int(name1);</span><br><span class="line">        <span class="keyword">int</span> id2 = string2Int(name2);</span><br><span class="line">        weight[id1]+=time;</span><br><span class="line">        weight[id2]+=time;</span><br><span class="line">        G[id1][id2]+=time;</span><br><span class="line">        G[id2][id1]+=time;</span><br><span class="line">    &#125;</span><br><span class="line">    traveDFS();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;gang.<span class="built_in">size</span>()&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=gang.<span class="built_in">begin</span>();it!=gang.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>PAT 1076</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> user[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> depth,<span class="keyword">int</span> &amp;cnt)</span></span>&#123;</span><br><span class="line">    <span class="comment">//level超过了</span></span><br><span class="line">    <span class="keyword">if</span>(depth&gt;l+<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">if</span>(depth&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="comment">//        if(visited[G[i][j]]==false)&#123;</span></span><br><span class="line">            DFS(G[i][j],depth+<span class="number">1</span>,cnt);</span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFStrave</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fill</span>(visited+<span class="number">1</span>,visited+n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    DFS(i,depth+<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count(visited+<span class="number">1</span>,visited+n+<span class="number">1</span>,<span class="literal">true</span>)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="comment">//id从1到n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="comment">//id从1到n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">            G[id].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">        DFStrave(id,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="djisktra"><a href="#djisktra" class="headerlink" title="djisktra"></a>djisktra</h3><p>1030 Travel Plan</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,s,d;</span><br><span class="line"><span class="keyword">int</span> G_dis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> G_cost[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn]; <span class="comment">//total dis</span></span><br><span class="line"><span class="keyword">int</span> cost[maxn]; <span class="comment">//total cost</span></span><br><span class="line"><span class="keyword">int</span> visited[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> parent[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    cost[s]=<span class="number">0</span>;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="comment">//update</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="literal">false</span>&amp;&amp;MIN&gt;dis[j])&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        visited[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//scan</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v]==<span class="literal">false</span>&amp;&amp;G_dis[u][v]!=INF)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&gt;dis[u]+G_dis[u][v])&#123;</span><br><span class="line">                    cost[v] = cost[u]+G_cost[u][v];</span><br><span class="line">                    dis[v] = dis[u]+G_dis[u][v];</span><br><span class="line">                    parent[v] = u;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[v]==dis[u]+G_dis[u][v])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cost[v] &gt; cost[u]+G_cost[u][v])&#123;</span><br><span class="line">                        cost[v] = cost[u]+G_cost[u][v];</span><br><span class="line">                        dis[v] = dis[u]+G_dis[u][v];</span><br><span class="line">                        parent[v] = u;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(dis,dis+maxn,INF);</span><br><span class="line">    <span class="built_in">fill</span>(cost,cost+maxn,INF);</span><br><span class="line">    <span class="built_in">fill</span>(G_dis[<span class="number">0</span>],G_dis[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line">    <span class="built_in">fill</span>(G_cost[<span class="number">0</span>],G_cost[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line">    <span class="built_in">fill</span>(parent,parent+maxn,INF);</span><br><span class="line">    <span class="comment">//读入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c1,c2,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;c1,&amp;c2,&amp;b,&amp;c);</span><br><span class="line">        G_dis[c1][c2] = b;</span><br><span class="line">        G_dis[c2][c1] = b;</span><br><span class="line">        G_cost[c1][c2] = c;</span><br><span class="line">        G_cost[c2][c1] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    dij(s);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> curPath=d;</span><br><span class="line">    path.push(curPath);</span><br><span class="line">    <span class="keyword">while</span>(curPath!=s)&#123;</span><br><span class="line">        curPath=parent[curPath];</span><br><span class="line">        path.push(curPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,path.top());</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,dis[d],cost[d]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3>]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>保研复习：图形学</title>
    <url>/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E5%9B%BE%E5%BD%A2%E5%AD%A6/</url>
    <content><![CDATA[<p>保研图形学复习</p>
<a id="more"></a>

<h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><p>应用阶段（输出渲染图元到几何阶段）、几何阶段（输出屏幕空间的坐标信息到光栅化阶段）、光栅化阶段</p>
<h1 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h1><p>GPU的流水线过程：</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E5%9B%BE%E5%BD%A2%E5%AD%A6/1600174842293.png" class="" width="1600174842293">



<p>顶点着色器：把顶点坐标从模型空间转化到齐次裁剪空间</p>
<p>屏幕映射：把每个图元的x和y坐标转化到屏幕坐标系</p>
<p>光栅化阶段：计算每个图元覆盖了哪些像素，以及为这些像素计算他们的颜色</p>
]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT1052</title>
    <url>/PAT1052/</url>
    <content><![CDATA[<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464</a></p>
<a id="more"></a>

<h1 id="1-自己的"><a href="#1-自己的" class="headerlink" title="1.自己的"></a>1.自己的</h1><ol>
<li>没有考虑到会有无效节点（该节点不在head所在的链表中）</li>
<li>当输入节点全部是无效节点时</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> addr;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;nodes[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Node&amp; a, Node&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.addr==<span class="number">-1</span>||b.addr==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.addr&gt;b.addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.value&lt;b.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        nodes[i].addr = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> head,N;</span><br><span class="line">    <span class="keyword">int</span> a,key,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;head);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;key,&amp;b);</span><br><span class="line">        nodes[a] = &#123;a,key,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nodes,nodes+<span class="number">100000</span>,cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %05d\n"</span>,N,nodes[<span class="number">0</span>].addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes[i+<span class="number">1</span>].addr!=<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,nodes[i].addr,nodes[i].value,nodes[i+<span class="number">1</span>].addr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d -1"</span>,nodes[i].addr,nodes[i].value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-别人的"><a href="#2-别人的" class="headerlink" title="2.别人的"></a>2.别人的</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> addr;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="comment">//是否在当前链表中</span></span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;nodes[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        nodes[i].flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Node&amp; a, Node&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.flag==<span class="literal">false</span>||b.flag==<span class="literal">false</span>) <span class="keyword">return</span> a.flag&gt;b.flag;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.key&lt;b.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head, N;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N, &amp;head);</span><br><span class="line">    <span class="keyword">int</span> a,k,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;k,&amp;b);</span><br><span class="line">        nodes[a].addr = a;</span><br><span class="line">        nodes[a].key = k;</span><br><span class="line">        nodes[a].next = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head;i!=<span class="number">-1</span>;i=nodes[i].next)&#123;</span><br><span class="line">        nodes[i].flag = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 -1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sort(nodes,nodes+maxn,cmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %05d\n"</span>,cnt,nodes[<span class="number">0</span>].addr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes[i+<span class="number">1</span>].flag!=<span class="literal">false</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,nodes[i].addr,nodes[i].key,nodes[i+<span class="number">1</span>].addr);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>,nodes[i].addr,nodes[i].key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>PAT</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT1032：sharing</title>
    <url>/PAT1032%EF%BC%9Asharing/</url>
    <content><![CDATA[<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920</a></p>
<a id="more"></a>

<h1 id="1-自己的"><a href="#1-自己的" class="headerlink" title="1.自己的"></a>1.自己的</h1><ol>
<li>有个测试点过不了</li>
<li>要注意scanf(“%d %c %d”,&amp;addr,&amp;cur_data,&amp;cur_nextAddr)加上空格，否则%c会读取输入中的空格</li>
<li>scanf读取0001会得到1</li>
<li>printf(“%05d”,minusOne)会得到-0001</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> nextAddr;</span><br><span class="line">&#125;nodes[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">        nodes[i].address = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    Node* head1, *head2;</span><br><span class="line">    <span class="keyword">int</span> addr1, addr2;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;addr1,&amp;addr2,&amp;N);</span><br><span class="line">    head1 = &amp;nodes[addr1];</span><br><span class="line">    head2 = &amp;nodes[addr2];</span><br><span class="line">    <span class="keyword">int</span> addr,cur_nextAddr;</span><br><span class="line">    <span class="keyword">char</span> cur_data;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>,&amp;addr,&amp;cur_data,&amp;cur_nextAddr);</span><br><span class="line">        nodes[addr].data = cur_data;</span><br><span class="line">        nodes[addr].nextAddr = cur_nextAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur1 = head1, *cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> common_addr=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur1-&gt;nextAddr!=<span class="number">-1</span>||cur2-&gt;nextAddr!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">            common_addr = cur1-&gt;address;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1-&gt;nextAddr==<span class="number">-1</span>)&#123;</span><br><span class="line">            cur1 =head2;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur2-&gt;nextAddr==<span class="number">-1</span>)&#123;</span><br><span class="line">            cur2=head1;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = &amp;nodes[cur1-&gt;nextAddr];</span><br><span class="line">        cur2 = &amp;nodes[cur2-&gt;nextAddr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur1-&gt;nextAddr==<span class="number">-1</span>&amp;&amp;cur2-&gt;nextAddr==<span class="number">-1</span>&amp;&amp;cur1==cur2) common_addr = cur1-&gt;address;</span><br><span class="line">    <span class="keyword">if</span>(common_addr!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>,common_addr);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-别人的"><a href="#2-别人的" class="headerlink" title="2.别人的"></a>2.别人的</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> addr;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> nextAddr;</span><br><span class="line">    <span class="comment">//记录是否访问</span></span><br><span class="line">    <span class="keyword">bool</span> isVisited;</span><br><span class="line">&#125;nodes[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head1, head2,N;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;head1,&amp;head2,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>,&amp;a,&amp;c,&amp;b);</span><br><span class="line">        nodes[a] = &#123;a,c,b,<span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> common_addr=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head1;i!=<span class="number">-1</span>;i=nodes[i].nextAddr)&#123;</span><br><span class="line">        nodes[i].isVisited = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head2;i!=<span class="number">-1</span>;i=nodes[i].nextAddr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes[i].isVisited == <span class="literal">true</span>)&#123;</span><br><span class="line">            common_addr = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(common_addr==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d"</span>,common_addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>PAT</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>保研复习：操作系统</title>
    <url>/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>保研操作系统复习</p>
<a id="more"></a>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h3 id="1-操作系统内核的功能"><a href="#1-操作系统内核的功能" class="headerlink" title="1.操作系统内核的功能"></a>1.操作系统内核的功能</h3><p>系统调用接口、进程管理、内存管理、文件系统管理、设备驱动</p>
<h1 id="2-BIOS和CMOS"><a href="#2-BIOS和CMOS" class="headerlink" title="2.BIOS和CMOS"></a>2.BIOS和CMOS</h1><p>CMOS是记录各项硬件参数且嵌在主板上的存储器</p>
<p>BIOS是写入到主板上的一个固件（固件就是写入到硬件上的一个软件）</p>
<p>MBR主引导程序</p>
<p>流程：</p>
<p>计算机自动从BIOS会去硬盘中读取CMOS设置，之后交付给MBR。MBR告诉计算机从某一个分区来装载boot loader，随后boot loader就会帮助我们加载内核（kernel），内核文件就会开始启动操作系统。</p>
]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>保研机试</title>
    <url>/%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95/</url>
    <content><![CDATA[<p>保研机试的整理</p>
<a id="more"></a>

<p>PAT刷题：</p>
<p>胡凡《算法笔记》</p>
<p>柳婼的博客</p>
]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>PAT</tag>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>保研复习：面试</title>
    <url>/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>从网上搜索的保研面试问题整理</p>
<a id="more"></a>

<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h1><p><a href="https://www.jianshu.com/p/40c0e0f93d13" target="_blank" rel="noopener">https://www.jianshu.com/p/40c0e0f93d13</a></p>
<ol>
<li><p>计算机网络（TCP/IP分层，包括每层的功能；报文交换与分组交换的区别）；</p>
</li>
<li><p>数据结构（常见的排序算法，举例并说明时间复杂度）；</p>
</li>
<li><p>项目（做过哪些项目，主要负责的部分，用到的语言，接着会问该语言的各种知识点）</p>
</li>
<li><p>离散的全序，偏序  <a href="https://blog.csdn.net/liuchuo/article/details/51986226" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/51986226</a></p>
</li>
<li><p>红黑树 √</p>
<p><a href="https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note</a></p>
<p>五个性质：<a href="https://zhuanlan.zhihu.com/p/60478979" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60478979</a></p>
</li>
<li><p>AVL树</p>
</li>
</ol>
<ol start="7">
<li><p>堆的实现：<a href="https://blog.csdn.net/happyjacob/article/details/83270786" target="_blank" rel="noopener">https://blog.csdn.net/happyjacob/article/details/83270786</a></p>
</li>
<li><p>两个正太分布相加还是不是正态分布</p>
</li>
<li><p>排序算法</p>
</li>
<li><p>报文交换和分组交换<a href="https://blog.csdn.net/weixin_42859280/article/details/83116359" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42859280/article/details/83116359</a>  √</p>
</li>
<li><p>数据库的三种锁<a href="https://blog.csdn.net/xyw591238/article/details/51918729" target="_blank" rel="noopener">https://blog.csdn.net/xyw591238/article/details/51918729</a>  √</p>
</li>
<li><p>偏序集合和全序集合<a href="https://blog.csdn.net/liuchuo/article/details/51986226" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/51986226</a></p>
</li>
<li><p>interupt和system call的区别：<a href="http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.aspx" target="_blank" rel="noopener">http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.aspx</a></p>
</li>
<li><p>基数排序和计数排序</p>
</li>
<li><p>数据库事务的特性和隔离级别：<a href="https://www.cnblogs.com/jian-gao/p/10795407.html" target="_blank" rel="noopener">https://www.cnblogs.com/jian-gao/p/10795407.html</a></p>
<p><a href="https://blog.csdn.net/gaopu12345/article/details/50868501?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">https://blog.csdn.net/gaopu12345/article/details/50868501?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
</li>
<li><p>数据库完整性约束：<a href="https://blog.csdn.net/u013634252/article/details/80696882" target="_blank" rel="noopener">https://blog.csdn.net/u013634252/article/details/80696882</a></p>
</li>
<li><p>链表和数组</p>
</li>
<li><p>动态规划和分治法的区别：<a href="https://zhidao.baidu.com/question/1945805938926194788.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1945805938926194788.html</a></p>
</li>
<li><p>内存的分配：<a href="https://zhidao.baidu.com/question/567742466.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/567742466.html</a></p>
</li>
<li><p>贝叶斯公式：</p>
</li>
<li><p>虚拟内存：<a href="https://blog.csdn.net/qq_30137611/article/details/66478426?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">https://blog.csdn.net/qq_30137611/article/details/66478426?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
</li>
<li><p>NP问题：</p>
</li>
<li><p>快速排序的时间复杂度：</p>
</li>
<li><p>死锁：<a href="https://blog.csdn.net/u014419806/article/details/52856589" target="_blank" rel="noopener">https://blog.csdn.net/u014419806/article/details/52856589</a></p>
</li>
<li><p>BIOS是什么：<a href="https://zhuanlan.zhihu.com/p/89058949?utm_source=qq" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/89058949?utm_source=qq</a></p>
</li>
<li><p>进程和线程<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E9%9D%A2%E8%AF%95/1601998468100.png" class="" width="1601998468100"></p>
</li>
<li><p>数据库三种模式</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E9%9D%A2%E8%AF%95/1601998628390.png" class="" width="1601998628390">
</li>
<li><p><a href="https://www.doc88.com/p-2532402403451.html" target="_blank" rel="noopener">https://www.doc88.com/p-2532402403451.html</a></p>
</li>
<li><p>NP问题：<a href="https://blog.csdn.net/qwer7512090/article/details/93720209" target="_blank" rel="noopener">https://blog.csdn.net/qwer7512090/article/details/93720209</a></p>
</li>
<li><p>动态规划的基本思想：<a href="https://www.cnblogs.com/wlw-x/p/12591363.html" target="_blank" rel="noopener">https://www.cnblogs.com/wlw-x/p/12591363.html</a></p>
</li>
<li><p>分治法的基本思想：<a href="https://blog.csdn.net/qq_41678225/article/details/100707762" target="_blank" rel="noopener">https://blog.csdn.net/qq_41678225/article/details/100707762</a></p>
</li>
<li><p>主键、超键、候选键：<a href="https://www.cnblogs.com/lumnm/archive/2010/11/08/1871783.html" target="_blank" rel="noopener">https://www.cnblogs.com/lumnm/archive/2010/11/08/1871783.html</a></p>
</li>
<li><p>分段和分页：<a href="https://blog.csdn.net/wangshihui512/article/details/9897683?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">https://blog.csdn.net/wangshihui512/article/details/9897683?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
</li>
<li><p>数据库总结1：<a href="https://blog.csdn.net/snowbaby1234/article/details/81238760?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/snowbaby1234/article/details/81238760?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p>
</li>
<li><p>数据库总结2：<a href="https://blog.csdn.net/tzy3013218117/article/details/51569183" target="_blank" rel="noopener">https://blog.csdn.net/tzy3013218117/article/details/51569183</a></p>
</li>
<li><p>数据库五范式：<a href="https://blog.csdn.net/huzhaomu945/article/details/52821755?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">https://blog.csdn.net/huzhaomu945/article/details/52821755?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
</li>
</ol>
<h1 id="2-项目"><a href="#2-项目" class="headerlink" title="2.项目"></a>2.项目</h1><h3 id="mfc项目"><a href="#mfc项目" class="headerlink" title="mfc项目"></a>mfc项目</h3><p>mfc前端、采集卡传输视频流、opencv进行模板匹配、端口传出鼠标信号信息来控制另外一台计算机。</p>
<h3 id="管理系统项目"><a href="#管理系统项目" class="headerlink" title="管理系统项目"></a>管理系统项目</h3><p>前端：vue+element-ui+stylus</p>
<p>vuex</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E9%9D%A2%E8%AF%95/vuex.png" class="" title="vuex">

<p>后端：nodejs+express</p>
<p>部署：阿里云+nginx+pm2</p>
<p><strong>前端</strong></p>
<p>修改el-collapse样式时比较麻烦，chrome控制台分析标签调整了属性。</p>
<p><strong>数据库</strong></p>
<p>mysql、设计时</p>
<p><strong>部署</strong></p>
<h3 id="爬虫项目"><a href="#爬虫项目" class="headerlink" title="爬虫项目"></a>爬虫项目</h3><p>前端：vue+echarts+element-ui+stylus</p>
<p>后端：flask+jieba分词</p>
<p>部署：阿里云+gunicorn+nginx+screen</p>
<p><strong>前端</strong></p>
<p>无跳闪刷新</p>
<p>临时变量的存储session storage</p>
<p>组间通信：vuex</p>
<p>echarts：使用axios获取后端传输的数据</p>
<p><strong>后端</strong></p>
<p>request爬虫，寻找b站api，放入请求头然后爬取</p>
<p>下载弹幕文件之后进行分析，再将最终数据转化成json数据传输回去</p>
<p><strong>部署</strong></p>
<p>SSH远程连接云服务器</p>
<p>gunicorn帮助后端和前端进行通信</p>
<p>screen让linux能够管理多窗口</p>
<p>nginx进行端口代理</p>
<h1 id="3-竞赛"><a href="#3-竞赛" class="headerlink" title="3.竞赛"></a>3.竞赛</h1><h3 id="数学建模："><a href="#数学建模：" class="headerlink" title="数学建模："></a>数学建模：</h3><p>优化模型：决策变量、目标函数、约束条件</p>
<p>首先进行假设</p>
<p><strong>题目一：</strong></p>
<p>高压燃油系统分为三个部分：⾼压油泵、⾼压油管与外界</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E9%9D%A2%E8%AF%95/1601087777934.png" class="" width="1601087777934">

<p>离散化后，计算各个部分燃油流量</p>
<p>变化函数是分段函数，所以使用求模运算来进行分段</p>
<p>离散化后，求出密度的各个量，进行拟合</p>
<p>使用方波模拟单向阀的开闭</p>
<p>进行单目标规划：</p>
<p>​    决策变量：单向闸开启持续时间</p>
<p>​    目标函数：<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E9%9D%A2%E8%AF%95/1601089038324.png" class="" width="1601089038324"></p>
<p>调整T的变化步长，进行遍历求解（最小二乘法）</p>
<p>空间分割</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E9%9D%A2%E8%AF%95/1601090427906.png" class="" width="1601090427906">]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>保研复习：计算机网络</title>
    <url>/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>保研复习：计算机网络</p>
<a id="more"></a>

<h1 id="别人的整理"><a href="#别人的整理" class="headerlink" title="别人的整理"></a>别人的整理</h1><p><a href="https://zhuanlan.zhihu.com/p/118504254" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/118504254</a></p>
<h1 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h1><h3 id="osi七层协议"><a href="#osi七层协议" class="headerlink" title="osi七层协议"></a>osi七层协议</h3><p>物理层</p>
<p>数据链路层：802.11、ethernet</p>
<p>网络层：icmp、ip、NAT</p>
<p>传输层：tcp、udp</p>
<p>会话层：建立回话</p>
<p>表示层：传递信息的语法和语义</p>
<p>应用层：http、https、dns、pop3、ftp、smtp、telnet</p>
<h3 id="ip-tcp协议"><a href="#ip-tcp协议" class="headerlink" title="ip/tcp协议"></a>ip/tcp协议</h3><p>链路层</p>
<p>互联网层</p>
<p>传输层</p>
<p>应用层</p>
<h3 id="各个层的设备"><a href="#各个层的设备" class="headerlink" title="各个层的设备"></a>各个层的设备</h3><img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-d3b45716d2f500c2.png" class="" title="图片.png">

<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-5466b5f883e62f6b.png" class="" title="图片.png">

<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>服务：为上一层提供什么样的服务（做什么）</p>
<p>接口：告诉上面的进程如何访问本层</p>
<p>协议：</p>
<h3 id="端到端和点到点"><a href="#端到端和点到点" class="headerlink" title="端到端和点到点"></a>端到端和点到点</h3><p><a href="https://www.cnblogs.com/beyond_dxb/archive/2018/01/17/8304093.html" target="_blank" rel="noopener">https://www.cnblogs.com/beyond_dxb/archive/2018/01/17/8304093.html</a></p>
<p><a href="https://blog.csdn.net/qq_34940959/article/details/78583993" target="_blank" rel="noopener">https://blog.csdn.net/qq_34940959/article/details/78583993</a></p>
<p>传输层提供端到端的服务</p>
<p>数据链路层、网络层提供点到点的服务</p>
<p>传输层让应用进程之间进行通信</p>
<blockquote>
<h3 id="一、点到点"><a href="#一、点到点" class="headerlink" title="一、点到点"></a>一、点到点</h3><p>　　点到点是<strong>物理拓扑</strong>，如光纤，就必须是点到点连接，DDN专线也是，即两头各一个机器中间不能有机器。<strong>点到点是网络层的</strong>，你传输层只认为我的数据是从a直接到e的，但实际不是这样的，打个比方，传输层好象领导，他发布命令：要干什么什么事，但真正干的不是他，真正干的是员工，也许领导认为很简单一句话就可以干好的事，在员工眼里却是难于登天，手续极其烦琐，所以传输层是发布命令的领导，他说的是命令，也就是最终的目的，所以他只看到最初的地址和最终的地址，既一个任务的两个端点，网络层就相当于员工，领导的任务我要一步一步的做完，先从a到b,在从b到c…,所以他看到的只是整个任务的一个阶段，a到b,b到c…这就是点到点。 </p>
<h3 id="二、端到端"><a href="#二、端到端" class="headerlink" title="二、端到端"></a>二、端到端</h3><p>　　端到端是网络连接。网络要通信，必须建立连接，不管有多远，中间有多少机器，都必须在两头（源和目的）间建立连接，一旦连接建立起来，就说已经是端到端连接了，即端到端是<strong>逻辑链路</strong>，这条路可能经过了很复杂的物理路线，但两端主机不管，只认为是有两端的连接，而且一旦通信完成，这个连接就释放了，物理线路可能又被别的应用用来建立连接了。TCP就是用来建立这种端到端连接的一个具体协议，SPX也是。<strong>端到端是传输层的</strong>，你比如你要将数据从A传送到E，中间可能经过A-&gt;B-&gt;C-&gt;D-&gt;E,对于传输层来说他并不知道B,C,D的存在，他只认为我的报文数据是从A直接到E的，这就叫做端到端。 总之，一句话概括就是端到端是由无数的点到点实现和组成的。</p>
<h3 id="三、联系与区别"><a href="#三、联系与区别" class="headerlink" title="三、联系与区别"></a>三、联系与区别</h3><p>　　端到端与点到点是针对网络中传输的两端设备间的关系而言的。端到端传输指的是在数据传输前，经过各种各样的交换设备，在两端设备问建立<strong>一条链路</strong>，就像它们是直接相连的一样，链路建立后，发送端就可以发送数据，直至数据发送完毕，接收端确认接收成功。点到点系统指的是发送端把数据传给与它直<strong>接相连的设备</strong>，这台设备在合适的时候又把数据传给与之直接相连的下一台设备，通过一台一台直接相连的设备，把数据传到接收端。 </p>
<p>　　端到端传输的优点是链路建立后，发送端知道接收设备一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。端到端传输的缺点是直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。端到端传输的另一个缺点是如果接收设备关机或故障，那么端到端传输不可能实现。点到点传输的优点是发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。另外，即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。在一个网络系统的不同分层中，可能用到端到端传输，也可能用到点到点传输。如Internet网，IP及以下各层采用点到点传输，4层以上采用端到端传输。</p>
</blockquote>
<hr>
<blockquote>
<p>数据传输的可靠性是通过数据链路层和网络层的点对点和传输层的端对端保证的。端到端与点到点是针对网络中传输的两端设备间的关系而言的。</p>
<p>端到端通信</p>
<p>端到端通信是针对传输层来说的，它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据，知道数据发送完毕，接收端确认接收成功。 也就是说在数据传输之前，先为数据的传输开辟一条通道，然后在进行传输。从发送端发出数据到接收端接收完毕，结束。</p>
<p>端到端的优点：</p>
<p>链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。</p>
<p>端到端传输的缺点：</p>
<p>（1）直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。</p>
<p>（2）如果接收设备关机或故障，那么端到端传输不可能实现。</p>
<p>点到点通信</p>
<p>点到点通信是针对数据链路层或网络层来说的，点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。</p>
<p>点到点的优点：</p>
<p>（1）发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。</p>
<p>（2）即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。</p>
<p>点到点的缺点：</p>
<p>点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。 </p>
</blockquote>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-e910de6c95e13d9c.png" class="" title="图片.png">

<h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h3><p>localhost和127.0.0.1的区别是bai，一个du是域名，一个是IP地址。</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>传输比特流</p>
<p>傅里叶分析：任何一个周期为T的函数都能表示为正弦函数和余弦函数的无穷级数</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1599650148995.png" class="" width="1599650148995">



<h3 id="数据传输速率："><a href="#数据传输速率：" class="headerlink" title="数据传输速率："></a>数据传输速率：</h3><p>尼奎斯特、香农公式</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1599650199489.png" class="" width="1599650199489">

<h3 id="传信速率和传码速率"><a href="#传信速率和传码速率" class="headerlink" title="传信速率和传码速率"></a>传信速率和传码速率</h3><img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1599650465352.png" class="" width="1599650465352">



<h3 id="基带传输和通带传输"><a href="#基带传输和通带传输" class="headerlink" title="基带传输和通带传输"></a>基带传输和通带传输</h3><p>基带传输：传输占有所有的频率</p>
<p>通带传输：传输占有给定的一段频带</p>
<h3 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h3><p>频分复用（FDM）：将频谱分成几段进行传输，比如正交频分复用用于802.11</p>
<p>时分复用（TDM）：输入流的比特从固定的时间槽取出</p>
<p>码分复用（CDM）：码分多址（CDMA），使用码片序列来传输信息，码片序列表示1，反码表示0</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1599651287738.png" class="" width="1599651287738">

<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>电路交换、数据包交换</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>数据链路层进行<strong>差错控制</strong>，<strong>流量控制</strong>和<strong>传输数据帧</strong></p>
<p>传输帧（帧头、数据包、帧尾），对物理层的比特流进行检测</p>
<p><strong>控制</strong>：错误控制、流量控制</p>
<p>提供的<strong>服务</strong>：无确认的无连接服务、有确认的无连接服务、有确认的有连接服务</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-0bc74e07861a171a.png" class="" title="图片.png">

<h3 id="纠错码和检错码（error-detection-and-correction）"><a href="#纠错码和检错码（error-detection-and-correction）" class="headerlink" title="纠错码和检错码（error detection and correction）"></a>纠错码和检错码（error detection and correction）</h3><p><strong>纠错码：</strong></p>
<p>汉明</p>
<p><strong>检错码：</strong></p>
<p>奇偶校验码（1bit的数目是偶数还是奇数）</p>
<p>CRC循环冗余校验码、多项式编码</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-7c48e15fb5c173e8.png" class="" title="图片.png">

<h3 id="数据链路层的协议"><a href="#数据链路层的协议" class="headerlink" title="数据链路层的协议"></a>数据链路层的协议</h3><p>数据链路层是设置在网卡和网卡驱动上的</p>
<p>传输层将报文传送给网络层，网络层添加了报头后成为数据包并传送给数据链路层，数据链路层再加上帧头和帧尾成为帧。</p>
<p>停-等协议（stop-and-wait）：发送发发送一帧，等待对方确认后才能继续发送</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-6291f0b8a66ee4ff.png" class="" title="图片.png">

<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-20ff33d7df2a8f77.png" class="" title="图片.png">

<p>一位滑动窗口、回退N、选择重传</p>
<h1 id="介质访问控制子层-MAC"><a href="#介质访问控制子层-MAC" class="headerlink" title="介质访问控制子层(MAC)"></a>介质访问控制子层(MAC)</h1><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>MAC层是数据链路层的一个子层，用来控制多路访问信道（广播），在LAN中有很大的作用</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-14a44e40ba9bd414.png" class="" title="图片.png">

<h3 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h3><img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-2e7e6f05bb6eea5b.png" class="" title="图片.png">



<h3 id="载波侦听协议"><a href="#载波侦听协议" class="headerlink" title="载波侦听协议"></a>载波侦听协议</h3><p>CSMA和CSMA/CD（带冲突检测的CSMA）</p>
<p>冲突避免collision free，csma/ca就是冲突避免算法之一</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1599965057489.png" class="" width="1599965057489">

<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>实现了</p>
<ol>
<li><p>点到点的数据的传输</p>
</li>
<li><p>路由的选择、寻址问题</p>
</li>
</ol>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>迪杰斯特拉、泛洪算法、距离向量（动态、缓存大）、链路状态路由（动态、缓存小）</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>ICMP：返回错误信息、查看traceroute，比如ping命令</p>
<p>ARP：将ip地址映射到以太网地址</p>
<p>DHCP：给主机分配本地ip地址</p>
<p>数据链路层地址：以太网地址\MAC地址\物理地址\网卡地址<br>传输层地址：端口<br>应用层地址：域名<br>ARP: IP地址-&gt;MAC地址<br>RARP: MAC地址-&gt;IP地址</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层提供端口到端口的传输</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-191b998bc55655b8.png" class="" title="图片.png">

<p>三次握手</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-e795af663be052da.png" class="" title="图片.png">

<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-7496d811a9aca7d3.png" class="" title="图片.png">

<p>TCP的连接建立过程</p>
<img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-b9a57433b4e65233.png" class="" title="图片.png">

<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17071720-a407ca9c74f33d1a.png" class="" title="图片.png">

<p>2)循环冗余校验码<br>3)发送方发送的数据序列是什么<br>11010110111110<br>4)检测过程<br>接收方使用校验码除以接受的数据，余数为0则无差错</p>
]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>保研</tag>
      </tags>
  </entry>
  <entry>
    <title>post213：打家劫舍2</title>
    <url>/post213%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>leetcode337：打家劫舍3</title>
    <url>/leetcode337%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/</url>
    <content><![CDATA[<img src="/leetcode337%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/1599621481548.png" class="" width="1599621481548">

<a id="more"></a>

<h1 id="1-错误代码"><a href="#1-错误代码" class="headerlink" title="1.错误代码"></a>1.错误代码</h1><p>自己的代码中使用了后续遍历，可以发现结果明显不对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memos;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = rob(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = rob(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> not_rob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rob_here = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left&amp;&amp;!root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> not_rob = left;</span><br><span class="line">            <span class="keyword">int</span> rob_here = left-root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left&amp;&amp;root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> not_rob = right;</span><br><span class="line">            <span class="keyword">int</span> rob_here = right-root-&gt;right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> not_rob = left+right;</span><br><span class="line">            <span class="keyword">int</span> rob_here = right-root-&gt;right-&gt;val + left-root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if(!root-&gt;left&amp;&amp;!root-&gt;right)</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> not_rob = left+right;</span><br><span class="line">            <span class="keyword">int</span> rob_here = right+left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = rob_here&gt;not_rob?rob_here:not_rob;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h1><p>这道题主要是将<strong>子树</strong>看成一个状态</p>
<ul>
<li><p>如果偷了当前节点，那么两个子节点都不能偷，只能偷左右子节点的子节点。</p>
</li>
<li><p>如果不偷当前节点，那么就能偷左右子节点</p>
</li>
</ul>
<p>又因为是树，所以使用递归解决</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memos;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> not_rob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rob_here = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果偷当前节点，要考虑左右子节点是否为空</span></span><br><span class="line">        <span class="comment">//左子节点不空</span></span><br><span class="line">        rob_here += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            rob_here += rob(root-&gt;left-&gt;left)+rob(root-&gt;left-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子节点不空</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            rob_here += rob(root-&gt;right-&gt;left)+rob(root-&gt;right-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不偷当前节点</span></span><br><span class="line">        not_rob += (rob(root-&gt;left)+rob(root-&gt;right));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">max</span>(rob_here,not_rob);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-动规"><a href="#3-动规" class="headerlink" title="3.动规"></a>3.动规</h1><p>那么只要用一个备忘录来记录每个节点对应的能偷得的最大值，就可以进行剪枝。</p>
<p>这里并不适合使用有顺序的数组，因为很难确认当前节点在数组中的顺序，那么就可以使用一个hash表来记录节点对应的值,最后得到的代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(root)!=<span class="built_in">map</span>.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="built_in">map</span>[root];</span><br><span class="line">        <span class="keyword">int</span> not_rob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rob_here = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果偷当前节点，要考虑左右子节点是否为空</span></span><br><span class="line">        <span class="comment">//左子节点不空</span></span><br><span class="line">        rob_here += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            rob_here += rob(root-&gt;left-&gt;left)+rob(root-&gt;left-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子节点不空</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            rob_here += rob(root-&gt;right-&gt;left)+rob(root-&gt;right-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不偷当前节点</span></span><br><span class="line">        not_rob += (rob(root-&gt;left)+rob(root-&gt;right));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">max</span>(rob_here,not_rob);</span><br><span class="line">        <span class="built_in">map</span>[root] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-自底向上的动规"><a href="#4-自底向上的动规" class="headerlink" title="4.自底向上的动规"></a>4.自底向上的动规</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt; rob_map, not_rob_map;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rob(root-&gt;left);</span><br><span class="line">        rob(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> rob_here = not_rob_map[root-&gt;left]+not_rob_map[root-&gt;right]+root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> not_rob = <span class="built_in">max</span>(rob_map[root-&gt;left], not_rob_map[root-&gt;left]) + <span class="built_in">max</span>(rob_map[root-&gt;right], not_rob_map[root-&gt;right]);</span><br><span class="line">        rob_map[root] = rob_here;</span><br><span class="line">        not_rob_map[root] = not_rob;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rob_here,not_rob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>官方：</p>
<img src="/leetcode337%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/1599671171737.png" class="" width="1599671171737">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode*, <span class="keyword">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(o-&gt;left);</span><br><span class="line">        dfs(o-&gt;right);</span><br><span class="line">        f[o] = o-&gt;val + g[o-&gt;left] + g[o-&gt;right];</span><br><span class="line">        g[o] = <span class="built_in">max</span>(f[o-&gt;left], g[o-&gt;left]) + <span class="built_in">max</span>(f[o-&gt;right], g[o-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        dfs(o);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f[o], g[o]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/house-robber-iii/solution/da-jia-jie-she-iii-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode543：二叉树的直径</title>
    <url>/leetcode543%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<img src="/leetcode543%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/1599548012298.png" class="" width="1599548012298">

<a id="more"></a>

<p>这一题本质就是求节点的深度，只要在求深度的过程中将左右节点的深度相加起来就能构成一个直径，那么最大直径也就是在这一系列数中求出最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> max_diameter = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(node-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(node-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = left&gt;right?left:right;</span><br><span class="line">        <span class="keyword">int</span> sum = left+right;</span><br><span class="line">        <span class="keyword">if</span>(max_diameter&lt;sum) max_diameter = sum;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> max_diameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode滑动窗口总结</title>
    <url>/leetcode%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>滑动窗口问题解决的一般都是子串问题，而子串(substring)问题要区别于子序列(subsquence)问题，因为他是一个连续的字符串</p>
<p>本文记录leetcode中的滑动窗口问题</p>
<a id="more"></a>

<p>思考问题方面，最长子串适合先移动右指针，然后移动左指针；最小子串则适合先移动左指针，再移动右指针。</p>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        <span class="keyword">int</span> max_len = INT_MIN;</span><br><span class="line">        <span class="keyword">char</span> left = s[<span class="number">0</span>], right=s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(s[j])!=<span class="built_in">map</span>.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len,j-i+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>[s[j]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len==INT_MIN?s.length():max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = INT_MIN;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="comment">//移动左指针    </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">set</span>.erase(s[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">                 <span class="comment">//出现了重复字符</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(s[right])!=<span class="built_in">set</span>.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len,right-i+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">set</span>.insert(s[right]);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode581：最短无序连续子数组</title>
    <url>/leetcode581%EF%BC%9A%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<img src="/leetcode581%EF%BC%9A%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/1599528657686.png" class="" width="1599528657686">

<a id="more"></a>

<p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/</a></p>
<h1 id="1-暴力求解"><a href="#1-暴力求解" class="headerlink" title="1.暴力求解"></a>1.暴力求解</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span>=INT_MAX, <span class="built_in">max</span>=INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> min_index = <span class="number">0</span>, max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">min</span> = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;<span class="built_in">min</span>) &#123;</span><br><span class="line">                    min_index = j;</span><br><span class="line">                    <span class="built_in">min</span> = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min_index!=i)&#123;</span><br><span class="line">                left = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line">                    max_index = j;</span><br><span class="line">                    <span class="built_in">max</span> = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_index!=i)&#123;</span><br><span class="line">                right=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">-1</span>&amp;&amp;right==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">-1</span>) <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="number">-1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>()-left;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode538：把二叉搜索树转化为累加树</title>
    <url>/leetcode538%EF%BC%9A%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<img src="/leetcode538%EF%BC%9A%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/1599542593285.png" class="" width="1599542593285">

<a id="more"></a>

<p>本题的实质就是对二叉搜索树进行中序遍历，只不过是从大到小进行遍历</p>
<h1 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        root-&gt;val=sum;</span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty()||cur)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(cur);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = <span class="built_in">stack</span>.top();<span class="built_in">stack</span>.pop();</span><br><span class="line">            </span><br><span class="line">            sum += cur-&gt;val;</span><br><span class="line">            cur-&gt;val = sum;</span><br><span class="line"></span><br><span class="line">            cur=cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-morris"><a href="#3-morris" class="headerlink" title="3. morris"></a>3. morris</h1><p>原始的morris会修改树的结构，所以这里需要进行额外的工作</p>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/solution/ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-jia-shu-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/solution/ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-jia-shu-3/</a></p>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode47：全排列2</title>
    <url>/leetcode47%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%972/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a></p>
<p>首先要画出树状图，对回溯过程有个总体的把握</p>
<img src="/leetcode47%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%972/1599441319956.png" class="" width="1599441319956">

<h1 id="1-使用set"><a href="#1-使用set" class="headerlink" title="1. 使用set"></a>1. 使用set</h1><p>使用set记录重复的数组，效率较低</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_res;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> visited[n];</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">        backTrack(nums,visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span>* visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp_res.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.<span class="built_in">find</span>(tmp_res)!=<span class="built_in">set</span>.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            res.push_back(tmp_res);</span><br><span class="line">            <span class="built_in">set</span>.insert(tmp_res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp_res.push_back(nums[i]);</span><br><span class="line">            visited[i]=<span class="number">1</span>;</span><br><span class="line">            backTrack(nums,visited);</span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">            tmp_res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-减枝"><a href="#2-减枝" class="headerlink" title="2. 减枝"></a>2. 减枝</h1><p>对树结构进行减枝</p>
<p>首先要对数组进行排序，这是这道题目进行减枝的前提。然后剪枝的条件有两个：</p>
<ol>
<li>当前数字和同一层的前一个数字相等</li>
<li>当前数字刚刚被回溯过</li>
</ol>
<p>从而得到：<code>if(i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1]) continue</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序是进行剪枝的基础</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//记录访问过的数字</span></span><br><span class="line">        <span class="keyword">int</span> used[nums.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="comment">//记录数字的排列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        backtrack(used,path,nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>* used, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;!used[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            backtrack(used,path,nums);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode77：组合</title>
    <url>/leetcode77%EF%BC%9A%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>leetcode461：汉明距离</title>
    <url>/leetcode461%EF%BC%9A%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<img src="/leetcode461%EF%BC%9A%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/1599200336219.png" class="" width="1599200336219">

<a id="more"></a>

<h1 id="1-简单的遍历解决"><a href="#1-简单的遍历解决" class="headerlink" title="1.简单的遍历解决"></a>1.简单的遍历解决</h1><h1 id="2-布赖恩·克尼根算法"><a href="#2-布赖恩·克尼根算法" class="headerlink" title="2.布赖恩·克尼根算法"></a>2.布赖恩·克尼根算法</h1><p><a href="https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dis=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> xor_ = x^y;</span><br><span class="line">        <span class="keyword">while</span>(xor_)&#123;</span><br><span class="line">            dis++;</span><br><span class="line">            xor_=xor_&amp;(xor_<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>bit</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode283：移动零</title>
    <url>/leetcode283%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<img src="/leetcode283%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6/1599181851289.png" class="" width="1599181851289">

<a id="more"></a>

<p><a href="https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/</a></p>
<h1 id="双指针两次遍历"><a href="#双指针两次遍历" class="headerlink" title="双指针两次遍历"></a>双指针两次遍历</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录非零元素移动到的位置</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后剩余位全部清零</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-单次遍历"><a href="#2-单次遍历" class="headerlink" title="2.单次遍历"></a>2.单次遍历</h1><img src="/leetcode283%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6/1599184372552.png" class="" width="1599184372552">

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode51：N皇后</title>
    <url>/leetcode51%EF%BC%9AN%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<img src="/leetcode51%EF%BC%9AN%E7%9A%87%E5%90%8E/1599126704827.png" class="" width="1599126704827">

<img src="/leetcode51%EF%BC%9AN%E7%9A%87%E5%90%8E/1599126714532.png" class="" width="1599126714532">

<a id="more"></a>

<p>回溯法的模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>具体的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//储存最终的结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solutions;</span><br><span class="line">        <span class="comment">//记录queens在每一行的列位置</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(n,<span class="built_in">string</span>(n,<span class="string">'.'</span>));</span><br><span class="line">        backtrack(solutions,board,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> solutions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右上角</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断左上角</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; solutions, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board,<span class="keyword">int</span> n, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            solutions.push_back(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(board,row,i,n))&#123;</span><br><span class="line">                board[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                backtrack(solutions,board,n,row+<span class="number">1</span>);</span><br><span class="line">                board[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>back track</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode46：全排列</title>
    <url>/leetcode46%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<img src="/leetcode46%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97/1599133232771.png" class="" width="1599133232771">

<a id="more"></a>

<p>回溯法一般使用一个visited数组来记录已经访问的节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>* visited, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(track.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.push_back(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//没被访问才进行    </span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                track.push_back(nums[i]);</span><br><span class="line">                visited[i]=<span class="number">1</span>;</span><br><span class="line">                backtrack(visited,res,nums,track);</span><br><span class="line">                track.pop_back();</span><br><span class="line">                visited[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//使用visisted记录访问过的节点</span></span><br><span class="line">        <span class="keyword">int</span> visited[n];</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(n)*nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        backtrack(visited,res,nums,track);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>back track</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode787：K站中转内最便宜的航班</title>
    <url>/leetcode787%EF%BC%9AK%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/</url>
    <content><![CDATA[<img src="/leetcode787%EF%BC%9AK%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/1599053043638.png" class="" width="1599053043638">

<img src="/leetcode787%EF%BC%9AK%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/1599053056607.png" class="" width="1599053056607">

<a id="more"></a>

<h1 id="1-迪杰斯特拉算法"><a href="#1-迪杰斯特拉算法" class="headerlink" title="1.迪杰斯特拉算法"></a>1.迪杰斯特拉算法</h1><h3 id="1-迪杰斯特拉算法-1"><a href="#1-迪杰斯特拉算法-1" class="headerlink" title="1.迪杰斯特拉算法:"></a>1.迪杰斯特拉算法:</h3><p><a href="https://www.bilibili.com/video/BV1q4411M7r9?t=701" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1q4411M7r9?t=701</a></p>
<p><a href="https://www.cnblogs.com/skywang12345/p/3711512.html#anchor2" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3711512.html#anchor2</a></p>
<h3 id="2-priority-queue"><a href="#2-priority-queue" class="headerlink" title="2.priority queue"></a>2.priority queue</h3><p><a href="https://blog.csdn.net/qq_41603898/article/details/81661833" target="_blank" rel="noopener">https://blog.csdn.net/qq_41603898/article/details/81661833</a></p>
<p>cmp函数的重载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;int adj;</span><br><span class="line"> int val;</span><br><span class="line"> friend  bool operator&lt;(const Node &amp;a,const Node &amp;b) &#123; return  a.val &gt; b.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node&gt;Q;</span><br></pre></td></tr></table></figure>

<p>储存指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">     short f;</span><br><span class="line">     short d;</span><br><span class="line">     short fishs;</span><br><span class="line">     short times;</span><br><span class="line">     short i;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct PCmp</span><br><span class="line">&#123;</span><br><span class="line">    bool operator () (Node const *x, Node const *y)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x-&gt;f &#x3D;&#x3D; y-&gt;f)</span><br><span class="line">            return x-&gt;i &gt; y-&gt;i;</span><br><span class="line">        return x-&gt;f &lt; y-&gt;f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">priority_queue&lt;Node*, vector&lt;Node*&gt;, PCmp &gt; Q;</span><br></pre></td></tr></table></figure>



<h3 id="3-代码："><a href="#3-代码：" class="headerlink" title="3.代码："></a>3.代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> city;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">int</span> remainStep;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost&gt;b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// auto cmp = [&amp;](const int&amp; a, const int&amp; b)&#123;</span></span><br><span class="line">        <span class="comment">//     return a&gt;b;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">//构造邻接链表</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> flight: flights)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = flight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = flight[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> cost = flight[<span class="number">2</span>];</span><br><span class="line">            graph[from][to] = cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, cmp&gt; que;</span><br><span class="line">        Node newNode = &#123;src,<span class="number">0</span>,K+<span class="number">1</span>&#125;;</span><br><span class="line">        que.push(newNode);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            Node top = que.top(); que.pop();</span><br><span class="line">            <span class="keyword">if</span>(top.city==dst)&#123;</span><br><span class="line">                <span class="keyword">return</span> top.cost;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top.remainStep&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> iter = graph[top.city].<span class="built_in">begin</span>();iter!=graph[top.city].<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">                    newNode = &#123;iter-&gt;first,top.cost+iter-&gt;second,top.remainStep<span class="number">-1</span>&#125;;</span><br><span class="line">                    que.push(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode160：相交链表</title>
    <url>/leetcode160%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<img src="/leetcode160%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/1598951796387.png" class="" width="1598951796387">

<a id="more"></a>

<p>双指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">NULL</span> || headB == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* curA=headA, *curB=headB;</span><br><span class="line">        <span class="keyword">while</span>(curA!=curB)&#123;</span><br><span class="line">            curA = curA == <span class="literal">NULL</span>?headB:curA-&gt;next;</span><br><span class="line">            curB = curB == <span class="literal">NULL</span>?headA:curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>list node</tag>
      </tags>
  </entry>
  <entry>
    <title>保研复习</title>
    <url>/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>保研复习资料的整理</p>
<a id="more"></a>

<h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h1><p>简历和个人陈述：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26999026" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26999026</a></p>
<p>计算机网络：</p>
<p><a href="https://zhuanlan.zhihu.com/p/118504254" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/118504254</a></p>
<p>操作系统：</p>
<p><a href="https://blog.csdn.net/qq_35564813/article/details/80651259?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">https://blog.csdn.net/qq_35564813/article/details/80651259?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
<p>计算机图形学：</p>
<p>数据结构：</p>
<p><a href="https://blog.csdn.net/weixin_40113925/article/details/100938378" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40113925/article/details/100938378</a></p>
<h1 id="2-高频问题"><a href="#2-高频问题" class="headerlink" title="2.高频问题"></a>2.高频问题</h1><p>高频问题：</p>
<p><a href="https://zhuanlan.zhihu.com/p/96719367" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96719367</a></p>
<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h3><p>迪杰斯特拉算法</p>
<h3 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3>]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>python对excel合并</title>
    <url>/python%E5%AF%B9excel%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>使用python将同一目录下的excel表格进行合并</p>
<a id="more"></a>

<h1 id="1-code"><a href="#1-code" class="headerlink" title="1.code"></a>1.code</h1><p>python代码如下，要注意的是excel文件有xsls和xsl两种格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> xlrd,xlwt</span><br><span class="line"><span class="comment">#============set style====================</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_stlye</span><span class="params">(name,height,bold=False)</span>:</span></span><br><span class="line">  <span class="comment">#初始化样式</span></span><br><span class="line">  style = xlwt.XFStyle()</span><br><span class="line">  <span class="comment">#创建字体</span></span><br><span class="line">  font = xlwt.Font()</span><br><span class="line">  font.bold = bold</span><br><span class="line">  font.colour_index = <span class="number">4</span></span><br><span class="line">  font.height = height</span><br><span class="line">  font.name =name</span><br><span class="line">  style.font = font</span><br><span class="line">  <span class="keyword">return</span> style</span><br><span class="line"><span class="comment">#==============get file list===============</span></span><br><span class="line">filelist=[]</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">"."</span>, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        str=os.path.join(root, name)</span><br><span class="line">        <span class="keyword">if</span> str.split(<span class="string">'.'</span>)[<span class="number">-1</span>]==<span class="string">'xlsx'</span>||str.split(<span class="string">'.'</span>)[<span class="number">-1</span>]==<span class="string">'xls'</span>:</span><br><span class="line">            filelist.append(str)</span><br><span class="line">print(<span class="string">'get files suc'</span>)</span><br><span class="line"><span class="comment"># #===========read excel=================</span></span><br><span class="line"><span class="comment"># wb = xlrd.open_workbook('.\\daily use\\填空.xlsx')</span></span><br><span class="line"><span class="comment"># #sheet1索引从0开始，得到sheet1表的句柄</span></span><br><span class="line"><span class="comment"># sheet1 = wb.sheet_by_index(0)</span></span><br><span class="line"><span class="comment"># rowNum = sheet1.nrows</span></span><br><span class="line"><span class="comment"># colNum = sheet1.ncols</span></span><br><span class="line"><span class="comment"># print('read  suc')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=================write=====================================</span></span><br><span class="line">output = xlwt.Workbook()</span><br><span class="line"><span class="comment">#add a new sheet</span></span><br><span class="line">output_sheet1 = output.add_sheet(<span class="string">u'sheet1'</span>,cell_overwrite_ok=<span class="literal">True</span>)</span><br><span class="line">output_row = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> filelist:</span><br><span class="line">  print(file)</span><br><span class="line">  wb = xlrd.open_workbook(file)</span><br><span class="line">  sheet1 = wb.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">  rowNum = sheet1.nrows</span><br><span class="line">  colNum = sheet1.ncols</span><br><span class="line">  <span class="keyword">for</span> row <span class="keyword">in</span> range(rowNum):</span><br><span class="line">    value = sheet1.cell(row,<span class="number">0</span>).value</span><br><span class="line">    output_sheet1.write(output_row,<span class="number">0</span>,value,set_stlye(<span class="string">"Time New Roman"</span>,<span class="number">220</span>,<span class="literal">True</span>))</span><br><span class="line">    output_row+=<span class="number">1</span>;</span><br><span class="line"><span class="comment"># save the file</span></span><br><span class="line">output.save(<span class="string">'output.xls'</span>)</span><br><span class="line">print(<span class="string">'output suc'</span>)</span><br><span class="line">print(<span class="string">'finish'</span>)</span><br><span class="line">input()</span><br></pre></td></tr></table></figure>

<h1 id="2-build"><a href="#2-build" class="headerlink" title="2.build"></a>2.build</h1><p>之后使用pyinstaller进行build</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller -F -i icon.ico excelcombine.py</span><br></pre></td></tr></table></figure>

<p>其中的icon.ico就是最后生成的可执行程序的图标，需要使用ico格式的图片，这里就直接上网上搜一个转化网站就好了，生成完成之后，将.exe文件移动一下就能够看到图标生效了。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode226：翻转二叉树</title>
    <url>/leetcode226%EF%BC%9A%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<img src="/leetcode226%EF%BC%9A%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/1597769391520.png" class="" width="1597769391520">

<a id="more"></a>

<h1 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        root-&gt;left = invertTree(right);</span><br><span class="line">        root-&gt;right = invertTree(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            TreeNode* cur = que.front(); que.pop();</span><br><span class="line">            TreeNode* tmp = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = cur-&gt;right;</span><br><span class="line">            cur-&gt;right=tmp;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) que.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) que.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode110：平衡二叉树</title>
    <url>/leetcode110%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<img src="/leetcode110%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/1597762741527.png" class="" width="1597762741527">

<a id="more"></a>

<h1 id="1-自顶向下"><a href="#1-自顶向下" class="headerlink" title="1.自顶向下"></a>1.自顶向下</h1><p>就是前序遍历。套上模板：root、left、right。但此处的判断需要得到两遍子树的深度，也就需要再写一个函数用来计算深度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left),<span class="built_in">height</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//root处，操作写在这，这里的操作就是判断该节点是否平衡</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right))&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左节点，右节点</span></span><br><span class="line">        <span class="keyword">return</span> isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-自底向下"><a href="#2-自底向下" class="headerlink" title="2.自底向下"></a>2.自底向下</h1><p>对height使用后续遍历，直接在height里判断是否平衡，如果不平衡返回-1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">-1</span>||right==<span class="number">-1</span>||<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root)!=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode141：环形链表</title>
    <url>/leetcode141%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="1-哈希函数"><a href="#1-哈希函数" class="headerlink" title="1.哈希函数"></a>1.哈希函数</h1><p>直接使用哈希表存储每个node的访问情况即可。</p>
<h1 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2.快慢指针"></a>2.快慢指针</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* first=head, *sec=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(first!=sec)&#123;</span><br><span class="line">            <span class="comment">//只要考虑快指针的情况就行了，因为末尾肯定是快指针先到达</span></span><br><span class="line">            <span class="keyword">if</span>(!sec||!sec-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            sec = sec-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/leetcode141%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/1598348358663.png" class="" width="1598348358663">

]]></content>
      <categories>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>linked list</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode136：只出现一次的数字</title>
    <url>/leetcode136%EF%BC%9A%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>leetcode121：买卖股票</title>
    <url>/leetcode121%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</url>
    <content><![CDATA[<img src="/leetcode121%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/1597397863470.png" class="" width="1597397863470">

<a id="more"></a>

<h1 id="1-迭代（超时）"><a href="#1-迭代（超时）" class="headerlink" title="1.迭代（超时）"></a>1.迭代（超时）</h1><h1 id="2-最大最小值"><a href="#2-最大最小值" class="headerlink" title="2.最大最小值"></a>2.最大最小值</h1><img src="/leetcode121%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/1597399119698.png" class="" width="1597399119698">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = INT_MAX, maxProfit = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice,price);</span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit,price-minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode155：最小栈</title>
    <url>/leetcode155%EF%BC%9A%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<img src="/leetcode155%EF%BC%9A%E6%9C%80%E5%B0%8F%E6%A0%88/1597375554674.png" class="" width="1597375554674">

<a id="more"></a>

<h1 id="1-使用辅助栈"><a href="#1-使用辅助栈" class="headerlink" title="1.使用辅助栈"></a>1.使用辅助栈</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; valStack;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        minStack.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        valStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;minStack.top()) minStack.push(x);</span><br><span class="line">        <span class="keyword">else</span> minStack.push(minStack.top());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        valStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> valStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-不使用辅助栈"><a href="#2-不使用辅助栈" class="headerlink" title="2.不使用辅助栈"></a>2.不使用辅助栈</h1><p>在栈中存放栈顶元素与最小值的差值即可</p>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode198：打家劫舍</title>
    <url>/leetcode198%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<img src="/leetcode198%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/1597251103641.png" class="" width="1597251103641">

<a id="more"></a>

<h1 id="1-动态规划-滑动数组"><a href="#1-动态规划-滑动数组" class="headerlink" title="1.动态规划+滑动数组"></a>1.动态规划+滑动数组</h1><h1 id="1-自己的"><a href="#1-自己的" class="headerlink" title="1.自己的"></a>1.自己的</h1><p>动态规划就是寻找<strong>状态</strong>和<strong>选择</strong>的过程。</p>
<p>通项公式：dp[i]=max(dp[i−2]+nums[i],dp[i−1])</p>
<p>自己的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value[nums.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) value[i] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>) value[i] = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                value[i] = <span class="built_in">max</span>(value[i<span class="number">-1</span>],value[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是可以看出，当前的值只和前两项的值有关，所以可以进行优化得到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> a=nums[<span class="number">0</span>],b=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = b;</span><br><span class="line">            b = <span class="built_in">max</span>(b,a+nums[i]);</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a>参考答案：</h1><img src="/leetcode198%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/1599571546524.png" class="" width="1599571546524">

<p>首先要写出<strong>状态转移方程</strong>，然后要找出<strong>边界条件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> a = nums[<span class="number">0</span>], b = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            tmp = b;</span><br><span class="line">            b = <span class="built_in">max</span>(b,nums[i]+a);</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以不用这个表达式</span></span><br><span class="line">        <span class="comment">// return max(a,b);</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode133：克隆图</title>
    <url>/leetcode133%EF%BC%9A%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    <content><![CDATA[<img src="/leetcode133%EF%BC%9A%E5%85%8B%E9%9A%86%E5%9B%BE/1597240328033.png" class="" width="1597240328033">

<img src="/leetcode133%EF%BC%9A%E5%85%8B%E9%9A%86%E5%9B%BE/1597240337894.png" class="" width="1597240337894">

<a id="more"></a>

<p>这题本质就是图的遍历</p>
<p><a href="https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/</a></p>
<p>另外：</p>
<img src="/leetcode133%EF%BC%9A%E5%85%8B%E9%9A%86%E5%9B%BE/1597246815021.png" class="" width="1597246815021">

<h1 id="1-递归-DFS"><a href="#1-递归-DFS" class="headerlink" title="1.递归-DFS"></a>1.递归-DFS</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; visited;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//如果访问过了，则返回克隆后的节点的地址</span></span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(node)!=visited.<span class="built_in">end</span>()) <span class="keyword">return</span> visited[node];</span><br><span class="line">        <span class="comment">//否则，加入hash table</span></span><br><span class="line">        Node* cloneNode = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor: node-&gt;neighbors)&#123;</span><br><span class="line">            visited[node]-&gt;neighbors.push_back(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-迭代-BFS"><a href="#2-迭代-BFS" class="headerlink" title="2.迭代-BFS"></a>2.迭代-BFS</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; visited;</span><br><span class="line">       <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">       que.push(node);</span><br><span class="line">       visited[node] = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">       <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">           Node* newNode = que.front();</span><br><span class="line">           que.pop();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor: newNode-&gt;neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited.<span class="built_in">find</span>(neighbor)==visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    visited[neighbor] = <span class="keyword">new</span> Node(neighbor-&gt;val);</span><br><span class="line">                    que.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                visited[newNode]-&gt;neighbors.push_back(visited[neighbor]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> visited[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode101：对称二叉树</title>
    <url>/leetcode101%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<a id="more"></a>

<img src="/leetcode101%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/1597219072547.png" class="" width="1597219072547">

<h1 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h1><p>左子树的左树和右子树的右树对称，</p>
<p>左子树的右树和右子树的左树对称</p>
<img src="/leetcode101%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/101_fig2.PNG" class="" title="fig2">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root-&gt;right, root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left&amp;&amp;!right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left||!right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val!=right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(left-&gt;left, right-&gt;right)&amp;&amp;isSymmetric(left-&gt;right,right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者看做两颗树，使用双指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h1 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h1><p>树的迭代操作一般使用queue</p>
<p>递归改迭代也一般使用queue</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">       <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       que.push(root);</span><br><span class="line">       que.push(root);</span><br><span class="line">       TreeNode* left, *right;</span><br><span class="line">       <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        left = que.front();que.pop();</span><br><span class="line">        right =que.front();que.pop();</span><br><span class="line">        <span class="keyword">if</span>(!left&amp;&amp;!right) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left^!right) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val!=right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        que.push(left-&gt;left);que.push(right-&gt;right);</span><br><span class="line">        que.push(left-&gt;right);que.push(right-&gt;left);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>recursion</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode70：爬楼梯</title>
    <url>/leetcode70%EF%BC%9A%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<img src="/leetcode70%EF%BC%9A%E7%88%AC%E6%A5%BC%E6%A2%AF/1597072519948.png" class="" width="1597072519948">

<a id="more"></a>

<p>这道题首先想到递归，解决子问题，然后发现就是一个斐波那契数列，不过是从n=0开始的。</p>
<h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1.动态规划"></a>1.动态规划</h1><p>斐波那契数列每一项只和前面两项有关，所以只要保存前面两项的数值即可</p>
<p>状态转移方程：<img src="/leetcode70%EF%BC%9A%E7%88%AC%E6%A5%BC%E6%A2%AF/fib.png" class="" title="img"></p>
<p>时间复杂度为O(n)</p>
<p>空间复杂度为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a =<span class="number">1</span>, b=<span class="number">2</span>, res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           res = a+b;</span><br><span class="line">           <span class="keyword">int</span> tmp=a;</span><br><span class="line">           a=b;</span><br><span class="line">           b=tmp+b;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-矩阵快速幂"><a href="#2-矩阵快速幂" class="headerlink" title="2.矩阵快速幂"></a>2.矩阵快速幂</h1><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></p>
<p><a href="https://blog.csdn.net/zhangxiaoduoduo/article/details/81807338" target="_blank" rel="noopener">https://blog.csdn.net/zhangxiaoduoduo/article/details/81807338</a></p>
<img src="/leetcode70%EF%BC%9A%E7%88%AC%E6%A5%BC%E6%A2%AF/1597073138416.png" class="" width="1597073138416">



<h1 id="3-斐波那契通项公式（适用于齐次线性递推）"><a href="#3-斐波那契通项公式（适用于齐次线性递推）" class="headerlink" title="3.斐波那契通项公式（适用于齐次线性递推）"></a>3.斐波那契通项公式（适用于齐次线性递推）</h1><p><a href="https://blog.csdn.net/u011068702/article/details/78948145?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf" target="_blank" rel="noopener">https://blog.csdn.net/u011068702/article/details/78948145?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode14：最长公共前缀</title>
    <url>/leetcode14%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<img src="/leetcode14%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/1597058381735.png" class="" width="1597058381735">

<a id="more"></a>

<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/</a></p>
<h1 id="1-自己的"><a href="#1-自己的" class="headerlink" title="1.自己的"></a>1.自己的</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            minLen = strs[i].<span class="built_in">size</span>()&lt;minLen?strs[i].<span class="built_in">size</span>():minLen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> preC=<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">string</span> publicS = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;minLen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">1</span>&amp;&amp;strs[j][i]==preC)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                preC = strs[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==strs.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">                publicS+=strs[<span class="number">0</span>][i];</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> publicS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-横向"><a href="#2-横向" class="headerlink" title="2.横向"></a>2.横向</h1><img src="/leetcode14%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/14_fig1.png" class="" title="fig1">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (!prefix.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">min</span>(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1[index] == str2[index]) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substr(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-纵向"><a href="#3-纵向" class="headerlink" title="3.纵向"></a>3.纵向</h1><img src="/leetcode14%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/14_fig2.png" class="" title="fig2">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].<span class="built_in">size</span>() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="4-二分"><a href="#4-二分" class="headerlink" title="4.二分"></a>4.二分</h1><img src="/leetcode14%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/14_fig4.png" class="" title="fig4">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = min_element(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; t) &#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>();&#125;)-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str0 = strs[<span class="number">0</span>].substr(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0[j] != str[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意这里的判断就不能是按列判断了，而应该判断前半段的字符串。</p>
<p>否则像[“babb”,”caa”]这样的数，第二列相同，但前两列不同。就会出错。</p>
<p>也需要注意空集的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果为空</span></span><br><span class="line">        <span class="keyword">if</span>(!strs.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s: strs)&#123;</span><br><span class="line">            minLen=minLen&lt;s.<span class="built_in">size</span>()?minLen:s.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=minLen;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(checkPrefix(strs,mid+<span class="number">1</span>))&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span>==<span class="number">-1</span>?<span class="string">""</span>:strs[<span class="number">0</span>].substr(<span class="number">0</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的mid就是count，也就是计算几位</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> strsLen = strs.<span class="built_in">size</span>(), count=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> preStr=strs[<span class="number">0</span>].substr(<span class="number">0</span>,mid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strsLen;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;strs[i].substr(<span class="number">0</span>,mid)==preStr)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            preStr=strs[i].substr(<span class="number">0</span>,mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==(strsLen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="5-分治"><a href="#5-分治" class="headerlink" title="5.分治"></a>5.分治</h1><img src="/leetcode14%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/14_fig3.png" class="" title="fig3">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">            <span class="built_in">string</span> lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpLeft, <span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = <span class="built_in">min</span>(lcpLeft.<span class="built_in">size</span>(), lcpRight.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft[i] != lcpRight[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="6-排序"><a href="#6-排序" class="headerlink" title="6.排序"></a>6.排序</h1><p>先排序，后比较头尾即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">        sort(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">string</span> st = strs.front(), en = strs.back();</span><br><span class="line">        <span class="keyword">int</span> i, num = <span class="built_in">min</span>(st.<span class="built_in">size</span>(), en.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num &amp;&amp; st[i] == en[i]; i ++);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(st, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode13：罗马数字转整数</title>
    <url>/leetcode13%EF%BC%9A%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<img src="/leetcode13%EF%BC%9A%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/1597042223985.png" class="" width="1597042223985">

<a id="more"></a>

<h1 id="1-hash-table"><a href="#1-hash-table" class="headerlink" title="1.hash table"></a>1.hash table</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; num = &#123;&#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;,&#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;,&#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,&#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">char</span> pre = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//把前面加上去的也减掉</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; num[pre]&lt;num[s[i]]) sum-=num[pre]*<span class="number">2</span>;</span><br><span class="line">            sum+=num[s[i]];</span><br><span class="line">            pre=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-全部放入hash-table"><a href="#2-全部放入hash-table" class="headerlink" title="2.全部放入hash table"></a>2.全部放入hash table</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="string">"I"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"IV"</span>, <span class="number">3</span>&#125;, &#123;<span class="string">"IX"</span>, <span class="number">8</span>&#125;, &#123;<span class="string">"V"</span>, <span class="number">5</span>&#125;, &#123;<span class="string">"X"</span>, <span class="number">10</span>&#125;, &#123;<span class="string">"XL"</span>, <span class="number">30</span>&#125;, &#123;<span class="string">"XC"</span>, <span class="number">80</span>&#125;, &#123;<span class="string">"L"</span>, <span class="number">50</span>&#125;, &#123;<span class="string">"C"</span>, <span class="number">100</span>&#125;, &#123;<span class="string">"CD"</span>, <span class="number">300</span>&#125;, &#123;<span class="string">"CM"</span>, <span class="number">800</span>&#125;, &#123;<span class="string">"D"</span>, <span class="number">500</span>&#125;, &#123;<span class="string">"M"</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> r = m[s.substr(<span class="number">0</span>, <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.size(); ++i)&#123;</span><br><span class="line">            string two = s.substr(i-<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            string one = s.substr(i, <span class="number">1</span>);</span><br><span class="line">            r += m[two] ? m[two] : m[one];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-switch-走一步回头看"><a href="#3-switch-走一步回头看" class="headerlink" title="3.switch+走一步回头看"></a>3.switch+走一步回头看</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(preNum &lt; num) &#123;</span><br><span class="line">                sum -= preNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += preNum;</span><br><span class="line">            &#125;</span><br><span class="line">            preNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += preNum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode9：回文数</title>
    <url>/leetcode9%EF%BC%9A%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<img src="/leetcode9%EF%BC%9A%E5%9B%9E%E6%96%87%E6%95%B0/1596996614493.png" class="" width="1596996614493">

<a id="more"></a>

<h1 id="1-转化为字符串"><a href="#1-转化为字符串" class="headerlink" title="1.转化为字符串"></a>1.转化为字符串</h1><p>主要利用to_string()方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="built_in">string</span> s_x = to_string(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s_x.<span class="built_in">size</span>()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_x[i]!=s_x[s_x.<span class="built_in">size</span>()-i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-对半折"><a href="#2-对半折" class="headerlink" title="2.对半折"></a>2.对半折</h1><p>从低位开始取数字，直到取出的数字<strong>大于等于</strong>剩下的数字。此时有两种情况，如果原数字为奇数，那么取出后的数字/10就可以相等；如果原数字为偶数，那么取出后的数字和原数就是相等的。</p>
<p>不过要注意的是末尾为0的数，除了0，都不是回文数。比如10。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prev  orgi</span><br><span class="line">0		10	</span><br><span class="line">0		1</span><br><span class="line">1		0</span><br></pre></td></tr></table></figure>

<p>按照上述方法计算就可得到这个表格，可以看出这里符合了返回true的条件，这是因为随着迭代的进行，末尾的0无法将翻转后的数字长度加长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//0为回文数</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//负数或者末尾为0</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> reverse=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(reverse&lt;x)&#123;</span><br><span class="line">            reverse = reverse*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(reverse==x||reverse/<span class="number">10</span>==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode696：计数二进制子串</title>
    <url>/leetcode696%EF%BC%9A%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<img src="/leetcode696%EF%BC%9A%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/1596994931284.png" class="" width="1596994931284">

<a id="more"></a>

<p><strong>Intuition</strong></p>
<p>We can convert the string <code>s</code> into an array <code>groups</code> that represents the length of same-character contiguous blocks within the string. For example, if <code>s = &quot;110001111000000&quot;</code>, then <code>groups = [2, 3, 4, 6]</code>.</p>
<p>For every binary string of the form <code>&#39;0&#39; * k + &#39;1&#39; * k</code> or <code>&#39;1&#39; * k + &#39;0&#39; * k</code>, the middle of this string must occur between two groups.</p>
<p>Let’s try to count the number of valid binary strings between <code>groups[i]</code> and <code>groups[i+1]</code>. If we have <code>groups[i] = 2, groups[i+1] = 3</code>, then it represents either <code>&quot;00111&quot;</code> or <code>&quot;11000&quot;</code>. We clearly can make <code>min(groups[i], groups[i+1])</code> valid binary strings within this string. Because the binary digits to the left or right of this string must change at the boundary, our answer can never be larger.</p>
<p><strong>Algorithm</strong></p>
<p>Let’s create <code>groups</code> as defined above. The first element of <code>s</code> belongs in it’s own group. From then on, each element either doesn’t match the previous element, so that it starts a new group of size 1; or it does match, so that the size of the most recent group increases by 1.</p>
<p>Afterwards, we will take the sum of <code>min(groups[i-1], groups[i])</code>.</p>
<p><strong>总结：</strong></p>
<p>也就是说<code>11100</code>可以拆出<strong>1100</strong>、<strong>10</strong>两个符合条件的子串。也就是min（3,2）。另外题目要求所有的0要consecutively，所有的1也要。所以只需要考虑前后两个连续的子串即可。</p>
<h1 id="1-自己的"><a href="#1-自己的" class="headerlink" title="1.自己的"></a>1.自己的</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; group;</span><br><span class="line">        <span class="comment">//把相邻的相同字符统计后分组</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只有一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//有多于一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                group.push_back(count);</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一段放入数组</span></span><br><span class="line">        group.push_back(count);</span><br><span class="line">        <span class="keyword">if</span>(group.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;group.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans+=<span class="built_in">min</span>(group[i],group[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-代码优化"><a href="#2-代码优化" class="headerlink" title="2.代码优化"></a>2.代码优化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; group;</span><br><span class="line">        group.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不符合条件的也就不会进入该循环，最红就会得到0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>]) group.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> group[group.<span class="built_in">size</span>()<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;group.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans+=<span class="built_in">min</span>(group[i],group[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBinarySubstrings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        groups = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] != s[i]:</span><br><span class="line">                groups.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                groups[<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(groups)):</span><br><span class="line">            ans += min(groups[i<span class="number">-1</span>], groups[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h1 id="3-算法优化"><a href="#3-算法优化" class="headerlink" title="3.算法优化"></a>3.算法优化</h1><p>不需要记录所有的值，只要记录prev和cur的即可</p>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can amend our <em>Approach #1</em> to calculate the answer on the fly. Instead of storing <code>groups</code>, we will remember only <code>prev = groups[-2]</code> and <code>cur = groups[-1]</code>. Then, the answer is the sum of <code>min(prev, cur)</code> over each different final <code>(prev, cur)</code> we see.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; group;</span><br><span class="line">        group.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>, cur=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//不符合条件的也就不会进入该循环，最红就会得到0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                ans+=<span class="built_in">min</span>(prev,cur);</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个group没加入</span></span><br><span class="line">        <span class="keyword">return</span> ans+<span class="built_in">min</span>(prev,cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>echartsTest</title>
    <url>/echartsTest/</url>
    <content><![CDATA[<p>测试一下echarts情况</p>
<a id="more"></a>

<div id="echarts2095" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts2095'));
        // 指定图表的配置项和数据
        var option = {
​    tooltip : {
​        trigger: 'axis',
​        axisPointer : {            // 坐标轴指示器，坐标轴触发有效
​            type : 'shadow'        // 默认为直线，可选为：'line' | 'shadow'
​        }
​    },
​    legend: {
​        data:['利润', '支出', '收入']
​    },
​    grid: {
​        left: '3%',
​        right: '4%',
​        bottom: '3%',
​        containLabel: true
​    },
​    xAxis : [
​        {
​            type : 'value'
​        }
​    ],
​    yAxis : [
​        {
​            type : 'category',
​            axisTick : {show: false},
​            data : ['周一','周二','周三','周四','周五','周六','周日']
​        }
​    ],
​    series : [
​        {
​            name:'利润',
​            type:'bar',
​            itemStyle : {
​                normal: {
​                    label: {show: true, position: 'inside'}
​                }
​            },
​            data:[200, 170, 240, 244, 200, 220, 210]
​        },
​        {
​            name:'收入',
​            type:'bar',
​            stack: '总量',
​            itemStyle: {
​                normal: {
​                    label : {show: true}
​                }
​            },
​            data:[320, 302, 341, 374, 390, 450, 420]
​        },
​        {
​            name:'支出',
​            type:'bar',
​            stack: '总量',
​            itemStyle: {normal: {
​                label : {show: true, position: 'left'}
​            }},
​            data:[-120, -132, -101, -134, -190, -230, -210]
​        }
​    ]
};
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>






]]></content>
  </entry>
  <entry>
    <title>hexo的项目结构</title>
    <url>/hexo%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>本文对hexo的项目结构进行总结</p>
<a id="more"></a>

<ol>
<li>hexo post模板：</li>
</ol>
<p>‪<code>hexo\scaffolds\post.md</code></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next-SEO设置</title>
    <url>/hexo-next-SEO%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>对hexo进行百度和google的seo设置和优化</p>
<a id="more"></a>

<p>参考如下：</p>
<p><a href="https://croook.github.io/2019/10/11/hexo_baidu_verify/" target="_blank" rel="noopener">https://croook.github.io/2019/10/11/hexo_baidu_verify/</a></p>
<p><a href="https://www.cnblogs.com/brady-wang/p/8493346.html" target="_blank" rel="noopener">https://www.cnblogs.com/brady-wang/p/8493346.html</a></p>
<p><a href="https://www.jianshu.com/p/5b4c98490f26" target="_blank" rel="noopener">https://www.jianshu.com/p/5b4c98490f26</a></p>
<p>首先要分别打开百度站长和google search console</p>
<h1 id="1-百度SEO"><a href="#1-百度SEO" class="headerlink" title="1.百度SEO"></a>1.百度SEO</h1><h3 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h3><p>验证方式有三种，常用的方式有两种</p>
<p>第一种是CNAME验证，这种验证方式需要有域名；第二种方式是html验证，这种方式不需要有域名。</p>
<h5 id="CNAME验证："><a href="#CNAME验证：" class="headerlink" title="CNAME验证："></a>CNAME验证：</h5><p>在阿里云DNS解析里面添加记录</p>
<img src="/hexo-next-SEO%E8%AE%BE%E7%BD%AE/1596919828051.png" class="" width="1596919828051">

<p><strong>主机记录</strong>就是百度给你的那一长串子，而<strong>记录值</strong>则是ziyuan.baidu.com，<strong>记录类型</strong>选择CNAME即可。</p>
<hr>
<h5 id="HTML验证："><a href="#HTML验证：" class="headerlink" title="HTML验证："></a>HTML验证：</h5><p>在<strong>next的config文件里</strong>查找如下记录</p>
<img src="/hexo-next-SEO%E8%AE%BE%E7%BD%AE/1596920200169.png" class="" width="1596920200169">

<p>将百度的提供的编码添加进去，<strong>clean之后</strong>重新生成和提交，头文件中就会出现需要的标签。</p>
<p>具体的设置可以看source/layout/partial/head下面的head.swig中的<code>if theme.baidu_site_verification</code></p>
<img src="/hexo-next-SEO%E8%AE%BE%E7%BD%AE/3.png" class="" title="img">

<h3 id="2-推送"><a href="#2-推送" class="headerlink" title="2.推送"></a>2.推送</h3><p>百度的推送方法有三种api推送、sitemap推送、手动推送。因为github屏蔽了百度的爬虫，所以这里需要借助api推送。</p>
<p>在那之前可以打开next的baidu自动推送功能</p>
<h5 id="1-next推送功能"><a href="#1-next推送功能" class="headerlink" title="1.next推送功能"></a>1.next推送功能</h5><p>在next的config文件下，搜索baidu_push，改为true。然后generate一下，就会在layout/third…中看到baidu_push.swig</p>
<hr>
<h5 id="2-api推送"><a href="#2-api推送" class="headerlink" title="2.api推送"></a>2.api推送</h5><p>这里使用一款插件来进行推送</p>
<p>·<code>npm install hexo-baidu-url-submit --save</code></p>
<p>然后在根目录下的config文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1 ## 提交最新的一个链接</span><br><span class="line">  host: www.hui-wang.info ## 在百度站长平台中注册的域名</span><br><span class="line">  token: your_token ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>

<p>同时要注意config中的url设置要和在百度站长中的域名一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: http:&#x2F;&#x2F;www.gzhao01.top</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink:</span><br></pre></td></tr></table></figure>

<p>然后加入新的deploy，这样每次deploy的时候都会进行推送了。注意这玩意儿要写在git下面，因为运行是按照顺序运行的，这样更方便自己查看。</p>
<img src="/hexo-next-SEO%E8%AE%BE%E7%BD%AE/1596921909712.png" class="" width="1596921909712">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"></span><br><span class="line">- type: git</span><br><span class="line">repo:</span><br><span class="line">coding: git@git.coding.net:你的coding用户名&#x2F;你的coding用户名.coding.me.git #coding地址</span><br><span class="line">github: git@github.com:你的github用户名&#x2F;你的github用户名.github.io.git # Github地址</span><br><span class="line">branch: master</span><br><span class="line"></span><br><span class="line">- type: baidu_url_submitter</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="3-sitemap"><a href="#3-sitemap" class="headerlink" title="3.sitemap"></a>3.sitemap</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<p>hexo g之后就能看到public中生成了对应的sitemap文件，也可以通过url进行访问了。然后按照百度的格式，将baidusitemap提交即可。</p>
<h1 id="2-google"><a href="#2-google" class="headerlink" title="2.google"></a>2.google</h1><h3 id="1-验证-1"><a href="#1-验证-1" class="headerlink" title="1.验证"></a>1.验证</h3><p>google的验证和百度的验证过程一样</p>
<h3 id="2-提交sitemap"><a href="#2-提交sitemap" class="headerlink" title="2.提交sitemap"></a>2.提交sitemap</h3><p>这样就完成了提交</p>
<h1 id="3-robot-txt"><a href="#3-robot-txt" class="headerlink" title="3.robot.txt"></a>3.robot.txt</h1><p>在根目录的source下面添加该文件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line">Allow: &#x2F;categories&#x2F;</span><br><span class="line">Allow: &#x2F;tags&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: http:&#x2F;&#x2F;www.gzhao01.top&#x2F;sitemap.xml</span><br><span class="line">Sitemap: http:&#x2F;&#x2F;www.gzhao01.top&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure>

<h1 id="4-SEO优化"><a href="#4-SEO优化" class="headerlink" title="4.SEO优化"></a>4.SEO优化</h1><h3 id="1-url优化"><a href="#1-url优化" class="headerlink" title="1.url优化"></a>1.url优化</h3><img src="/hexo-next-SEO%E8%AE%BE%E7%BD%AE/1596925377152.png" class="" width="1596925377152">

<p>原先的hexo文章是如上的格式，这样子对搜索引擎很不友好，因为网页深度越深，搜索引擎对其的搜索效果也就越差，所以将其改成:title/即可</p>
<h3 id="2-镜像仓库"><a href="#2-镜像仓库" class="headerlink" title="2.镜像仓库"></a>2.镜像仓库</h3><p><a href="https://zhuanlan.zhihu.com/p/33333345" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33333345</a></p>
<p>准确来说就是通过DNS解析，将百度的解析路径改变成coding界面的git仓库。</p>
<img src="/hexo-next-SEO%E8%AE%BE%E7%BD%AE/v2-1cf2d18e29eec3dcefe9997e607a0520_720w.jpg" class="" title="img">]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode215：数组中的第K个最大元素</title>
    <url>/leetcode215%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<img src="/leetcode215%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/1596925157987.png" class="" width="1596925157987">

<a id="more"></a>

<h1 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h1><p>调用priority_queue，要注意的是，默认为大顶堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a&gt;b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// auto cmp = [&amp;](const int&amp; a, const int&amp; b)&#123;</span></span><br><span class="line">        <span class="comment">//     return a&gt;b;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">// priority_queue&lt;int, vector&lt;int&gt;,decltype(cpm)&gt; que(cmp);</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            que.push(INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top=que.top();</span><br><span class="line">            <span class="keyword">if</span>(top&lt;nums[i])&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">                que.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>手写：</p>
<h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h1>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>topN</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode230：二叉搜索树中第k个小的元素</title>
    <url>/leetcode230%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<img src="/leetcode230%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/1596900100511.png" class="" width="1596900100511">

<a id="more"></a>

<h1 id="1-中序遍历递归"><a href="#1-中序遍历递归" class="headerlink" title="1.中序遍历递归"></a>1.中序遍历递归</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> kth;</span><br><span class="line">        findKth(root,k, kth);</span><br><span class="line">        <span class="keyword">return</span> kth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findKth</span><span class="params">(TreeNode*root, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span>&amp; kth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        findKth(root-&gt;left,k,kth);</span><br><span class="line">        <span class="keyword">if</span>(--k==<span class="number">0</span>) kth = root-&gt;val;</span><br><span class="line">        findKth(root-&gt;right,k,kth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-中序遍历迭代"><a href="#2-中序遍历迭代" class="headerlink" title="2.中序遍历迭代"></a>2.中序遍历迭代</h1><p>注意<code>root=stack.top();</code>不要写错，即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=<span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">//=======操作=============</span></span><br><span class="line">            <span class="keyword">if</span>(--k==<span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="comment">//=========================</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-中序遍历morris"><a href="#3-中序遍历morris" class="headerlink" title="3.中序遍历morris"></a>3.中序遍历morris</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root, *prev = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//========操作============</span></span><br><span class="line">                <span class="keyword">if</span>(--k==<span class="number">0</span>) <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">                <span class="comment">//=======================</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;right)&#123;</span><br><span class="line">                    prev=prev-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                prev-&gt;right=cur;</span><br><span class="line">                TreeNode* tmp = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                tmp-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode94：二叉树的中序遍历-binarytree-inorder-traversal</title>
    <url>/leetcode94%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-binarytree-inorder-traversal/</url>
    <content><![CDATA[<img src="/leetcode94%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-binarytree-inorder-traversal/1596841508109.png" class="" width="1596841508109">

<a id="more"></a>

<h1 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h1><ul>
<li>Time complexity : O(n). The time complexity is O(n) because the recursive function is $T(n)=2⋅T(n/2)+1$.</li>
<li>Space complexity : The worst case space required is O(n), and in the average case it’s $O(\log n)$ where n is number of nodes.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        inorderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h1><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/solution/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span> || !<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="comment">//左节点</span></span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//中间节点</span></span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            <span class="comment">//右节点</span></span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-morris法"><a href="#3-morris法" class="headerlink" title="3.morris法"></a>3.morris法</h1><h3 id="1-算法"><a href="#1-算法" class="headerlink" title="1.算法"></a>1.算法</h3><p>Step 1: Initialize current as root</p>
<p>Step 2: While current is not NULL,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If current does not have left child</span><br><span class="line"></span><br><span class="line">    a. Add current’s value</span><br><span class="line"></span><br><span class="line">    b. Go to the right, i.e., current &#x3D; current.right</span><br><span class="line"></span><br><span class="line">Else</span><br><span class="line"></span><br><span class="line">    a. In current&#39;s left subtree, make current the right child of the rightmost node</span><br><span class="line"></span><br><span class="line">    b. Go to this left child, i.e., current &#x3D; current.left</span><br></pre></td></tr></table></figure>

<p>cur用来表示当前节点，prev用来选取当前节点的左节点的右子树最右边节点</p>
<h3 id="2-图形"><a href="#2-图形" class="headerlink" title="2.图形"></a>2.图形</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     3</span><br><span class="line"> &#x2F; \   &#x2F;</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>

<p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current’s left subtree is</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = cuurent.left (current = 2). The tree now looks like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       &#x2F;</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<p>For current 2, which has left child 4, we can continue with thesame process as we did above</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       &#x2F;</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* prev=root, *cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="comment">//如果cur有左节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//cur的左节点中的 右子树中的 最右边的节点</span></span><br><span class="line">                prev = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;right)&#123;</span><br><span class="line">                    prev=prev-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cur移动到该节点右边</span></span><br><span class="line">                prev-&gt;right = cur;</span><br><span class="line">                TreeNode* tmp =cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                tmp-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果cur没有左节点</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//node操作</span></span><br><span class="line">                <span class="comment">//======================</span></span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                <span class="comment">//======================</span></span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-复杂度"><a href="#4-复杂度" class="headerlink" title="4.复杂度"></a>4.复杂度</h3><ul>
<li>Time complexity : O(n). To prove that the time complexity is O(n), the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is O(nlogn), because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs O(n) time. <strong>Because a binary Tree with n nodes has n−1 edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is O(n).</strong></li>
<li>Space complexity : O(n). Arraylist of size n is used.</li>
</ul>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode98：验证二叉树-BST-validation</title>
    <url>/leetcode98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91-BFS-validation/</url>
    <content><![CDATA[<img src="/leetcode98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91-BFS-validation/1596833289221.png" class="" width="1596833289221">

<a id="more"></a>

<h1 id="1-中序遍历（递归）"><a href="#1-中序遍历（递归）" class="headerlink" title="1.中序遍历（递归）"></a>1.中序遍历（递归）</h1><p>二叉搜索树（binary search tree），如果按照中序遍历的话，就会得到一个从小到大排列的数组。那么只要检验当前节点的值是否比上一个节点小。如果全部符合就是一个BST，否则就不是。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//left node</span></span><br><span class="line">        <span class="keyword">bool</span> leftVal = isValidBST(root-&gt;left);</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//right node</span></span><br><span class="line">        <span class="keyword">bool</span> rightVal = isValidBST(root-&gt;right);</span><br><span class="line">        <span class="comment">//左节点和右节点，只要有一个不能用返回false，如果都能用就是true</span></span><br><span class="line">        <span class="keyword">return</span> leftVal&amp;&amp;rightVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种写法，一般来说if中含有return，就是一种筛选的情况，不返回的话，下面的语句都要在一种筛选的情况后运行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//只要左节点不符合就直接返回false</span></span><br><span class="line">        <span class="comment">//如果左节点符合就继续判断，看右节点是否符合</span></span><br><span class="line">        <span class="comment">//所以这里不能写成return isValidBST()</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//左节点已经验证过，此时右节点必须为true</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h1><p>The idea above could be implemented as a recursion. One compares the node value with its upper and lower limits if they are available. Then one repeats the same step recursively for left and right subtrees.</p>
<ul>
<li>Time complexity : $\mathcal{O}(N)$ since we visit each node exactly once.</li>
<li>Space complexity : $\mathcal{O}(N)$ since we keep up to the entire tree.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* <span class="built_in">min</span>, TreeNode* <span class="built_in">max</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//左子树比前一个节点大，return false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span> !=<span class="literal">NULL</span> &amp;&amp; root-&gt;val &gt;= <span class="built_in">max</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//右子树比父节点小，return false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> !=<span class="literal">NULL</span> &amp;&amp; root-&gt;val &lt;= <span class="built_in">min</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left,<span class="built_in">min</span>,root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;right,root,<span class="built_in">max</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>简化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* <span class="built_in">min</span>=<span class="literal">NULL</span>, TreeNode* <span class="built_in">max</span> = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>!=<span class="literal">NULL</span>&amp;&amp;root-&gt;val &gt;= <span class="built_in">max</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>!=<span class="literal">NULL</span>&amp;&amp;root-&gt;val &lt;= <span class="built_in">min</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left,<span class="built_in">min</span>,root)&amp;&amp;isValidBST(root-&gt;right,root,<span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-中序遍历（迭代）"><a href="#3-中序遍历（迭代）" class="headerlink" title="3.中序遍历（迭代）"></a>3.中序遍历（迭代）</h1><img src="/leetcode98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91-BFS-validation/145_transverse.png" class="" title="postorder">

<ul>
<li>Time complexity : $O(N)$ in the worst case when the tree is BST or the “bad” element is a rightmost leaf.</li>
<li>Space complexity : $O(N)$ to keep <code>stack</code>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">long</span> prev=LONG_MIN;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span> || !<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="comment">//left node</span></span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//inner node</span></span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(prev&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            prev = root-&gt;val;</span><br><span class="line">            <span class="comment">//right node</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode总结</title>
    <url>/leetcode%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>leetcode刷题总结</p>
<a id="more"></a>

<h1 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h1><p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa</a></p>
<p>数据结构基本都是由<strong>链表</strong>和<strong>数组</strong>构成的。算法基本都是为了实现增删改查。</p>
<p>其中链表访问速度慢，但修改速度快。数组的访问速度快，但修改速度慢（插入、删除）。</p>
<p>二叉树的访问：前序、中序、后续</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历的root操作在这里</span></span><br><span class="line">    method(root-&gt;left);</span><br><span class="line">    <span class="comment">//中序遍历的root操作在这里</span></span><br><span class="line">    right(root-&gt;right);</span><br><span class="line">    <span class="comment">//后序遍历的root操作在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method(root-&gt;n1);</span><br><span class="line">    method(root-&gt;n2);</span><br><span class="line">    ...</span><br><span class="line">    method(root-&gt;nn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-自己小结"><a href="#2-自己小结" class="headerlink" title="2.自己小结"></a>2.自己小结</h1><h3 id="1-if和return"><a href="#1-if和return" class="headerlink" title="1.if和return"></a>1.if和return</h3><p>一般来说if中含有return，就是一种筛选的情况，不返回的话，下面的语句都要在一种筛选的情况后运行。</p>
<p>比如：leetcode.98</p>
<p>一下两种情况相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//只要左节点不符合就直接返回false</span></span><br><span class="line">        <span class="comment">//如果左节点符合就继续判断，看右节点是否符合</span></span><br><span class="line">        <span class="comment">//所以这里不能写成return isValidBST()</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//左节点已经验证过，此时右节点必须为true</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//left node</span></span><br><span class="line">        <span class="keyword">bool</span> leftVal = isValidBST(root-&gt;left);</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//right node</span></span><br><span class="line">        <span class="keyword">bool</span> rightVal = isValidBST(root-&gt;right);</span><br><span class="line">        <span class="comment">//左节点和右节点，只要有一个不能用返回false，如果都能用就是true</span></span><br><span class="line">        <span class="keyword">return</span> leftVal&amp;&amp;rightVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-树"><a href="#3-树" class="headerlink" title="3.树"></a>3.树</h1><p><a href="https://www.cnblogs.com/bigsai/p/11393609.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigsai/p/11393609.html</a></p>
<p><a href="https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/</a></p>
<h3 id="1-几种遍历"><a href="#1-几种遍历" class="headerlink" title="1.几种遍历"></a>1.几种遍历</h3><img src="/leetcode%E6%80%BB%E7%BB%93/1597775405882.png" class="" width="1597775405882">

<p>前序遍历</p>
<img src="/leetcode%E6%80%BB%E7%BB%93/20190820000853382.png" class="" title="在这里插入图片描述">

<p>中序遍历</p>
<img src="/leetcode%E6%80%BB%E7%BB%93/1596820407921.png" class="" width="1596820407921">

<p>后序遍历（遍历二叉搜索树得到升序BST）</p>
<img src="/leetcode%E6%80%BB%E7%BB%93/1596820593086.png" class="" width="1596820593086">

<img src="/leetcode%E6%80%BB%E7%BB%93/145_transverse.png" class="" title="postorder">

<h3 id="2-BST"><a href="#2-BST" class="headerlink" title="2.BST"></a>2.BST</h3><p><a href="https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/</a></p>
<h3 id="3-inorder-iteration"><a href="#3-inorder-iteration" class="headerlink" title="3. inorder iteration"></a>3. inorder iteration</h3><p><a href="https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        Stack &lt; TreeNode &gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">//=========节点操作============</span></span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            <span class="comment">//============================</span></span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-morris"><a href="#4-morris" class="headerlink" title="4. morris"></a>4. morris</h3><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/solution/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        TreeNode pre;</span><br><span class="line">        <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.left == null) &#123;</span><br><span class="line">                <span class="comment">//=======节点操作=========</span></span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                <span class="comment">//========================</span></span><br><span class="line">                curr = curr.right; <span class="comment">// move to next right node</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// has a left subtree</span></span><br><span class="line">                pre = curr.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != null) &#123; <span class="comment">// find rightmost</span></span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.right = curr; <span class="comment">// put cur after the pre node</span></span><br><span class="line">                TreeNode temp = curr; <span class="comment">// store cur node</span></span><br><span class="line">                curr = curr.left; <span class="comment">// move cur to the top of the new tree</span></span><br><span class="line">                temp.left = null; <span class="comment">// original cur left be null, avoid infinite loops</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-数组、链表"><a href="#4-数组、链表" class="headerlink" title="4.数组、链表"></a>4.数组、链表</h1><h3 id="1-top-n"><a href="#1-top-n" class="headerlink" title="1.top-n"></a>1.top-n</h3><h3 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h3><h1 id="5-回溯法"><a href="#5-回溯法" class="headerlink" title="5.回溯法"></a>5.回溯法</h1><p>backtracking:</p>
<p><a href="https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html" target="_blank" rel="noopener">https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html</a></p>
<p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban</a></p>
<p>回溯法leetcode上较好的总结：</p>
<p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p>
<h1 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6.动态规划"></a>6.动态规划</h1><p>讲解页：</p>
<p><a href="https://www.geeksforgeeks.org/solve-dynamic-programming-problem/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/solve-dynamic-programming-problem/</a></p>
<p>以下借鉴：</p>
<p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] &#x3D; base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure>

<h3 id="1-通识"><a href="#1-通识" class="headerlink" title="1.通识"></a>1.通识</h3><p>Dynamic Programming is an algorithmic paradigm that solves a given complex problem by <strong>breaking it into subproblems</strong> and <strong>stores the results of subproblems</strong> to <strong>avoid</strong> computing the <strong>same results</strong> again.</p>
<p>It has two main properties:  <strong>Overlapping Subproblems, Optimal Substructure.</strong></p>
<p>Dynamic Programming is mainly used when solutions of same subproblems are needed again and again.So Dynamic Programming is not useful when there are no common (overlapping) subproblems because there is no point storing the solutions if they are not needed again.</p>
<hr>
<p>动态规划基本要素：<strong>重叠子问题，最优子结构，状态转移方程</strong>。</p>
<p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p>
<p><strong>重叠子问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上使用备忘录，就能解决重叠子问题，省去很多的重复操作，此时时间复杂度也就变成了O(n)</p>
<img src="/leetcode%E6%80%BB%E7%BB%93/2.jpg" class="" title="img">

<p>也可以使用<strong>table</strong>来记录并进行进一步修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>||N==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">table</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        table[<span class="number">1</span>] = <span class="number">1</span>;table[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            table[i] = table[i<span class="number">-1</span>]+table[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过因为斐波那契的每个状态只和上两个状态有关，就可以进行<strong>状态压缩</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-递归"><a href="#7-递归" class="headerlink" title="7.递归"></a>7.递归</h1><h3 id="1-通识-1"><a href="#1-通识-1" class="headerlink" title="1.通识"></a>1.通识</h3><p>解决递归问题时，最好画递归树，比如斐波那契问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>)+f(n+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<img src="/leetcode%E6%80%BB%E7%BB%93/1.jpg" class="" title="img">

<p>这里是想求f(20)，那么求f（20）就要解决f(19)和f(18)这两个问题，以此类推，直到终止条件。递归树也就数画了出来。</p>
<h3 id="2-复杂度计算"><a href="#2-复杂度计算" class="headerlink" title="2.复杂度计算"></a>2.复杂度计算</h3><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法极其低效。</p>
<h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8.查找"></a>8.查找</h1><h3 id="1-二分"><a href="#1-二分" class="headerlink" title="1.二分"></a>1.二分</h3><p>二分法主要分为三部分来看: mid-1, mid, mid+1</p>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html" target="_blank" rel="noopener">https://www.cnblogs.com/kyoner/p/11080078.html</a></p>
<p>搜索区间为[0,len-1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-分治"><a href="#2-分治" class="headerlink" title="2.分治"></a>2.分治</h3><p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html</a></p>
<blockquote>
<p><strong>三、分治法适用的情况</strong></p>
<p>​    分治法所能解决的问题一般具有以下几个特征：</p>
<p>​    1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>​    2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>​    3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>​    4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。</p>
</blockquote>
<p>步骤：</p>
<p>​    \1. if |P|≤n0</p>
<p>​    \2. then return(ADHOC(P))</p>
<p>​    \3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk</p>
<p>​    \4. for i←1 to k</p>
<p>​    \5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi</p>
<p>​    \6. T ← MERGE(y1,y2,…,yk) △ 合并子问题</p>
<p>​    \7. return(T)</p>
<p>比如求最长前缀</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        string lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">        string lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-矩阵"><a href="#9-矩阵" class="headerlink" title="9.矩阵"></a>9.矩阵</h1><h3 id="1-矩阵快速幂"><a href="#1-矩阵快速幂" class="headerlink" title="1.矩阵快速幂"></a>1.矩阵快速幂</h3><p><a href="https://blog.csdn.net/zhangxiaoduoduo/article/details/81807338" target="_blank" rel="noopener">https://blog.csdn.net/zhangxiaoduoduo/article/details/81807338</a></p>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</a></p>
<h1 id="10-公式推导"><a href="#10-公式推导" class="headerlink" title="10.公式推导"></a>10.公式推导</h1><h3 id="1-齐次线性递推"><a href="#1-齐次线性递推" class="headerlink" title="1.齐次线性递推"></a>1.齐次线性递推</h3><p>求斐波那契数列的特征方程和通项公式：</p>
<p><a href="https://blog.csdn.net/u011068702/article/details/78948145?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf" target="_blank" rel="noopener">https://blog.csdn.net/u011068702/article/details/78948145?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf</a></p>
<h1 id="11-string"><a href="#11-string" class="headerlink" title="11. string"></a>11. string</h1><h3 id="1-LCS-longest-common-subsequence"><a href="#1-LCS-longest-common-subsequence" class="headerlink" title="1.LCS( longest common subsequence)"></a>1.LCS( <strong>longest common subsequence</strong>)</h3><p>It differs from the <a href="https://en.wikipedia.org/wiki/Longest_common_substring_problem" target="_blank" rel="noopener">longest common substring problem</a>: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences. </p>
<h1 id="12-滑动窗口（子串）"><a href="#12-滑动窗口（子串）" class="headerlink" title="12.滑动窗口（子串）"></a>12.滑动窗口（子串）</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/</a></p>
<h1 id="13-红黑树（RBT）"><a href="#13-红黑树（RBT）" class="headerlink" title="13.红黑树（RBT）"></a>13.红黑树（RBT）</h1><p><a href="https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note</a></p>
<h1 id="14-并查集"><a href="#14-并查集" class="headerlink" title="14.并查集"></a>14.并查集</h1>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode100：相同的树</title>
    <url>/leetcode100%EF%BC%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<img src="/leetcode100%EF%BC%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/1596830840744.png" class="" width="1596830840744">

<a id="more"></a>

<h1 id="1-深度优先搜索"><a href="#1-深度优先搜索" class="headerlink" title="1.深度优先搜索"></a>1.深度优先搜索</h1><p>如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。</p>
<p>如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。</p>
<ul>
<li>Time complexity : $\mathcal{O}(N)$, where N is a number of nodes in the tree, since one visits each node exactly once.</li>
<li>Space complexity : $\mathcal{O}(\log(N))$ in the best case of completely balanced tree and $\mathcal{O}(N)$ in the worst case of completely unbalanced tree, to keep a recursion stack.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>||q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span> q == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            q != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; p.val == q.val</span><br><span class="line">            &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">            &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-广度优先搜索"><a href="#2-广度优先搜索" class="headerlink" title="2.广度优先搜索"></a>2.广度优先搜索</h1><p><a href="https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/</a></p>
<blockquote>
<p>使用两个队列分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。</p>
<p>比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；</p>
<p>如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；</p>
<p>如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。</p>
<p>如果搜索结束时两个队列同时为空，则两个二叉树相同。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。</p>
</blockquote>
<p>使用队列，循环直到有一个或者两个队列为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>^q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; pQue,qQue;</span><br><span class="line">        pQue.push(p);</span><br><span class="line">        qQue.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!pQue.empty()&amp;&amp;!qQue.empty())&#123;</span><br><span class="line">            TreeNode* pTop = pQue.front(), *qTop = qQue.front();</span><br><span class="line">            pQue.pop(); qQue.pop();</span><br><span class="line">            <span class="comment">//如果两个值相同，下一步</span></span><br><span class="line">            <span class="comment">//不相同，false</span></span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;val!=qTop-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//左右子树，不全为null的，false</span></span><br><span class="line">            <span class="comment">//全为null下一步</span></span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;left==<span class="literal">nullptr</span>^qTop-&gt;left==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;right==<span class="literal">nullptr</span>^qTop-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//左右子树，全不是null的，分别推入队列</span></span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;left&amp;&amp;qTop-&gt;left)&#123;</span><br><span class="line">                pQue.push(pTop-&gt;left);</span><br><span class="line">                qQue.push(qTop-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;right&amp;&amp;qTop-&gt;right)&#123;</span><br><span class="line">                pQue.push(pTop-&gt;right);</span><br><span class="line">                qQue.push(qTop-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pQue.empty()&amp;&amp;qQue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>connect to host github.com port 22 Operation timed out</title>
    <url>/FatalgitConnection/</url>
    <content><![CDATA[<p>hexo push到git时报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Operation timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这是因为防火墙的原因，把访问端口屏蔽了。</p>
<p><a href="https://stackoverflow.com/questions/7953806/github-ssh-via-public-wifi-port-22-blocked/8081292#8081292" target="_blank" rel="noopener">https://stackoverflow.com/questions/7953806/github-ssh-via-public-wifi-port-22-blocked/8081292#8081292</a></p>
<p>Try this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim ~&#x2F;.ssh&#x2F;config</span><br></pre></td></tr></table></figure>

<p>Add</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo美化</title>
    <url>/hexo%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>对hexo的next主题进行进一步的个性化</p>
<a id="more"></a>

<p>next官方博客：<a href="https://theme-next.js.org/docs/third-party-services/external-libraries.html" target="_blank" rel="noopener">https://theme-next.js.org/docs/third-party-services/external-libraries.html</a></p>
<h1 id="1-创建自定义文件"><a href="#1-创建自定义文件" class="headerlink" title="1.创建自定义文件"></a>1.创建自定义文件</h1><p>在next的config文件下，搜索如下文件，将注释取消。</p>
<img src="/hexo%E7%BE%8E%E5%8C%96/1596784778759.png" class="" width="1596784778759">

<p>然后在<strong>hexo根目录</strong>的source下创建<strong>_data</strong>文件夹，里面存放styles.styl文件。</p>
<p>之后就可以在这个文件里添加自己想要添加的css代码（可以是styl格式）</p>
<h1 id="2-自定义整理"><a href="#2-自定义整理" class="headerlink" title="2.自定义整理"></a>2.自定义整理</h1><p><a href="https://www.jianshu.com/p/5017abb0d0a2" target="_blank" rel="noopener">https://www.jianshu.com/p/5017abb0d0a2</a></p>
<p><a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">https://io-oi.me/tech/hexo-next-optimization/</a></p>
<p><a href="https://sunderarmor.ink/2019/06/20/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/#more" target="_blank" rel="noopener">https://sunderarmor.ink/2019/06/20/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/#more</a></p>
<h3 id="1-滚动条设置"><a href="#1-滚动条设置" class="headerlink" title="1.滚动条设置"></a>1.滚动条设置</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 更好的侧边滚动条</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:increment</span>,<span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:decrement</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-corner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span>,<span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat <span class="number">0</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">15px</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">30px</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-添加自定义图标（bilibili、简书等）"><a href="#2-添加自定义图标（bilibili、简书等）" class="headerlink" title="2.添加自定义图标（bilibili、简书等）"></a>2.添加自定义图标（bilibili、简书等）</h3><p><a href="https://blog.dlzhang.com/posts/32/" target="_blank" rel="noopener">https://blog.dlzhang.com/posts/32/</a></p>
<p>这里可以使用阿里矢量库，在里面搜索相关的图标，添加至购物车，然后下载代码。</p>
<p>将其中的<strong>iconfont.css</strong>的代码复制粘贴在styles.styl里面，此时就可以在hexo中使用<code>&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</code>进行引用了。</p>
<p>但如果想在侧边栏隐形，需要进一步修改</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;<span class="attribute">font-family</span>: <span class="string">"iconfont"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'iconfont.eot?t=1596739855011'</span>); <span class="comment">/* IE9 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'iconfont.eot?t=1596739855011#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAUEAAsAAAAACdQAAAS4AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCDHAqHCIVTATYCJAMQCwoABCAFhG0HUBtNCFGULk6N7Edh3LaEI5xZSilVQyl4tvV9vdPGw39rr/fNzC4H0CUKULLi46OiiqQqFLBqpatTZSP+1bTtU9t4Zseny1e0pqq/u+wlm/TN0sbjNMqAkCAcg2xqKN3+k4m5wFVpp+YXtT/unf5R54HNZ1kuYy0ba1DUBRiNrYHtiVEgBThAIg3AYm8Yu4k8yPMEeqsCs6uLu0dYU4BpgXjFhYG1hFapIIVWUResLeK7Spu+pm/gm/f++C+LNZIqA3Ovn5zncPSz/n074xPcLYrgDWeGsomMPaAQzwqtDywG/j2Leit6ySHQQnNiqJ7538GTicjfirQV//IISSZqQDoKxH1JPjAeZhD85mCQ+B2slXm8PN9iHsQuQNwZ7EHoVEq1cbh3sLxatePJ6kLzMTk2ZmaUynmGI5zk4iJbIAQbJOKNY14CtZVcV5u5mtelSDpRxtvWJygIr9HC+Upz+CtIGUyCTlew459QNTUkSLRBGEar4K4gdXRE6JU8PLCNFo4fc5WPY5gEbGnj5UWZEOY0gKEw/GTfB0OZvQBEMABwpE0A8Sk8fut18s77wQff++/jQLWQondFNZdPvVL3ulQznXfvgWBVkyBG1PFCQsIHqx4nm3lVqySHtrjL6wGk1XBhXtRUwR8uizWG/jZRhLcvRDEKLPSGvmXXOnAuL3htY2YAUPD+6XWM5erm7CCCEkNzWxD60Imua+EszeN8FLxHOrltShAlZsNaOgDA2692IgjRFRn7aTgAAEQNUbnlrQf1PDQd5gGnFcJkCdTCWnFGhQ7RuuhGHcnkNcXhrW154UVVFvVhvfDq2aKfMsNKNL5T2yxmkjERNsK3Q39XM3IIKJgN6fQE93RZiDW5duvekt9/e/TtNsXDp3lfVdtAwowrdts3yKSDKrPpTDon3GI4x1nAkKHCv+UvjlvilVK6L0uYBIooAFH8EVVMjPoIsiibCKN7NheiSI4PuwUlXWFLKn2ZomM/P8DIVixn9vTeM6PzlLObWewo4qZHc3rLwSDz4wNqJdHyGB0ldCixDLRkMMbIPBvloiWlMvW30gH8r80UtfxJfzawIIlduXIZfXRbokJi29nZXySmIlrERyS6IkZEgbf4OztXDv3xReG2qlwQ/++7qsAfKKj5pITtEoc3x2WpPOrNjQVsuZ45T+oy77gE2ABwol0o7982Dg7rX34OZTX6dxo+7aonHuJf73gFE7xAfsMvw2vM+7d4DUuKLQC6Ukwh5jqJxQcdrypVr8cfFWbe3xDypcbJhNZSBEljBbLWGlqIe1AZ7EOtdQq9XZebBwvEoigddnxyEGZ9QTLtB2SzftBC/IXKsn+ozcYi9G6Cc8/BRvCGpZBRytF+ILu+88igG37qPRUvjZG4wCM/k0zswjRK0qFL6kiGWDC9FpmqRy99ixfcZdQ0PQ7SV+Q0KlWHeRz7ohtFrm9hwyVBDEVyyPqAmNPreFpZbWRef48UXjQMqShqMT8jYsL9o1QkaYBeSrtGRZdyzeRVIaOUhzzRa6ELzkwa6O+hoXhUhTgqUnbwDuZioZxvKo2ml7d3uAl6YM8SKXKUqDQv2HRT+bJVUDIdGjoW19B2BDeMRSGydQQA'</span>) <span class="built_in">format</span>(<span class="string">'woff2'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'iconfont.woff?t=1596739855011'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'iconfont.ttf?t=1596739855011'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>), <span class="comment">/* chrome, firefox, opera, Safari, Android, iOS 4.2+ */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'iconfont.svg?t=1596739855011#iconfont'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>); <span class="comment">/* iOS 4.1- */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:inherit;</span><br><span class="line">  <span class="attribute">font-style</span>:normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-jianshu</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e506"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-zhihu-circle</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e712"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-bilibili-line</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e75d"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是第10行到第16行的修改。这样就可以使用使用了。</p>
<img src="/hexo%E7%BE%8E%E5%8C%96/1596785254999.png" class="" width="1596785254999">

<h3 id="3-域名绑定"><a href="#3-域名绑定" class="headerlink" title="3.域名绑定"></a>3.域名绑定</h3><ol>
<li><p>在hexo的source下添加CNAME文件（无后缀），在里面写上自己的域名，如：<a href="http://www.gzhao01.top">www.gzhao01.top</a></p>
</li>
<li><p>在github设置中，custom domain下面设置该域名</p>
</li>
<li><p>ping一下自己的项目部署网址，得到ip地址</p>
</li>
<li><p>在阿里云的域名服务中添加两个解析记录分别是www和@记录。</p>
<img src="/hexo%E7%BE%8E%E5%8C%96/1596786571292.png" class="" width="1596786571292">

</li>
</ol>
<h3 id="4-SSL证书"><a href="#4-SSL证书" class="headerlink" title="4.SSL证书"></a>4.SSL证书</h3><p>如果是部署在github上的，只要在setting界面勾选enfore https即可。</p>
<h3 id="5-设置置顶"><a href="#5-设置置顶" class="headerlink" title="5.设置置顶"></a>5.设置置顶</h3><ol>
<li><p>插件的安装和卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在文章中加入top，top的值越大，权重越大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo Next主题设置文章置顶</span><br><span class="line">id: a1</span><br><span class="line">date: 2020-01-03 17:26:01</span><br><span class="line">categories: Hexo</span><br><span class="line">tags: Next主题</span><br><span class="line">top: 999</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置置顶标志</p>
<p>在next/layout/_macro/post.swig中的添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class&#x3D;&quot;fas fa-thumbtack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;font color&#x3D;&quot;999&quot;&gt;pin top&lt;&#x2F;font&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>位置如下：</p>
<img src="/hexo%E7%BE%8E%E5%8C%96/1596921149652.png" class="" width="1596921149652">

</li>
</ol>
<p>最终的效果如下：</p>
<img src="/hexo%E7%BE%8E%E5%8C%96/1596919102715.png" class="" width="1596919102715">

<h3 id="6-文章推荐插件"><a href="#6-文章推荐插件" class="headerlink" title="6.文章推荐插件"></a>6.文章推荐插件</h3><p><a href="https://github.com/huiwang/hexo-recommended-posts" target="_blank" rel="noopener">https://github.com/huiwang/hexo-recommended-posts</a></p>
<p>安装：</p>
<p><code>npm install hexo-recommended-posts --save</code></p>
<p>获取recommend列表</p>
<p><code>hexo recommend</code></p>
<p>可以在config中修改配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recommended_posts:</span><br><span class="line">  server: https:&#x2F;&#x2F;api.truelaurel.com #后端推荐服务器地址</span><br><span class="line">  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式</span><br><span class="line">  internalLinks: 3 #内部文章数量</span><br><span class="line">  externalLinks: 1 #外部文章数量</span><br><span class="line">  fixedNumber: false</span><br><span class="line">  autoDisplay: true #自动在文章底部显示推荐文章</span><br><span class="line">  excludePattern: []</span><br><span class="line">  titleHtml: &lt;h1&gt;推荐文章&lt;span style&#x3D;&quot;font-size:0.45em; color:gray&quot;&gt;（由&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;huiwang&#x2F;hexo-recommended-posts&quot;&gt;hexo文章推荐插件&lt;&#x2F;a&gt;驱动）&lt;&#x2F;span&gt;&lt;&#x2F;h1&gt; #自定义标题</span><br></pre></td></tr></table></figure>

<h3 id="7-echarts"><a href="#7-echarts" class="headerlink" title="7.echarts"></a>7.echarts</h3><p>改了好久但还是失败了</p>
<p><a href="http://fuxuemingzhu.cn/2017/08/10/echarts-hexo/" target="_blank" rel="noopener">http://fuxuemingzhu.cn/2017/08/10/echarts-hexo/</a></p>
<p><a href="https://blog.csdn.net/qq_41426117/article/details/105416911" target="_blank" rel="noopener">https://blog.csdn.net/qq_41426117/article/details/105416911</a></p>
<p><a href="https://codertang.com/2019/02/21/hexo-drawing-echarts/" target="_blank" rel="noopener">https://codertang.com/2019/02/21/hexo-drawing-echarts/</a></p>
<p><a href="https://houmin.cc/posts/d823886b/" target="_blank" rel="noopener">https://houmin.cc/posts/d823886b/</a></p>
<p><a href="https://kchen.cc/2016/11/05/echarts-in-hexo/" target="_blank" rel="noopener">https://kchen.cc/2016/11/05/echarts-in-hexo/</a></p>
<h1 id="3-有用的资料"><a href="#3-有用的资料" class="headerlink" title="3.有用的资料"></a>3.有用的资料</h1><p><a href="https://blog.csdn.net/sunshine940326/article/details/70936988/" target="_blank" rel="noopener">https://blog.csdn.net/sunshine940326/article/details/70936988/</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>titanic logistic prac</title>
    <url>/titanic_logistic_prac/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49797143</a><br>本篇文章只是进行简单的复原</p>
<a id="more"></a>

<h1 id="1、数据分析"><a href="#1、数据分析" class="headerlink" title="1、数据分析"></a>1、数据分析</h1><p>首先简单的导入数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment">#数据分析</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#科学计算</span></span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br><span class="line"></span><br><span class="line">data_train = pd.read_csv(<span class="string">"../titanic/train.csv"</span>)</span><br><span class="line">data_train</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>C85</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>C123</td>
      <td>S</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>886</th>
      <td>887</td>
      <td>0</td>
      <td>2</td>
      <td>Montvila, Rev. Juozas</td>
      <td>male</td>
      <td>27.0</td>
      <td>0</td>
      <td>0</td>
      <td>211536</td>
      <td>13.0000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>887</th>
      <td>888</td>
      <td>1</td>
      <td>1</td>
      <td>Graham, Miss. Margaret Edith</td>
      <td>female</td>
      <td>19.0</td>
      <td>0</td>
      <td>0</td>
      <td>112053</td>
      <td>30.0000</td>
      <td>B42</td>
      <td>S</td>
    </tr>
    <tr>
      <th>888</th>
      <td>889</td>
      <td>0</td>
      <td>3</td>
      <td>Johnston, Miss. Catherine Helen "Carrie"</td>
      <td>female</td>
      <td>NaN</td>
      <td>1</td>
      <td>2</td>
      <td>W./C. 6607</td>
      <td>23.4500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>889</th>
      <td>890</td>
      <td>1</td>
      <td>1</td>
      <td>Behr, Mr. Karl Howell</td>
      <td>male</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>111369</td>
      <td>30.0000</td>
      <td>C148</td>
      <td>C</td>
    </tr>
    <tr>
      <th>890</th>
      <td>891</td>
      <td>0</td>
      <td>3</td>
      <td>Dooley, Mr. Patrick</td>
      <td>male</td>
      <td>32.0</td>
      <td>0</td>
      <td>0</td>
      <td>370376</td>
      <td>7.7500</td>
      <td>NaN</td>
      <td>Q</td>
    </tr>
  </tbody>
</table>
<p>891 rows × 12 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.info()</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;
RangeIndex: 891 entries, 0 to 890
Data columns (total 12 columns):
 #   Column       Non-Null Count  Dtype  
---  ------       --------------  -----  
 0   PassengerId  891 non-null    int64  
 1   Survived     891 non-null    int64  
 2   Pclass       891 non-null    int64  
 3   Name         891 non-null    object 
 4   Sex          891 non-null    object 
 5   Age          714 non-null    float64
 6   SibSp        891 non-null    int64  
 7   Parch        891 non-null    int64  
 8   Ticket       891 non-null    object 
 9   Fare         891 non-null    float64
 10  Cabin        204 non-null    object 
 11  Embarked     889 non-null    object 
dtypes: float64(2), int64(5), object(5)
memory usage: 83.7+ KB</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.describe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>714.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>446.000000</td>
      <td>0.383838</td>
      <td>2.308642</td>
      <td>29.699118</td>
      <td>0.523008</td>
      <td>0.381594</td>
      <td>32.204208</td>
    </tr>
    <tr>
      <th>std</th>
      <td>257.353842</td>
      <td>0.486592</td>
      <td>0.836071</td>
      <td>14.526497</td>
      <td>1.102743</td>
      <td>0.806057</td>
      <td>49.693429</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>0.420000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>223.500000</td>
      <td>0.000000</td>
      <td>2.000000</td>
      <td>20.125000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>7.910400</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>446.000000</td>
      <td>0.000000</td>
      <td>3.000000</td>
      <td>28.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>14.454200</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>668.500000</td>
      <td>1.000000</td>
      <td>3.000000</td>
      <td>38.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>31.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>891.000000</td>
      <td>1.000000</td>
      <td>3.000000</td>
      <td>80.000000</td>
      <td>8.000000</td>
      <td>6.000000</td>
      <td>512.329200</td>
    </tr>
  </tbody>
</table>
</div>



<p>这里只会显示类型为数值的属性<br>可以发现乘客平均生存率0.38,二三等舱人数较多，平均年龄29<br>同时Age字段有数据丢失,embarked有少量数值丢失，Cabin有大量数值丢失</p>
<h1 id="2-各属性乘客分布"><a href="#2-各属性乘客分布" class="headerlink" title="2. 各属性乘客分布"></a>2. 各属性乘客分布</h1><p>下一步就是对各个属性的乘客分布进行大致的把握，这样子对数据也能有个大体的认识</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'KaiTi'</span>] <span class="comment">#字体</span></span><br><span class="line">plt.rcParams[<span class="string">'font.serif'</span>] = [<span class="string">'KaiTi'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment">#改变图片大小</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>) <span class="comment">#图表颜色alpha</span></span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">0</span>)) <span class="comment">#划分成小图</span></span><br><span class="line">data_train.Survived.value_counts().plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.title(<span class="string">u"survived(1 as survived)"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">data_train.Pclass.value_counts().plot(kind=<span class="string">"bar"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line">plt.title(<span class="string">u"乘客等级分布"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line">plt.scatter(data_train.Survived, data_train.Age)</span><br><span class="line">plt.ylabel(<span class="string">u"年龄"</span>)</span><br><span class="line">plt.grid(b=<span class="literal">True</span>, which=<span class="string">'major'</span>, axis=<span class="string">'y'</span>)</span><br><span class="line">plt.title(<span class="string">u"年龄和获救分布(1为获救)"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),colspan=<span class="number">2</span>)</span><br><span class="line">data_train.Age[data_train.Pclass == <span class="number">1</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">data_train.Age[data_train.Pclass == <span class="number">2</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">data_train.Age[data_train.Pclass == <span class="number">3</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"年龄"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"密度"</span>)</span><br><span class="line">plt.title(<span class="string">u"各等级客舱乘客年龄密度分布"</span>)</span><br><span class="line">plt.legend((<span class="string">u"一等"</span>,<span class="string">u"二等"</span>,<span class="string">u"三等"</span>),loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">data_train.Embarked.value_counts().plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.title(<span class="string">u"各登船口岸登船人数"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<img src="/titanic_logistic_prac/output_7_0.png" class="" title="png">


<p>从上图可以发现，未获救人数较被获救人数多了很多。乘客也普遍分布在三等舱，说明三等舱人数较多，未来要考虑到这个比例问题。各个舱的年龄分布相似，但一等舱年龄偏大。同时S港口登船人数最多。</p>
<h1 id="3-属性与获救结果的关系"><a href="#3-属性与获救结果的关系" class="headerlink" title="3.属性与获救结果的关系"></a>3.属性与获救结果的关系</h1><p>下面就要观察我们关系的获救结果与各个属性之间的大致关系</p>
<h3 id="1-客舱等级"><a href="#1-客舱等级" class="headerlink" title="1.客舱等级"></a>1.客舱等级</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#存活人数</span></span><br><span class="line">Survived_1 = data_train.Pclass[data_train.Survived == <span class="number">1</span>].value_counts()</span><br><span class="line"><span class="comment">#未存活人数</span></span><br><span class="line">Survived_0 = data_train.Pclass[data_train.Survived == <span class="number">0</span>].value_counts()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u'获救'</span>:Survived_1, <span class="string">u'未获救'</span>:Survived_0&#125;)</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>, stacked=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">u"各等式客舱乘客获救情况"</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"客舱等级"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br></pre></td></tr></table></figure>




<pre><code>Text(0, 0.5, &apos;人数&apos;)




&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><img src="/titanic_logistic_prac/output_9_2.png" class="" title="png">


<p>可以发现，明显一客舱成员获救比例高，而三客舱成员获救比例低。可能是因为人员密集度，社会地位，财富等原因造成这样的差异。</p>
<h3 id="2-性别"><a href="#2-性别" class="headerlink" title="2.性别"></a>2.性别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">Survived_0 = data_train.Sex[data_train.Survived == <span class="number">0</span>].value_counts()</span><br><span class="line">Survived_1 = data_train.Sex[data_train.Survived == <span class="number">1</span>].value_counts()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u'获救'</span>: Survived_1,<span class="string">u'未获救'</span>: Survived_0&#125;)</span><br></pre></td></tr></table></figure>


<pre><code>&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>)</span><br><span class="line">plt.title(<span class="string">u"性别和船舱级别与获救情况"</span>)</span><br><span class="line">plt.xticks([]) <span class="comment">#隐藏坐标轴</span></span><br><span class="line">plt.yticks([]) </span><br><span class="line"></span><br><span class="line"><span class="comment">#high class female</span></span><br><span class="line">ax1=fig.add_subplot(<span class="number">141</span>)</span><br><span class="line">high_female = data_train.Survived[data_train.Sex==<span class="string">'female'</span>][data_train.Pclass!=<span class="number">3</span>].value_counts()</span><br><span class="line">high_female.plot(kind=<span class="string">'bar'</span>,label=<span class="string">"female highClass"</span>, color=<span class="string">'#FA2479'</span>)</span><br><span class="line">ax1.set_xticklabels([<span class="string">u"获救"</span>,<span class="string">u"未获救"</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax1.legend([<span class="string">u"女性/高级舱"</span>],loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#high class male</span></span><br><span class="line">ax2=fig.add_subplot(<span class="number">142</span>)</span><br><span class="line">high_male=data_train.Survived[data_train.Sex==<span class="string">'male'</span>][data_train.Pclass!=<span class="number">3</span>].value_counts()</span><br><span class="line">high_male.plot(kind=<span class="string">'bar'</span>,label=<span class="string">'male highclass'</span>, color=<span class="string">'pink'</span>)</span><br><span class="line">ax2.set_xticklabels([<span class="string">u'获救'</span>,<span class="string">u'未获救'</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax2.legend([<span class="string">u"男性/高级舱"</span>],loc=<span class="string">"best"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#low class female</span></span><br><span class="line">ax3=fig.add_subplot(<span class="number">143</span>)</span><br><span class="line">high_female = data_train.Survived[data_train.Sex==<span class="string">'female'</span>][data_train.Pclass==<span class="number">3</span>].value_counts()</span><br><span class="line">high_female.plot(kind=<span class="string">'bar'</span>,label=<span class="string">"female highClass"</span>, color=<span class="string">'red'</span>)</span><br><span class="line">ax3.set_xticklabels([<span class="string">u"获救"</span>,<span class="string">u"未获救"</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax3.legend([<span class="string">u"女性/高级舱"</span>],loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#low class male</span></span><br><span class="line">ax4=fig.add_subplot(<span class="number">144</span>)</span><br><span class="line">high_male=data_train.Survived[data_train.Sex==<span class="string">'male'</span>][data_train.Pclass==<span class="number">3</span>].value_counts()</span><br><span class="line">high_male.plot(kind=<span class="string">'bar'</span>,label=<span class="string">'male highclass'</span>, color=<span class="string">'blue'</span>)</span><br><span class="line">ax4.set_xticklabels([<span class="string">u'获救'</span>,<span class="string">u'未获救'</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax4.legend([<span class="string">u"男性/高级舱"</span>],loc=<span class="string">"best"</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.legend.Legend at 0x27ae4edfcc8&gt;</code></pre><img src="/titanic_logistic_prac/output_12_1.png" class="" title="png">


<p>可以发现女性获救比例明显高于男性获救比例。</p>
<h3 id="3-登录的港口"><a href="#3-登录的港口" class="headerlink" title="3.登录的港口"></a>3.登录的港口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">Survived_0 = data_train.Embarked[data_train.Survived == <span class="number">0</span>].value_counts()</span><br><span class="line">Survived_1 = data_train.Embarked[data_train.Survived == <span class="number">1</span>].value_counts()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u'获救'</span>: Survived_1,<span class="string">u'未获救'</span>: Survived_0&#125;)</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,stacked=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x27ae52aeb08&gt;




&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><img src="/titanic_logistic_prac/output_14_2.png" class="" title="png">


<p>可以发现S港里未获救人口比例较高</p>
<h3 id="4-家属个数与获救情况"><a href="#4-家属个数与获救情况" class="headerlink" title="4.家属个数与获救情况"></a>4.家属个数与获救情况</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = data_train.groupby([<span class="string">'SibSp'</span>,<span class="string">'Survived'</span>])</span><br><span class="line">df = pd.DataFrame(g.count()[<span class="string">'PassengerId'</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>                PassengerId
SibSp Survived             
0     0                 398
      1                 210
1     0                  97
      1                 112
2     0                  15
      1                  13
3     0                  12
      1                   4
4     0                  15
      1                   3
5     0                   5
8     0                   7</code></pre><h3 id="5-Cabin"><a href="#5-Cabin" class="headerlink" title="5. Cabin"></a>5. Cabin</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.Cabin.value_counts()</span><br></pre></td></tr></table></figure>




<pre><code>B96 B98        4
G6             4
C23 C25 C27    4
F33            3
C22 C26        3
              ..
A19            1
C7             1
D15            1
E77            1
A10            1
Name: Cabin, Length: 147, dtype: int64</code></pre><p>因为没有规律，并且是类别属性，所以可以看看Cabin的有无对于结果的影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无Cabin属性</span></span><br><span class="line">Survived_cabin = data_train.Survived[pd.isnull(data_train.Cabin)].value_counts()</span><br><span class="line"><span class="comment">#有Cabin属性</span></span><br><span class="line">Survived_nocabin = data_train.Survived[pd.notnull(data_train.Cabin)].value_counts()</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u"无cabin"</span>: Survived_cabin,<span class="string">u"有cabin"</span>:Survived_nocabin&#125;).transpose()</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,stacked=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">"cabin有无对获救情况的影响"</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"1为获救，0为未获救"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<pre><code>&lt;Figure size 720x576 with 0 Axes&gt;</code></pre>{% asset_img output_20_1.png png %}


<p>根据上面可以看出，无cabin的获救比例较高<br><strong>这里要注意的是</strong>：<br>看下图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无Cabin属性</span></span><br><span class="line">Survived_cabin = data_train.Survived[pd.isnull(data_train.Cabin)].value_counts()</span><br><span class="line"><span class="comment">#有Cabin属性</span></span><br><span class="line">Survived_nocabin = data_train.Survived[pd.notnull(data_train.Cabin)].value_counts()</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u"无cabin"</span>: Survived_cabin,<span class="string">u"有cabin"</span>:Survived_nocabin&#125;)</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,stacked=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">"不同获救情况的有无cabin比例"</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"1为获救，0为未获救"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<pre><code>&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><img src="/titanic_logistic_prac/output_22_1.png" class="" title="png">


<p>以上两张图，可以看出，在第二张图中无论是获救还是未获救，无cabin记录的人数占比都较高。但是第一张图却反映出有cabin记录的人获救比例较高。这是为什么？<br>个人理解是因为条件概率问题。可以发现有cabin记录的人数仅为200多人，占比少数。所以假设有个人，那么这个人无论获救没获救，他是有cabin记录的可能性都会较低，因为本身这个群体占比就低。那么假设有另一个人，这个人是获救的人，那么他极可能就是有cabin记录的人，这样也就符合了第一幅图的描述。</p>
<h1 id="4-数据预处理"><a href="#4-数据预处理" class="headerlink" title="4.数据预处理"></a>4.数据预处理</h1><p>数据预处理包括了feature engineer的过程。<br>首先要对缺值进行处理</p>
<h3 id="1-对缺值的处理"><a href="#1-对缺值的处理" class="headerlink" title="1.对缺值的处理"></a>1.对缺值的处理</h3><p>1.缺值样本占比极高<br>一般会选择舍弃该属性，否则可能会对训练结果产生不好的影响<br>2.缺值的占比适中，并且是<strong>非连续值</strong>的属性（比如类属性）<br>一般把NaN作为一个新类，并入之前的类目之中<br>3.缺值样本适中，并且是<strong>连续</strong>的特征值<br>那么一般会定长，使用一个step，将其<strong>离散化</strong>，然后把NaN作为一个类并入其中<br>4.缺值不多<br>可以尝试拟合数值，补充空缺</p>
<p>下面对缺值少的属性进行拟合补缺</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment">#补充缺失的年龄属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_missing_ages</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="comment">#放入数值型属性</span></span><br><span class="line">    age_df = df[[<span class="string">'Age'</span>,<span class="string">'Fare'</span>,<span class="string">'Parch'</span>,<span class="string">'SibSp'</span>,<span class="string">'Pclass'</span>]]</span><br><span class="line">    <span class="comment">#已知年龄和未知年龄的</span></span><br><span class="line">    known_age = age_df[age_df.Age.notnull()].values</span><br><span class="line">    unknown_age = age_df[age_df.Age.isnull()].values</span><br><span class="line">    </span><br><span class="line">    y = known_age[:,<span class="number">0</span>]</span><br><span class="line">    X = known_age[:,<span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    rfr = RandomForestRegressor(random_state=<span class="number">0</span>,n_estimators=<span class="number">2000</span>,n_jobs=<span class="number">-1</span>)</span><br><span class="line">    rfr.fit(X,y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#预测结果</span></span><br><span class="line">    predictedAges =rfr.predict(unknown_age[:,<span class="number">1</span>::])</span><br><span class="line">    </span><br><span class="line">    df.loc[(df.Age.isnull()), <span class="string">'Age'</span>] = predictedAges</span><br><span class="line">    <span class="keyword">return</span> df, rfr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_Cabin_type</span><span class="params">(df)</span>:</span></span><br><span class="line">    df.loc[(df.Cabin.notnull()),<span class="string">'Cabin'</span>] = <span class="string">"Yes"</span></span><br><span class="line">    df.loc[(df.Cabin.isnull()),<span class="string">'Cabin'</span>] = <span class="string">"No"</span></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数内部修改了data_train</span></span><br><span class="line">data_train, rfr = set_missing_ages(data_train)</span><br><span class="line">data_train = set_Cabin_type(data_train)</span><br><span class="line">data_train.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>No</td>
      <td>S</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>Yes</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>No</td>
      <td>S</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>Yes</td>
      <td>S</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>No</td>
      <td>S</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="2-因子化"><a href="#2-因子化" class="headerlink" title="2.因子化"></a>2.因子化</h3><p>特征因子化，举例来说，就是Cabin的取值只能为[‘yes’,’no’]，那么就可以把他展开成两个属性’cabin_yes’和’cabin_no’<br>那么原本取值为’yes’的，在此处’cabin_yes’下为1，’cabin_no’下为0；<br>原本取值为’no’的，在此处’cabin_yse’下为0，’cabin_no’下为1；<br>此处使用’get_dummies’来实现这个效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummies_Cabin = pd.get_dummies(data_train[<span class="string">'Cabin'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Pclass = pd.get_dummies(data_train[<span class="string">'Pclass'</span>],prefix=<span class="string">'Pclass'</span>)</span><br><span class="line">dummies_Sex = pd.get_dummies(data_train[<span class="string">'Sex'</span>],prefix=<span class="string">'Sex'</span>)</span><br><span class="line">dummies_Embarked = pd.get_dummies(data_train[<span class="string">'Embarked'</span>],prefix=<span class="string">'Embarked'</span>)</span><br><span class="line"></span><br><span class="line">df = pd.concat([data_train, dummies_Cabin, dummies_Embarked, dummies_Pclass, dummies_Sex],axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#去除无用属性</span></span><br><span class="line">df.drop([<span class="string">'Name'</span>,<span class="string">'Pclass'</span>,<span class="string">'Sex'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>,<span class="string">'Embarked'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
      <th>Cabin_No</th>
      <th>Cabin_Yes</th>
      <th>Embarked_C</th>
      <th>Embarked_Q</th>
      <th>Embarked_S</th>
      <th>Pclass_1</th>
      <th>Pclass_2</th>
      <th>Pclass_3</th>
      <th>Sex_female</th>
      <th>Sex_male</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>22.000000</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>38.000000</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>35.000000</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>35.000000</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>886</th>
      <td>887</td>
      <td>0</td>
      <td>27.000000</td>
      <td>0</td>
      <td>0</td>
      <td>13.0000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>887</th>
      <td>888</td>
      <td>1</td>
      <td>19.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>888</th>
      <td>889</td>
      <td>0</td>
      <td>16.185117</td>
      <td>1</td>
      <td>2</td>
      <td>23.4500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>889</th>
      <td>890</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>890</th>
      <td>891</td>
      <td>0</td>
      <td>32.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.7500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>891 rows × 16 columns</p>
</div>



<h3 id="3-数据标准化"><a href="#3-数据标准化" class="headerlink" title="3.数据标准化"></a>3.数据标准化</h3><p>经过以上的处理结果，剩下的问题就是Age以及Fare的scale差距过大，需要进行标准化。<br>可以使用scikit-learn里面的preprocessing进行scaling，转化到[-1,1]之间的数值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.preprocessing <span class="keyword">as</span> preprocessing</span><br><span class="line">scaler = preprocessing.StandardScaler()</span><br><span class="line"><span class="comment"># age_scale_param = scaler.fit(df['Age'])</span></span><br><span class="line">df[<span class="string">'Age_scaled'</span>] = scaler.fit_transform(df[<span class="string">'Age'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># fare_scale_param = scaler.fit(df['Fare'])</span></span><br><span class="line">df[<span class="string">'Fare_scaled'</span>] = scaler.fit_transform(df[<span class="string">'Fare'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
      <th>Cabin_No</th>
      <th>Cabin_Yes</th>
      <th>Embarked_C</th>
      <th>Embarked_Q</th>
      <th>Embarked_S</th>
      <th>Pclass_1</th>
      <th>Pclass_2</th>
      <th>Pclass_3</th>
      <th>Sex_female</th>
      <th>Sex_male</th>
      <th>Age_scaled</th>
      <th>Fare_scaled</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>22.000000</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>-0.561377</td>
      <td>-0.502445</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>38.000000</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0.613173</td>
      <td>0.786845</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-0.267740</td>
      <td>-0.488854</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>35.000000</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0.392945</td>
      <td>0.420730</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>35.000000</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.392945</td>
      <td>-0.486337</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>886</th>
      <td>887</td>
      <td>0</td>
      <td>27.000000</td>
      <td>0</td>
      <td>0</td>
      <td>13.0000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>-0.194330</td>
      <td>-0.386671</td>
    </tr>
    <tr>
      <th>887</th>
      <td>888</td>
      <td>1</td>
      <td>19.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>-0.781606</td>
      <td>-0.044381</td>
    </tr>
    <tr>
      <th>888</th>
      <td>889</td>
      <td>0</td>
      <td>16.185117</td>
      <td>1</td>
      <td>2</td>
      <td>23.4500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-0.988244</td>
      <td>-0.176263</td>
    </tr>
    <tr>
      <th>889</th>
      <td>890</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>-0.267740</td>
      <td>-0.044381</td>
    </tr>
    <tr>
      <th>890</th>
      <td>891</td>
      <td>0</td>
      <td>32.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.7500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.172717</td>
      <td>-0.492378</td>
    </tr>
  </tbody>
</table>
<p>891 rows × 18 columns</p>
</div>



<h1 id="5-逻辑回归建模"><a href="#5-逻辑回归建模" class="headerlink" title="5.逻辑回归建模"></a>5.逻辑回归建模</h1><p>经过了以上的数据预处理之后，就可以将所需的feature抽取出来，转化成numpy格式，使用logistic regression进行建模了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用正则去除所需的属性值</span></span><br><span class="line">train_df = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line">train_np = train_df.values</span><br><span class="line"></span><br><span class="line">y=train_np[:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">X=train_np[:,<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">clf = linear_model.LogisticRegression(C=<span class="number">1.0</span>,penalty=<span class="string">'l1'</span>,solver=<span class="string">"liblinear"</span>,tol=<span class="number">1e-6</span>)</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"></span><br><span class="line">clf</span><br></pre></td></tr></table></figure>




<pre><code>LogisticRegression(penalty=&apos;l1&apos;, solver=&apos;liblinear&apos;, tol=1e-06)</code></pre><p>之后就可以导入测试集，来测试训练出的模型了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_test = pd.read_csv(<span class="string">"../titanic/test.csv"</span>)</span><br><span class="line">data_test.loc[(data_test.Fare.isnull()),<span class="string">'Fare'</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">#对test集进行和train集一样的数据预处理</span></span><br><span class="line">tmp_df = data_test[[<span class="string">'Age'</span>,<span class="string">'Fare'</span>,<span class="string">'Parch'</span>,<span class="string">'SibSp'</span>,<span class="string">'Pclass'</span>]]</span><br><span class="line"><span class="comment">#拟合age</span></span><br><span class="line">null_age = tmp_df[tmp_df.Age.isnull()].values</span><br><span class="line">X = null_age[:,<span class="number">1</span>:]</span><br><span class="line">predictedAges = rfr.predict(X)</span><br><span class="line">data_test.loc[(data_test.Age.isnull()),<span class="string">'Age'</span>] = predictedAges</span><br><span class="line"></span><br><span class="line"><span class="comment">#因子化</span></span><br><span class="line">data_test = set_Cabin_type(data_test)</span><br><span class="line">dummies_Cabin = pd.get_dummies(data_test[<span class="string">'Cabin'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Embarked = pd.get_dummies(data_test[<span class="string">'Embarked'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Sex = pd.get_dummies(data_test[<span class="string">'Sex'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Pclass = pd.get_dummies(data_test[<span class="string">'Pclass'</span>],prefix=<span class="string">'Pclass'</span>)</span><br><span class="line"></span><br><span class="line">df_test = pd.concat([data_test,dummies_Cabin,dummies_Embarked,dummies_Pclass,dummies_Sex],axis=<span class="number">1</span>)</span><br><span class="line">df_test.drop([<span class="string">'Pclass'</span>,<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>,<span class="string">'Embarked'</span>,<span class="string">'Sex'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#标准化</span></span><br><span class="line">df_test[<span class="string">'Age_scaled'</span>] = scaler.fit_transform(df_test[<span class="string">'Age'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">df_test[<span class="string">'Fare_scaled'</span>] = scaler.fit_transform(df_test[<span class="string">'Fare'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">df_test</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
      <th>Cabin_No</th>
      <th>Cabin_Yes</th>
      <th>Cabin_C</th>
      <th>Cabin_Q</th>
      <th>Cabin_S</th>
      <th>Pclass_1</th>
      <th>Pclass_2</th>
      <th>Pclass_3</th>
      <th>Cabin_female</th>
      <th>Cabin_male</th>
      <th>Age_scaled</th>
      <th>Fare_scaled</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>892</td>
      <td>34.500000</td>
      <td>0</td>
      <td>0</td>
      <td>7.8292</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.307526</td>
      <td>-0.496637</td>
    </tr>
    <tr>
      <th>1</th>
      <td>893</td>
      <td>47.000000</td>
      <td>1</td>
      <td>0</td>
      <td>7.0000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1.256242</td>
      <td>-0.511497</td>
    </tr>
    <tr>
      <th>2</th>
      <td>894</td>
      <td>62.000000</td>
      <td>0</td>
      <td>0</td>
      <td>9.6875</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>2.394702</td>
      <td>-0.463335</td>
    </tr>
    <tr>
      <th>3</th>
      <td>895</td>
      <td>27.000000</td>
      <td>0</td>
      <td>0</td>
      <td>8.6625</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>-0.261704</td>
      <td>-0.481704</td>
    </tr>
    <tr>
      <th>4</th>
      <td>896</td>
      <td>22.000000</td>
      <td>1</td>
      <td>1</td>
      <td>12.2875</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-0.641190</td>
      <td>-0.416740</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>413</th>
      <td>1305</td>
      <td>30.705727</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.019551</td>
      <td>-0.492680</td>
    </tr>
    <tr>
      <th>414</th>
      <td>1306</td>
      <td>39.000000</td>
      <td>0</td>
      <td>0</td>
      <td>108.9000</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0.649064</td>
      <td>1.314641</td>
    </tr>
    <tr>
      <th>415</th>
      <td>1307</td>
      <td>38.500000</td>
      <td>0</td>
      <td>0</td>
      <td>7.2500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.611115</td>
      <td>-0.507017</td>
    </tr>
    <tr>
      <th>416</th>
      <td>1308</td>
      <td>30.705727</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.019551</td>
      <td>-0.492680</td>
    </tr>
    <tr>
      <th>417</th>
      <td>1309</td>
      <td>25.755877</td>
      <td>1</td>
      <td>1</td>
      <td>22.3583</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>-0.356130</td>
      <td>-0.236263</td>
    </tr>
  </tbody>
</table>
<p>418 rows × 17 columns</p>
</div>



<p>进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Embarked_.*|Sex_.*|Pclass_.*|Cabin_.*'</span>)</span><br><span class="line">predictions = clf.predict(test)</span><br><span class="line">result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>: data_test[<span class="string">'PassengerId'</span>].values,<span class="string">'Survived'</span>:predictions.astype(np.int32)&#125;)</span><br><span class="line">result.to_csv(<span class="string">"../titanic/logistic_regression_prediction.csv"</span>,index=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">"output suc"</span>)</span><br></pre></td></tr></table></figure>

<pre><code>output suc</code></pre><p>之后，就可以在kaggle界面sumbit，最终结果是0.76315</p>
<h1 id="6-逻辑回归模型的优化"><a href="#6-逻辑回归模型的优化" class="headerlink" title="6.逻辑回归模型的优化"></a>6.逻辑回归模型的优化</h1><h3 id="1-关联系数分析"><a href="#1-关联系数分析" class="headerlink" title="1.关联系数分析"></a>1.关联系数分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(&#123;<span class="string">"columns"</span>:list(train_df.columns)[<span class="number">1</span>:], <span class="string">"coef"</span>:list(clf.coef_.T)&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>columns</th>
      <th>coef</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>SibSp</td>
      <td>[-0.34423363130066786]</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Parch</td>
      <td>[-0.1049180394409882]</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Cabin_No</td>
      <td>[-0.20329593023712947]</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Cabin_Yes</td>
      <td>[0.6987933469628373]</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Embarked_C</td>
      <td>[0.0]</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Embarked_Q</td>
      <td>[0.0]</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Embarked_S</td>
      <td>[-0.4172616632645433]</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Pclass_1</td>
      <td>[0.34116702481573935]</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Pclass_2</td>
      <td>[0.0]</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Pclass_3</td>
      <td>[-1.1941332195046448]</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Sex_female</td>
      <td>[2.159866487359889]</td>
    </tr>
    <tr>
      <th>11</th>
      <td>Sex_male</td>
      <td>[-0.47412117296965695]</td>
    </tr>
    <tr>
      <th>12</th>
      <td>Age_scaled</td>
      <td>[-0.5237628634773356]</td>
    </tr>
    <tr>
      <th>13</th>
      <td>Fare_scaled</td>
      <td>[0.084436110718527]</td>
    </tr>
  </tbody>
</table>
</div>



<p>系数为正的特征，和最后结果是一个正相关，反之为负相关<br>可以分析出来:<br>Sex属性，如果是female会极大提高最后获救的概率，而male会很大程度拉低这个概率。</p>
<p>Pclass属性，1等舱乘客最后获救的概率会上升，而乘客等级为3会极大地拉低这个概率。</p>
<p>有Cabin值会很大程度拉升最后获救概率(这里似乎能看到了一点端倪，事实上从最上面的有无Cabin记录的Survived分布图上看出，即使有Cabin记录的乘<br>客也有一部分遇难了，估计这个属性上我们挖掘还不够)</p>
<p>Age是一个负相关，意味着在我们的模型里，年龄越小，越有获救的优先权(还得回原数据看看这个是否合理）<br>有一个登船港口S会很大程度拉低获救的概率，另外俩港口压根就没啥作用(这个实际上非常奇怪，因为我们从之前的统计图上并没有看到S港口的获救率非常低，所以也许可以考虑把登船港口这个feature去掉试试)。<br>船票Fare有小幅度的正相关(并不意味着这个feature作用不大，有可能是我们细化的程度还不够，举个例子，说不定我们得对它离散化，再分至各个乘客等级上？)</p>
<h1 id="7-交叉验证"><a href="#7-交叉验证" class="headerlink" title="7.交叉验证"></a>7.交叉验证</h1><p>这里的交叉验证就是将数据集切割成五份，进行五次验证。</p>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score, train_test_split</span><br><span class="line"></span><br><span class="line"> <span class="comment">#简单看看打分情况</span></span><br><span class="line">clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>,C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</span><br><span class="line">all_data = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line">X = all_data.values[:,<span class="number">1</span>:]</span><br><span class="line">y = all_data.values[:,<span class="number">0</span>]</span><br><span class="line"><span class="comment"># print(cross_validation.cross_val_score(clf, X, y, cv=5))</span></span><br><span class="line">print(cross_val_score(clf, X, y, cv=<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[0.81564246 0.80898876 0.78651685 0.78651685 0.81460674]</code></pre><p>之后再查看一下bad case的情况，试一试用人眼能不能观察出什么规律</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分割数据，按照 训练数据:cv数据 = 7:3的比例</span></span><br><span class="line"><span class="comment"># split_train, split_cv = cross_validation.train_test_split(df, test_size=0.3, random_state=0)</span></span><br><span class="line">split_train, split_cv = train_test_split(df, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">train_df = split_train.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line"><span class="comment"># 生成模型</span></span><br><span class="line">clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>,C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</span><br><span class="line">clf.fit(train_df.values[:,<span class="number">1</span>:], train_df.values[:,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对cross validation数据进行预测</span></span><br><span class="line"></span><br><span class="line">cv_df = split_cv.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line">predictions = clf.predict(cv_df.values[:,<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">origin_data_train = pd.read_csv(<span class="string">"../titanic/train.csv"</span>)</span><br><span class="line">bad_cases = origin_data_train.loc[origin_data_train[<span class="string">'PassengerId'</span>].isin(split_cv[predictions != cv_df.values[:,<span class="number">0</span>]][<span class="string">'PassengerId'</span>].values)]</span><br><span class="line">bad_cases.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>23</th>
      <td>24</td>
      <td>1</td>
      <td>1</td>
      <td>Sloper, Mr. William Thompson</td>
      <td>male</td>
      <td>28.00</td>
      <td>0</td>
      <td>0</td>
      <td>113788</td>
      <td>35.5000</td>
      <td>A6</td>
      <td>S</td>
    </tr>
    <tr>
      <th>25</th>
      <td>26</td>
      <td>1</td>
      <td>3</td>
      <td>Asplund, Mrs. Carl Oscar (Selma Augusta Emilia...</td>
      <td>female</td>
      <td>38.00</td>
      <td>1</td>
      <td>5</td>
      <td>347077</td>
      <td>31.3875</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>49</th>
      <td>50</td>
      <td>0</td>
      <td>3</td>
      <td>Arnold-Franchi, Mrs. Josef (Josefine Franchi)</td>
      <td>female</td>
      <td>18.00</td>
      <td>1</td>
      <td>0</td>
      <td>349237</td>
      <td>17.8000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>55</th>
      <td>56</td>
      <td>1</td>
      <td>1</td>
      <td>Woolner, Mr. Hugh</td>
      <td>male</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>19947</td>
      <td>35.5000</td>
      <td>C52</td>
      <td>S</td>
    </tr>
    <tr>
      <th>65</th>
      <td>66</td>
      <td>1</td>
      <td>3</td>
      <td>Moubarek, Master. Gerios</td>
      <td>male</td>
      <td>NaN</td>
      <td>1</td>
      <td>1</td>
      <td>2661</td>
      <td>15.2458</td>
      <td>NaN</td>
      <td>C</td>
    </tr>
    <tr>
      <th>78</th>
      <td>79</td>
      <td>1</td>
      <td>2</td>
      <td>Caldwell, Master. Alden Gates</td>
      <td>male</td>
      <td>0.83</td>
      <td>0</td>
      <td>2</td>
      <td>248738</td>
      <td>29.0000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>81</th>
      <td>82</td>
      <td>1</td>
      <td>3</td>
      <td>Sheerlinck, Mr. Jan Baptist</td>
      <td>male</td>
      <td>29.00</td>
      <td>0</td>
      <td>0</td>
      <td>345779</td>
      <td>9.5000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>118</th>
      <td>119</td>
      <td>0</td>
      <td>1</td>
      <td>Baxter, Mr. Quigg Edmond</td>
      <td>male</td>
      <td>24.00</td>
      <td>0</td>
      <td>1</td>
      <td>PC 17558</td>
      <td>247.5208</td>
      <td>B58 B60</td>
      <td>C</td>
    </tr>
    <tr>
      <th>139</th>
      <td>140</td>
      <td>0</td>
      <td>1</td>
      <td>Giglio, Mr. Victor</td>
      <td>male</td>
      <td>24.00</td>
      <td>0</td>
      <td>0</td>
      <td>PC 17593</td>
      <td>79.2000</td>
      <td>B86</td>
      <td>C</td>
    </tr>
    <tr>
      <th>165</th>
      <td>166</td>
      <td>1</td>
      <td>3</td>
      <td>Goldsmith, Master. Frank John William "Frankie"</td>
      <td>male</td>
      <td>9.00</td>
      <td>0</td>
      <td>2</td>
      <td>363291</td>
      <td>20.5250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
  </tbody>
</table>
</div>



<p>具体的优化思路有以下几点：<br>Age属性不使用现在的拟合方式，而是根据名称中的『Mr』『Mrs』『Miss』等的平均值进行填充。</p>
<p>Age不做成一个连续值属性，而是使用一个步长进行离散化，变成离散的类目feature。</p>
<p>Cabin再细化一些，对于有记录的Cabin属性，我们将其分为前面的字母部分(我猜是位置和船层之类的信息) 和 后面的数字部分(应该是房间号，有意思的事情是，如果你仔细看看原始数据，你会发现，这个值大的情况下，似乎获救的可能性高一些)。</p>
<p>Pclass和Sex俩太重要了，我们试着用它们去组出一个组合属性来试试，这也是另外一种程度的细化。</p>
<p>单加一个Child字段，Age&lt;=12的，设为1，其余为0(你去看看数据，确实小盆友优先程度很高啊)<br>如果名字里面有『Mrs』，而Parch&gt;1的，我们猜测她可能是一个母亲，应该获救的概率也会提高，因此可以多加一个Mother字段，此种情况下设为1，其余情况下设为0</p>
<p>登船港口可以考虑先去掉试试(Q和C本来就没权重，S有点诡异)</p>
<p>把堂兄弟/兄妹 和 Parch 还有自己 个数加在一起组一个Family_size字段(考虑到大家族可能对最后的结果有影响)<br>Name是一个我们一直没有触碰的属性，我们可以做一些简单的处理，比如说男性中带某些字眼的(‘Capt’, ‘Don’, ‘Major’, ‘Sir’)可以统一到一个Title，女性也一样。</p>
<h1 id="8-learning-curve"><a href="#8-learning-curve" class="headerlink" title="8.learning curve"></a>8.learning curve</h1><p>主要用来判断过拟合和欠拟合问题，其中过拟合的解决办法如下：</p>
<ol>
<li>做一下feature selection，挑出较好的feature的subset来做training</li>
<li>提供更多的数据，从而弥补原始数据的bias问题，学习到的model也会更准确 而对于欠拟合而言，我们通常需要更多的feature，更复杂的模型来提高准确度。<br>种状态分别如下两张图所示：过拟合(overfitting/high variace)，欠拟合(underfitting/high bias)：
这里可以使用sklearn的learning curve来解决问题</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># from sklearn.learning_curve import learning_curve  修改以fix learning_curve DeprecationWarning</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用sklearn的learning_curve得到training_score和cv_score，使用matplotlib画出learning curve</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curve</span><span class="params">(estimator, title, X, y, ylim=None, cv=None, n_jobs=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                        train_sizes=np.linspace<span class="params">(<span class="number">.05</span>, <span class="number">1.</span>, <span class="number">20</span>)</span>, verbose=<span class="number">0</span>, plot=True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    画出data在某模型上的learning curve.</span></span><br><span class="line"><span class="string">    参数解释</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    estimator : 你用的分类器。</span></span><br><span class="line"><span class="string">    title : 表格的标题。</span></span><br><span class="line"><span class="string">    X : 输入的feature，numpy类型</span></span><br><span class="line"><span class="string">    y : 输入的target vector</span></span><br><span class="line"><span class="string">    ylim : tuple格式的(ymin, ymax), 设定图像中纵坐标的最低点和最高点</span></span><br><span class="line"><span class="string">    cv : 做cross-validation的时候，数据分成的份数，其中一份作为cv集，其余n-1份作为training(默认为3份)</span></span><br><span class="line"><span class="string">    n_jobs : 并行的的任务数(默认1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    train_sizes, train_scores, test_scores = learning_curve(</span><br><span class="line">        estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes, verbose=verbose)</span><br><span class="line">    </span><br><span class="line">    train_scores_mean = np.mean(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">    train_scores_std = np.std(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">    test_scores_mean = np.mean(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    test_scores_std = np.std(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> plot:</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.title(title)</span><br><span class="line">        <span class="keyword">if</span> ylim <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            plt.ylim(*ylim)</span><br><span class="line">        plt.xlabel(<span class="string">u"训练样本数"</span>)</span><br><span class="line">        plt.ylabel(<span class="string">u"得分"</span>)</span><br><span class="line">        plt.gca().invert_yaxis()</span><br><span class="line">        plt.grid()</span><br><span class="line">    </span><br><span class="line">        plt.fill_between(train_sizes, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std, </span><br><span class="line">                         alpha=<span class="number">0.1</span>, color=<span class="string">"b"</span>)</span><br><span class="line">        plt.fill_between(train_sizes, test_scores_mean - test_scores_std, test_scores_mean + test_scores_std, </span><br><span class="line">                         alpha=<span class="number">0.1</span>, color=<span class="string">"r"</span>)</span><br><span class="line">        plt.plot(train_sizes, train_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"b"</span>, label=<span class="string">u"训练集上得分"</span>)</span><br><span class="line">        plt.plot(train_sizes, test_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"r"</span>, label=<span class="string">u"交叉验证集上得分"</span>)</span><br><span class="line">    </span><br><span class="line">        plt.legend(loc=<span class="string">"best"</span>)</span><br><span class="line">        </span><br><span class="line">        plt.draw()</span><br><span class="line">        plt.gca().invert_yaxis()</span><br><span class="line">        plt.show()</span><br><span class="line">    </span><br><span class="line">    midpoint = ((train_scores_mean[<span class="number">-1</span>] + train_scores_std[<span class="number">-1</span>]) + (test_scores_mean[<span class="number">-1</span>] - test_scores_std[<span class="number">-1</span>])) / <span class="number">2</span></span><br><span class="line">    diff = (train_scores_mean[<span class="number">-1</span>] + train_scores_std[<span class="number">-1</span>]) - (test_scores_mean[<span class="number">-1</span>] - test_scores_std[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> midpoint, diff</span><br><span class="line"></span><br><span class="line">plot_learning_curve(clf, <span class="string">u"学习曲线"</span>, X, y)</span><br></pre></td></tr></table></figure>


<img src="/titanic_logistic_prac/output_44_0.png" class="" title="png">





<pre><code>(0.8041289762608517, 0.028972978630723678)</code></pre><h1 id="9-模型融合"><a href="#9-模型融合" class="headerlink" title="9.模型融合"></a>9.模型融合</h1><p>这里可以每次取训练集的一个subset，做训练，这样，我们虽然用的是同一个机器学习算法，但是得到的模型却是不一样的；同时，因为我们没有任何一份子数据集是全的，因此即使出现过拟合，也是在子训练集上出现过拟合，而不是全体数据上，这样做一个融合，可能对最后的结果有一定的帮助。对，这就是常用的Bagging。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line"></span><br><span class="line">train_df = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass.*|Mother|Child|Family|Title'</span>)</span><br><span class="line">train_np = train_df.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># y即Survival结果</span></span><br><span class="line">y = train_np[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># X即特征属性值</span></span><br><span class="line">X = train_np[:, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># fit到BaggingRegressor之中</span></span><br><span class="line">clf = linear_model.LogisticRegression(C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>,solver=<span class="string">"liblinear"</span>)</span><br><span class="line">bagging_clf = BaggingRegressor(clf, n_estimators=<span class="number">20</span>, max_samples=<span class="number">0.8</span>, max_features=<span class="number">1.0</span>, bootstrap=<span class="literal">True</span>, bootstrap_features=<span class="literal">False</span>, n_jobs=<span class="number">-1</span>)</span><br><span class="line">bagging_clf.fit(X, y)</span><br><span class="line"></span><br><span class="line">test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass.*|Mother|Child|Family|Title'</span>)</span><br><span class="line">predictions = bagging_clf.predict(test)</span><br><span class="line">result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>:data_test[<span class="string">'PassengerId'</span>].values, <span class="string">'Survived'</span>:predictions.astype(np.int32)&#125;)</span><br><span class="line">result.to_csv(<span class="string">"../titanic/logistic_regression_bagging_predictions.csv"</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">"../titanic/logistic_regression_bagging_predictions.csv"</span>).head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>892</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>893</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>894</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>895</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>896</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>897</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>898</td>
      <td>1</td>
    </tr>
    <tr>
      <th>7</th>
      <td>899</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>900</td>
      <td>1</td>
    </tr>
    <tr>
      <th>9</th>
      <td>901</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



<p>可以发现结果总体上是优于之前的预测的，只是不太稳定</p>
<img src="/titanic_logistic_prac/1596729100632.png" class="" width="1596729100632">

<p>最后，仍然是别人总结的思路流程图</p>
<img src="/titanic_logistic_prac/100f3a39031e73bd0a8.jpg" class="" title="用机器学习解决问题的过程">]]></content>
      <categories>
        <category>kaggle</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode53：最大子序和</title>
    <url>/leetcode53%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<img src="/leetcode53%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/1596702245700.png" class="" width="1596702245700">

<a id="more"></a>

<p><a href="https://blog.csdn.net/zwzsdy/article/details/80029796" target="_blank" rel="noopener">https://blog.csdn.net/zwzsdy/article/details/80029796</a></p>
<h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h1><blockquote>
<p>设sum[i]为<strong>以第i个元素结尾且和最大</strong>的连续子数组。假设对于元素i，所有以它前面的元素结尾的子数组的长度都已经求得，那么以第i个元素结尾且和最大的连续子数组实际上，要么是以第i-1个元素结尾且和最大的连续子数组加上这个元素，要么是只包含第i个元素，即sum[i]<br>= max(sum[i-1] + a[i], a[i])。可以通过<strong>判断sum[i-1] + a[i]是否大于a[i]来做选择</strong>，而这实际上等价于判断<strong>sum[i-1]是否大于0</strong>。由于每次运算只需要前一次的结果，因此并不需要像普通的动态规划那样保留之前所有的计算结果，只需要保留上一次的即可，因此算法的时间和空间复杂度都很小</p>
</blockquote>
<img src="/leetcode53%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/1596701867094.png" class="" width="1596701867094">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre_sum=<span class="number">0</span>;<span class="comment">//sum用0初始化</span></span><br><span class="line">        <span class="keyword">int</span> maxRes = INT_MIN;<span class="comment">//求最大用最小值初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur:nums)&#123;</span><br><span class="line">            pre_sum = <span class="built_in">max</span>(pre_sum+cur,cur);</span><br><span class="line">            maxRes = <span class="built_in">max</span>(maxRes,pre_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-扫描法"><a href="#2-扫描法" class="headerlink" title="2.扫描法"></a>2.扫描法</h1><p>和动态规划差不多，如果之前的数字之和小于零，就抛弃前面的和；如果不小于零，就继续累加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>, maxSum=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; cur: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum&lt;<span class="number">0</span>) curSum=cur;</span><br><span class="line">            <span class="keyword">else</span> curSum+=cur;</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum,curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-分治法"><a href="#3-分治法" class="headerlink" title="3.分治法"></a>3.分治法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode7：整数翻转</title>
    <url>/leetcode7%EF%BC%9A%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/</url>
    <content><![CDATA[<img src="/leetcode7%EF%BC%9A%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/1596699696045.png" class="" width="1596699696045">

<a id="more"></a>

<img src="/leetcode7%EF%BC%9A%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/1596699677897.png" class="" width="1596699677897">

<h1 id="1-手算"><a href="#1-手算" class="headerlink" title="1.手算"></a>1.手算</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev&gt;INT_MAX/<span class="number">10</span>||(rev==INT_MAX/<span class="number">10</span>&amp;&amp;pop&gt;<span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev&lt;INT_MIN/<span class="number">10</span>||(rev==INT_MIN/<span class="number">10</span>&amp;&amp;pop&lt;<span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev*<span class="number">10</span>+pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-代码算"><a href="#2-代码算" class="headerlink" title="2.代码算"></a>2.代码算</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev &gt; Integer.MAX_VALUE / <span class="number">10</span> || (rev == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>))&#123;</span><br><span class="line">                rev = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rev &lt; Integer.MIN_VALUE / <span class="number">10</span> || (rev == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; x &lt; Integer.MIN_VALUE % <span class="number">10</span>))&#123;</span><br><span class="line">                rev = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode3：无重复字符的最长子串</title>
    <url>/leetcode3%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<img src="/leetcode3%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/1596712159058.png" class="" width="1596712159058">

<a id="more"></a>

<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/</a></p>
<p>滑动窗口问题要注意空集。</p>
<ul>
<li><code>int[26]</code> for Letters ‘a’ - ‘z’ or ‘A’ - ‘Z’</li>
<li><code>int[128]</code> for ASCII</li>
<li><code>int[256]</code> for Extended ASCII</li>
</ul>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><blockquote>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(2n) = O(n). In the worst case each character will be visited twice by i and j.</li>
<li>Space complexity : O(min(m, n)). Same as the previous approach. We need O(k)space for the sliding window, where k is the size of the <code>Set</code>. The size of the Set is upper bounded by the size of the string n and the size of the charset/alphabet m.</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = INT_MIN,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dic[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dic,<span class="number">0</span>,<span class="keyword">sizeof</span>(dic));</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//如果下一个字符的不存在集合里</span></span><br><span class="line">            <span class="keyword">if</span>(!dic[s[r]])&#123;</span><br><span class="line">                dic[s[r++]]++;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen,r-l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果下一个字符存在集合里</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dic[s[l++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hashmap[<span class="number">130</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">//双指针滑动窗口</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//当前判断是否重复的串为s[i..j]</span></span><br><span class="line">        hashmap[s[j]]++;</span><br><span class="line">        <span class="keyword">while</span>(hashmap[s[j]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            hashmap[s[i++]]--;  <span class="comment">//i指针右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;<span class="built_in">max</span>)</span><br><span class="line">            <span class="built_in">max</span> = j-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2、优化的滑动窗口"><a href="#2、优化的滑动窗口" class="headerlink" title="2、优化的滑动窗口"></a>2、优化的滑动窗口</h1><blockquote>
<p>The reason is that if $s[j]$ have a duplicate in the range $[i, j)$ with index $j’$, we don’t need to increase ii little by little. We can skip all the elements in the range $[i,j′] $and let $i$ to be $j’ + 1$directly.</p>
</blockquote>
<blockquote>
<ul>
<li>Time complexity : O(n). Index j will iterate n times.</li>
<li>Space complexity (HashMap) : O(min(m, n)). Same as the previous approach.</li>
<li>Space complexity (Table): O(m). mm is the size of the charset.</li>
</ul>
</blockquote>
<blockquote>
<p>the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">     <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">         <span class="keyword">if</span> (map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">             j = Math.max(j,map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         map.put(s.charAt(i),i);</span><br><span class="line">         max = Math.max(max,i-j+<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> max;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-另一种滑动窗口"><a href="#3-另一种滑动窗口" class="headerlink" title="3.另一种滑动窗口"></a>3.另一种滑动窗口</h1><blockquote>
<p>我们不妨以示例一中的字符串 \texttt{abcabcbb}abcabcbb 为例，找出 从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<p>$以 \texttt{(a)bcabcbb} 开始的最长字符串为 \texttt{(abc)abcbb}；\<br>以 \texttt{a(b)cabcbb} 开始的最长字符串为 \texttt{a(bca)bcbb}；\<br>以 \texttt{ab(c)abcbb} 开始的最长字符串为 \texttt{ab(cab)cbb}；\<br>以 \texttt{abc(a)bcbb} 开始的最长字符串为 \texttt{abc(abc)bb}；\<br>以 \texttt{abca(b)cbb} 开始的最长字符串为 \texttt{abca(bc)bb}；\<br>以 \texttt{abcab(c)bb} 开始的最长字符串为 \texttt{abcab(cb)b}；\<br>以 \texttt{abcabc(b)b} 开始的最长字符串为 \texttt{abcabc(b)b}；\<br>以 \texttt{abcabcb(b)} 开始的最长字符串为 \texttt{abcabcb(b)}。$<br>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 $r_k$ 。那么当我们选择第 k+1个字符作为起始位置时，首先从 k+1 到 $r_k$<br>的字符显然是不重复的，并且由于少了原本的第 k个字符，我们可以尝试继续增大 r_kr，直到右侧出现了重复字符为止。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = INT_MIN,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dic[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dic,<span class="number">0</span>,<span class="keyword">sizeof</span>(dic));</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;s.<span class="built_in">size</span>();l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l) dic[s[l<span class="number">-1</span>]]--;</span><br><span class="line">            <span class="keyword">while</span>(dic[s[r]]==<span class="number">0</span>&amp;&amp;r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen,r-l+<span class="number">1</span>);</span><br><span class="line">                dic[s[r]]++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode76：最小覆盖子串</title>
    <url>/leetcode76%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<img src="/leetcode76%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/1596540796924.png" class="" width="1596540796924">

<p>要注意的是，这里的字符串可以有重复字符，比如”AABC”，A要计数两次。</p>
<a id="more"></a>

<h1 id="1-使用哈希表（慢）"><a href="#1-使用哈希表（慢）" class="headerlink" title="1.使用哈希表（慢）"></a>1.使用哈希表（慢）</h1><ol>
<li><p>要考虑两者之一为空串时，返回空串</p>
</li>
<li><p>同时当S=”a”,T=”aa”时，返回空串</p>
</li>
<li><p>当S=“ab”，T=“a”时候，要考虑到T为单个字符</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt,t_cnt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p: t_cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[p.first]&lt;p.second) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>||t==<span class="string">""</span>||s.<span class="built_in">size</span>()&lt;t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//左指针，右指针，最小子字符的长度，结果的左指针</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>,min_len=INT_MAX,res_left=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计T的每个字符个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c:t)&#123;</span><br><span class="line">            t_cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左指针移动</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.<span class="built_in">size</span>()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(t_cnt.<span class="built_in">find</span>(s[right])!=t_cnt.<span class="built_in">end</span>())&#123;</span><br><span class="line">                cnt[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//右指针移动</span></span><br><span class="line">            <span class="keyword">while</span>(check() &amp;&amp; left&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min_len&gt;right-left)&#123;</span><br><span class="line">                    res_left = left;</span><br><span class="line">                    min_len=right-left;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(t_cnt.<span class="built_in">find</span>(s[left])!=t_cnt.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    cnt[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右指针没移动，则返回空串，比如S=“ab”，T=“a”</span></span><br><span class="line">        <span class="keyword">if</span>(min_len==INT_MAX) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substr(res_left,min_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-使用数组"><a href="#2-使用数组" class="headerlink" title="2.使用数组"></a>2.使用数组</h1><p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(|S| + |T|)O(∣S∣+∣T∣) where |S| and |T| represent the lengths of strings SS and TT. In the worst case we might end up visiting every element of string SS twice, once by left pointer and once by right pointer. |T|∣T∣ represents the length of string TT.</li>
<li>Space Complexity: O(|S| + |T|)O(∣S∣+∣T∣). |S|∣S∣ when the window size is equal to the entire string SS. |T|∣T∣ when TT has all unique characters.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dic[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dic,<span class="number">0</span>,<span class="keyword">sizeof</span>(dic));</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,minLen=INT_MAX,minL=<span class="number">0</span>,remaining=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:t)&#123;</span><br><span class="line">            dic[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//右指针向右</span></span><br><span class="line">            <span class="comment">//非t的字符，此时变为负数</span></span><br><span class="line">            <span class="keyword">if</span>(--dic[s[r++]]&gt;=<span class="number">0</span>) remaining--;</span><br><span class="line">            <span class="keyword">while</span>(remaining==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-l&lt;minLen) &#123;</span><br><span class="line">                    minL=l;</span><br><span class="line">                    minLen=r-l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左指针向右</span></span><br><span class="line">                <span class="comment">//属于t的字符，此时才会大于0</span></span><br><span class="line">                <span class="keyword">if</span>(++dic[s[l++]]&gt;<span class="number">0</span>) remaining++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX?s.substr(minL,minLen):<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日练习：字符串相加</title>
    <url>/leetcode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<img src="/leetcode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/1596398440298.png" class="" width="1596398440298">

<a id="more"></a>

<h1 id="1-自己"><a href="#1-自己" class="headerlink" title="1.自己"></a>1.自己</h1><p>%取个位，/取十位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        short carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先翻转字符串</span></span><br><span class="line">        reverse(num1.<span class="built_in">begin</span>(),num1.<span class="built_in">end</span>());</span><br><span class="line">        reverse(num2.<span class="built_in">begin</span>(),num2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//补0</span></span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="built_in">size</span>()&gt;num2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=num2.<span class="built_in">size</span>();i&lt;num1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                num2+=<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="built_in">size</span>()&lt;num2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=num1.<span class="built_in">size</span>();i&lt;num2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                num1+=<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpRes = num1[i]-<span class="string">'0'</span>+num2[i]-<span class="string">'0'</span>+carry;</span><br><span class="line">            res+=<span class="keyword">char</span>(tmpRes%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">            carry= (tmpRes&lt;<span class="number">10</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一位进位判定</span></span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            res+=<span class="string">"1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转结果</span></span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-改进"><a href="#2-改进" class="headerlink" title="2.改进"></a>2.改进</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpRes=<span class="number">0</span>, i = num1.<span class="built_in">size</span>()<span class="number">-1</span>, j = num2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmpRes&gt;<span class="number">0</span>||i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//这个位置上有数字，就加上去</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) tmpRes+=num1[i--]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) tmpRes+=num2[j--]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//最终结果加上临时结果的个位</span></span><br><span class="line">            res+=to_string(tmpRes%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//保留临时结果十分位（进位）</span></span><br><span class="line">            tmpRes/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100：有效括号</title>
    <url>/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>本题虽然简单，但有很多有趣的、轻便的解法，值得一看。</p>
<img src="/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596389567066.png" class="" width="1596389567066">

<a id="more"></a>

<h1 id="1-自己的解法（分类）"><a href="#1-自己的解法（分类）" class="headerlink" title="1.自己的解法（分类）"></a>1.自己的解法（分类）</h1><p>下面三种解法时间复杂度和空间复杂度都是$O(n)$</p>
<p>要注意的是空字符串也是正确的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">char</span> next=<span class="string">' '</span>;</span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            next = s[i];</span><br><span class="line">            <span class="comment">//左括号，则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(next==<span class="string">'('</span>||next==<span class="string">'&#123;'</span>||next==<span class="string">'['</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push(s[i]);</span><br><span class="line">            <span class="comment">//右括号，分情况</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//是如果栈不为空</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">char</span> pop_char = <span class="built_in">stack</span>.top();</span><br><span class="line">                    <span class="built_in">stack</span>.pop();</span><br><span class="line">                    <span class="comment">//栈顶元素不相配，返回false，否则继续循环</span></span><br><span class="line">                    <span class="keyword">switch</span> (next)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">if</span>(pop_char!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span>(pop_char!=<span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'&#125;'</span>: <span class="keyword">if</span>(pop_char!=<span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//栈为空，返回false</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束后，栈为空，返回false；否则为true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-优化代码"><a href="#2-优化代码" class="headerlink" title="2.优化代码"></a>2.优化代码</h1><p>其中empty的判断要在前，否则遇到’]’这种的，会报错，因为此时栈为空，调用top会出错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">char</span> c=<span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])&#123;</span><br><span class="line">                <span class="comment">//左括号</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>: <span class="built_in">stack</span>.push(<span class="string">')'</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'['</span>: <span class="built_in">stack</span>.push(<span class="string">']'</span>);<span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#123;'</span>: <span class="built_in">stack</span>.push(<span class="string">'&#125;'</span>);<span class="keyword">break</span>; </span><br><span class="line">                <span class="comment">//右括号</span></span><br><span class="line">                <span class="keyword">default</span>:&#123;</span><br><span class="line">                    <span class="comment">//empty在前，否则会报错</span></span><br><span class="line">                    <span class="comment">//如果栈为空 或者 栈顶元素不匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">stack</span>.empty()||<span class="built_in">stack</span>.top()!=s[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">stack</span>.pop(); </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596394828010.png" class="" width="1596394828010">

<h1 id="3-优化栈"><a href="#3-优化栈" class="headerlink" title="3.优化栈"></a>3.优化栈</h1><p>使用字典来优化代码。注意这里用右括号来当键，左括号来当值。这是因为在整个过程用我们会用右括号来匹配左括号，而字典里查找键的值比较方便，所以这样子写比较方便一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(s.size()==0) return true;</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; brackets&#123;</span><br><span class="line">            &#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;,</span><br><span class="line">            &#123;<span class="string">']'</span>,<span class="string">'['</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//遇到右括号</span></span><br><span class="line">            <span class="keyword">if</span>(brackets.<span class="built_in">find</span>(s[i])!=brackets.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//stack为空 或者 括号间不匹配</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.empty()||brackets[s[i]]!=<span class="built_in">stack</span>.top())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到左括号</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596394721849.png" class="" width="1596394721849">

<h1 id="4-从内向外去成对括号（python）"><a href="#4-从内向外去成对括号（python）" class="headerlink" title="4.从内向外去成对括号（python）"></a>4.从内向外去成对括号（python）</h1><img src="/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596389740129.png" class="" width="1596389740129">

<p>可以发现成对的括号之间构成了一种递归关系：如果括号全部成对，那么无论是小对括号还是大对括号都是成对的。虽然解法效率低，但很简洁。</p>
<blockquote>
<p>从整体表达式中一次删除一个较小的表达式，因为这是一个有效的表达式，我们最后剩留下一个空字符串。</p>
</blockquote>
<img src="/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596395364511.png" class="" width="1596395364511">

<img src="/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596395373951.png" class="" width="1596395373951">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'&#123;&#125;'</span> <span class="keyword">in</span> s o<span class="string">r'[]'</span> <span class="keyword">in</span> s o<span class="string">r'()'</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">'&#123;&#125;'</span>,<span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'[]'</span>,<span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>,<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">''</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode：二叉树展开为链表</title>
    <url>/leetcode%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<img src="/leetcode%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/1596378927495.png" class="" width="1596378927495">

<a id="more"></a>

<h1 id="1-前序遍历（不是原地）"><a href="#1-前序遍历（不是原地）" class="headerlink" title="1.前序遍历（不是原地）"></a>1.前序遍历（不是原地）</h1><p>要注意的是，存在<strong>空节点</strong>或者<strong>只有一个节点</strong>的可能。不考虑的话会报错：out-of-range。</p>
<p>另外题目要求原地（in-place）展开，也就是要求<strong>空间复杂度</strong>为$O(1)$，而这种方法不符合规定。</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="comment">//前序遍历，展开成vector</span></span><br><span class="line">        pre_trav(root, <span class="built_in">list</span>);</span><br><span class="line">        <span class="comment">//考虑空树和单节点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将vector内的指正串会树状图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            TreeNode* prev=<span class="built_in">list</span>.at(i), *cur=<span class="built_in">list</span>.at(i+<span class="number">1</span>);</span><br><span class="line">            prev-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right=cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_trav</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="built_in">list</span>.push_back(root);</span><br><span class="line">            pre_trav(root-&gt;left,<span class="built_in">list</span>);</span><br><span class="line">            pre_trav(root-&gt;right,<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     void flatten(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">//         vector&lt;TreeNode*&gt; l;</span></span><br><span class="line"><span class="comment">//         preorderTraversal(root, l);</span></span><br><span class="line"><span class="comment">//         int n = l.size();</span></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//             TreeNode *prev = l.at(i - 1), *curr = l.at(i);</span></span><br><span class="line"><span class="comment">//             prev-&gt;left = nullptr;</span></span><br><span class="line"><span class="comment">//             prev-&gt;right = curr;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     void preorderTraversal(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) &#123;</span></span><br><span class="line"><span class="comment">//         if (root != NULL) &#123;</span></span><br><span class="line"><span class="comment">//             l.push_back(root);</span></span><br><span class="line"><span class="comment">//             preorderTraversal(root-&gt;left, l);</span></span><br><span class="line"><span class="comment">//             preorderTraversal(root-&gt;right, l);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-先序遍历-前驱节点"><a href="#2-先序遍历-前驱节点" class="headerlink" title="2.先序遍历(前驱节点)"></a>2.先序遍历(前驱节点)</h1><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/</a></p>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 1 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"><span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">//将 2 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">作者：windliang</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>具体过程如下：</p>
<ol>
<li>找出左子树的最右边的节点</li>
<li>将右子树移到左子树最右边节点的右边</li>
<li>将左子树移动到当前节点的右边</li>
<li>当前节点的左边清空</li>
<li>当前指针指向右边的节点，知道当前指针为空</li>
</ol>
<p><strong>时间复杂度</strong>：$O(log(n))$，n为所有节点的个数</p>
<p><strong>空间复杂度</strong>：$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* curNode = root;</span><br><span class="line">        <span class="comment">//当前节点不为空才继续</span></span><br><span class="line">        <span class="keyword">while</span>(curNode)&#123;</span><br><span class="line">            <span class="comment">//当前节点有左子树，才继续</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//左子树中最右边的节点</span></span><br><span class="line">                TreeNode* leftRightMost = curNode-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(leftRightMost-&gt;right)&#123;</span><br><span class="line">                    leftRightMost = leftRightMost-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                leftRightMost-&gt;right = curNode-&gt;right;</span><br><span class="line">                curNode-&gt;right = curNode-&gt;left;</span><br><span class="line">                curNode-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-前序遍历-展开"><a href="#3-前序遍历-展开" class="headerlink" title="3.前序遍历+展开"></a>3.前序遍历+展开</h1><p>这里其实就是前序遍历的时候，将每个遍历到的节点使用一个栈保存下来</p>
<blockquote>
<p>修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则依次将右子节点和左子节点压入栈内（注意入栈顺序）。</p>
<p>展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(root);</span><br><span class="line">        TreeNode* curr=<span class="literal">nullptr</span>, *prev=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            curr = <span class="built_in">stack</span>.top(); <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(prev!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">                prev-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *left = curr-&gt;left, *right=curr-&gt;right;</span><br><span class="line">            <span class="comment">//右先入栈，后出栈</span></span><br><span class="line">            <span class="keyword">if</span>(right!=<span class="literal">nullptr</span>) <span class="built_in">stack</span>.push(right);</span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="literal">nullptr</span>) <span class="built_in">stack</span>.push(left);</span><br><span class="line">            prev=curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>linked list</tag>
        <tag>leetcode</tag>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100：两两交换链表中的节点</title>
    <url>/leetcode-top100%EF%BC%9A%E4%B8%A4%E8%BE%86%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<img src="/leetcode-top100%EF%BC%9A%E4%B8%A4%E8%BE%86%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1596369150852.png" class="" width="1596369150852">

<a id="more"></a>

<h1 id="1-递归解法"><a href="#1-递归解法" class="headerlink" title="1.递归解法"></a>1.递归解法</h1><p><a href="https://lyl0724.github.io/2020/01/25/1/" target="_blank" rel="noopener">https://lyl0724.github.io/2020/01/25/1/</a></p>
<p>递归需要三个个条件：</p>
<ol>
<li><p>终止条件：这里就是递归到的节点只剩一个或者是null节点。</p>
</li>
<li><p>返回值：返回值是已经交换后的第一个节点</p>
</li>
<li><p>单次过程：这里单次过程相当于在三个节点中交换前两个：first, second, 后面的节点作为一个整体</p>
<img src="/leetcode-top100%EF%BC%9A%E4%B8%A4%E8%BE%86%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1596369477110.png" class="" width="1596369477110">

</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!(head-&gt;next))&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* headNext = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(headNext-&gt;next);</span><br><span class="line">        headNext-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> headNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-迭代求解"><a href="#2-迭代求解" class="headerlink" title="2.迭代求解"></a>2.迭代求解</h1><p>过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	first</span><br><span class="line">	↓</span><br><span class="line">-1-&gt;1-&gt;2-&gt;3-&gt;4</span><br><span class="line">↑	   ↑</span><br><span class="line">prev  sec</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* preNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* beforeHeadNode = preNode;</span><br><span class="line">        preNode-&gt;next=head;</span><br><span class="line">        <span class="comment">//还剩两个节点可供交换时</span></span><br><span class="line">        <span class="keyword">while</span>(preNode-&gt;next&amp;&amp;preNode-&gt;next-&gt;next)&#123;</span><br><span class="line">            ListNode* first = preNode-&gt;next;</span><br><span class="line">            ListNode* sec = preNode-&gt;next-&gt;next;</span><br><span class="line">            first-&gt;next = sec-&gt;next;</span><br><span class="line">            sec-&gt;next = first;</span><br><span class="line">            preNode-&gt;next = sec;</span><br><span class="line">            <span class="comment">//更新前节点</span></span><br><span class="line">            preNode = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beforeHeadNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题：最小区间</title>
    <url>/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<img src="/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596366784500.png" class="" width="1596366784500">

<a id="more"></a>

<h1 id="1-最小堆"><a href="#1-最小堆" class="headerlink" title="1.最小堆"></a>1.最小堆</h1><p>解说可以参考：<a href="https://leetcode.com/articles/smallest-range/" target="_blank" rel="noopener">https://leetcode.com/articles/smallest-range/</a></p>
<p>代码可以参考：<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/solution/zui-xiao-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/solution/zui-xiao-qu-jian-by-leetcode-solution/</a></p>
<p>本题的本质就是在每个链表中选择一个数，使得这一组数的最大值减去最小值最小。也就是一个合并链表考虑的问题，将链表”展开“。</p>
<p><strong>红框表示目前堆的最小值在哪</strong></p>
<img src="/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596367211146.png" class="" width="1596367211146">

<ol>
<li><p>next全为0</p>
</li>
<li><p>将每个链表的第一个元素放入最小堆中，堆顶元素也就是堆中的最小值。同时将堆中的最大值保存。</p>
</li>
<li><p>要想缩小区间有两种方法：增加最小值，减小最大值。</p>
</li>
<li><p>这里的最大值无法减小，所以就选择增加最小值。</p>
</li>
<li><p>然后将next值更新，将最小值的下一个元素放入堆中，重新堆排序。然后找更新后的堆的最小值，如此反复。</p>
<img src="/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596367489520.png" class="" width="1596367489520">
</li>
<li><p>直到某一个链表的元素全部被遍历完，那么目前的最小值无法进行扩大，流程结束。</p>
<img src="/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596367566755.png" class="" width="1596367566755">

</li>
</ol>
<p><strong>时间复杂度</strong>：$O(nk \log k)$，n为所有列表的平均长度，k为列表的个数，遍历每个列表的每一个格需要$O(nk)$的时间。同时每次的遍历要处理有k个节点的最小堆，需要$O(logk)$</p>
<p><strong>空间复杂度</strong>：$O(k)$，空间复杂度取决于堆的节点个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最终结果的边界，边界在不断缩小，所以初始化范围要大</span></span><br><span class="line">        <span class="keyword">int</span> rangeLeft = <span class="number">0</span>, rangeRight = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//next记录每一行的指向的列，定位到数值</span></span><br><span class="line">        <span class="comment">//此处初始化为0</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[a][next[a]] &gt; nums[b][next[b]];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//que记录当前最小值在哪一行</span></span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; que(cmp);</span><br><span class="line">        <span class="comment">//每次循环变化的边界，max在不断变大，所以max初始化要小</span></span><br><span class="line">        <span class="keyword">int</span> min_val = <span class="number">0</span>,max_val = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">            que.emplace(i);</span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val,nums[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//取出最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> row = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            min_val = nums[row][next[row]];</span><br><span class="line">            <span class="keyword">if</span>(max_val-min_val&lt;rangeRight-rangeLeft)&#123;</span><br><span class="line">                rangeLeft=min_val;</span><br><span class="line">                rangeRight=max_val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有一个链表遍历完了，就终止循环</span></span><br><span class="line">            <span class="keyword">if</span>(next[row]==nums[row].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next[row]++;</span><br><span class="line">            que.emplace(row);</span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val,nums[row][next[row]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;rangeLeft, rangeRight&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些操作：</p>
<p>emplace：<a href="https://blog.csdn.net/weixin_43892298/article/details/105733034" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43892298/article/details/105733034</a></p>
<p>[&amp;] lambda表达式：<a href="https://www.jianshu.com/p/6482fbd3abdf" target="_blank" rel="noopener">https://www.jianshu.com/p/6482fbd3abdf</a></p>
<h1 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h1>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>slide window</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/leetcode21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[

<a id="more"></a>

<p>本题使用递归处理，具体流程可以参考：</p>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/</a></p>
<p><strong>时间复杂度：</strong>$O(m+n)$</p>
<blockquote>
<p>给出一个递归算法，其时间复杂度 ${\mathcal{O}(T)}$ 通常是递归调用的数量（记作 ${R}$） 和计算的时间复杂度的乘积（表示为 ${\mathcal{O}(s)})$的乘积：${\mathcal{O}(T) = R * \mathcal{O}(s)}O(T)=R∗O(s)$</p>
</blockquote>
<p>设n，m为两个链表的长度。本题的递归调用数量，最坏情况下为$O(m+n)$，每次计算需要耗费$O(1)$的时间。所以空间复杂度为$O(m+n)$</p>
<p><strong>空间复杂度：</strong>$O(m+n)$</p>
<p>在递归结束前，已经调用了$O(m+n)$次该函数，所以也调用了那么多的栈帧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100：两数相加</title>
    <url>/leetcode-top100%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<img src="/leetcode-top100%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/1596276070612.png" class="" width="1596276070612">

<a id="more"></a>

<p>这一题就是简单的初等运算。</p>
<p>不过要注意的是c++的内存分配机制。</p>
<p><a href="https://www.cnblogs.com/1zhk/articles/5028743.html" target="_blank" rel="noopener">https://www.cnblogs.com/1zhk/articles/5028743.html</a></p>
<p>在c++中，分为栈空间、堆空间。一般的局部变量都分配在栈空间之中，比如<code>ListNode newNode(0);</code>，所以如果写成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">ListNode* l1_cur = l1;</span><br><span class="line"><span class="keyword">while</span>(a--)&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">newNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    l1_cur-&gt;next = &amp;newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么分配出来的结构体的空间会在循环结束的时候被释放，就会导致under-flow的error。</p>
<p>对于堆空间，唯一的分配方法就是使用new，这样直到程序人员自己释放空间之前，分配的空间都会被保存下来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//补全空链，以0填充</span></span><br><span class="line">        ListNode* l1_cur = l1;</span><br><span class="line">        ListNode* l2_cur = l2;</span><br><span class="line">        <span class="keyword">while</span>(l1_cur-&gt;next!=<span class="literal">NULL</span>||l2_cur-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = l1_cur-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(l1_cur-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="function">ListNode <span class="title">newNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">                l1_cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(l2_cur-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="function">ListNode <span class="title">newNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">                l2_cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                l2_cur = l2_cur-&gt;next;</span><br><span class="line">                l1_cur = l1_cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置</span></span><br><span class="line">        l1_cur=l1;</span><br><span class="line">        l2_cur=l2;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">result</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* header = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* pointer = header;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1_cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp = l1_cur-&gt;val + l2_cur-&gt;val + carry;</span><br><span class="line">            <span class="comment">//进位</span></span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                tmp=tmp%<span class="number">10</span>;</span><br><span class="line">                carry=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不进位</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                carry=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">ListNode <span class="title">tmpNode</span><span class="params">(tmp)</span></span>;</span><br><span class="line">            pointer-&gt;next = <span class="keyword">new</span> ListNode(tmp);</span><br><span class="line">            pointer = pointer-&gt;next;</span><br><span class="line">            l1_cur=l1_cur-&gt;next;</span><br><span class="line">            l2_cur=l2_cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一位进位</span></span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            <span class="function">ListNode <span class="title">node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            pointer-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> header-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100:两数之和</title>
    <url>/leetcode-top100-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<img src="/leetcode-top100-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/1596191333136.png" class="" width="1596191333136">

<a id="more"></a>

<h1 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1.暴力解法"></a>1.暴力解法</h1><p>时间复杂度：$O（n²）$</p>
<p>空间复杂度：$O（1）$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    res.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-两遍哈希表"><a href="#2-两遍哈希表" class="headerlink" title="2.两遍哈希表"></a>2.两遍哈希表</h1><h3 id="1-前置知识："><a href="#1-前置知识：" class="headerlink" title="1.前置知识："></a>1.前置知识：</h3><p><a href="https://blog.csdn.net/qq_21997625/article/details/84672775" target="_blank" rel="noopener">https://blog.csdn.net/qq_21997625/article/details/84672775</a></p>
<p>unordered_map</p>
<p>c++里有map和unordered_map，其中map是个红黑树，里面所有的元素都是有序的；而unordered_map里面所有的元素都是无序的，实现的是一个哈希表。</p>
<h3 id="2-思路和代码："><a href="#2-思路和代码：" class="headerlink" title="2.思路和代码："></a>2.思路和代码：</h3><p>哈希表的查找时近似于$O(1)$的，除非查找时出现了冲突，那么就会变成$O(n)$。</p>
<p>这里的思路是进行两次迭代。第一次中，将数值和索引存入哈希表；第二遍迭代中，检查每个元素对应的数值<code>target-nums[i]</code>是否存在于哈希表中。需要注意的就是两个数字不能重复，即可。</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="comment">//存入hash表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = i; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(target-nums[i])&amp;&amp;<span class="built_in">map</span>[target-nums[i]]!=i)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(<span class="built_in">map</span>[target-nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-排序-双指针"><a href="#3-排序-双指针" class="headerlink" title="3.排序+双指针"></a>3.排序+双指针</h1><p>首先将数组排序，需要消耗$O(n\log(n))$的时间，然后使用双指针，遍历排序后的数组找到需要的值。</p>
<p>时间：$O(n\log(n))$</p>
<p>空间：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; </span><br><span class="line">        tmp = nums;</span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//双指针遍历</span></span><br><span class="line">        <span class="keyword">int</span> n=tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]+tmp[j]&lt;target) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]+tmp[j]&gt;target) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了相等的值</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//遍历原数组寻找参数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                <span class="comment">//找到了第一个值</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;n&amp;&amp;nums[k]==tmp[i])&#123;</span><br><span class="line">                    res.push_back(k);</span><br><span class="line">                    i=n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到了第二个值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;n&amp;&amp;nums[k]==tmp[j])&#123;</span><br><span class="line">                    res.push_back(k);</span><br><span class="line">                    j=n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//全找到</span></span><br><span class="line">                <span class="keyword">if</span>(i==n&amp;&amp;j==n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>一个报错：</strong></p>
<p><a href="https://blog.csdn.net/zhangpeterx/article/details/88775434" target="_blank" rel="noopener">https://blog.csdn.net/zhangpeterx/article/details/88775434</a></p>
<p>在写的过程中遇到一个报错：Heap-buffer-overflow。意思是访问了非法地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array[-1];&#x2F;&#x2F;非法地址</span><br></pre></td></tr></table></figure>

<p>原因时因为条件判断的过程中，顺序出了错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;         if(i&lt;j)&#123;</span><br><span class="line">&#x2F;&#x2F;             &#x2F;&#x2F;遍历原数组寻找参数</span><br><span class="line">&#x2F;&#x2F;             for(int k&#x3D;0;k&lt;n;k++)&#123;</span><br><span class="line">&#x2F;&#x2F;                 &#x2F;&#x2F;找到了第一个值</span><br><span class="line">				   &#x2F;&#x2F;顺序出错</span><br><span class="line">&#x2F;&#x2F;                 if(nums[k]&#x3D;&#x3D;tmp[i]&amp;&amp;i&lt;n)&#123;</span><br><span class="line">&#x2F;&#x2F;                     res.push_back(k);</span><br><span class="line">&#x2F;&#x2F;                     i&#x3D;n;</span><br><span class="line">&#x2F;&#x2F;                 &#125;</span><br><span class="line">&#x2F;&#x2F;                 &#x2F;&#x2F;找到了第二个值</span><br><span class="line">&#x2F;&#x2F;                 else if(nums[k]&#x3D;&#x3D;tmp[j]&amp;&amp;j&lt;n)&#123;</span><br><span class="line">&#x2F;&#x2F;                     res.push_back(k);</span><br><span class="line">&#x2F;&#x2F;                     j&#x3D;n;</span><br><span class="line">&#x2F;&#x2F;                 &#125;</span><br><span class="line">&#x2F;&#x2F;                 &#x2F;&#x2F;全找到</span><br><span class="line">&#x2F;&#x2F;                 if(i&#x3D;&#x3D;n&amp;&amp;j&#x3D;&#x3D;n)&#123;</span><br><span class="line">&#x2F;&#x2F;                     return res;</span><br><span class="line">&#x2F;&#x2F;                 &#125;</span><br><span class="line">&#x2F;&#x2F;             &#125;</span><br><span class="line">&#x2F;&#x2F;         &#125;</span><br></pre></td></tr></table></figure>

<p>这里的k的值可以变成n先判断第一个条件<code>nums[k]==tmp[i]</code>，之后才判断第二个条件<code>i&lt;n</code>。</p>
<p>所以调换一下顺序，就可以在判断<code>i&lt;n</code>的时候直接返回false了。</p>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>hash</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日题目：魔术索引</title>
    <url>/leetcode%E6%AF%8F%E6%97%A5%E9%A2%98%E7%9B%AE%EF%BC%9A%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>leetcode每日练习：二叉树的最大深度</title>
    <url>/LeetCode-104%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>给定二叉树，求其最大深度</p>


<a id="more"></a>

<h1 id="解法一：递归（DFS）"><a href="#解法一：递归（DFS）" class="headerlink" title="解法一：递归（DFS）"></a>解法一：递归（DFS）</h1>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//solution 1</span></span><br><span class="line">        <span class="comment">//recursion</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">NULL</span> ?<span class="number">0</span>:<span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="解法二：BFS搜索"><a href="#解法二：BFS搜索" class="headerlink" title="解法二：BFS搜索"></a>解法二：BFS搜索</h1><h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h3><p><strong>queue库:</strong></p>
<p><a href="http://c.biancheng.net/view/479.html" target="_blank" rel="noopener">http://c.biancheng.net/view/479.html</a></p>


<p><strong>BFS和DFS：</strong></p>
<p><a href="http://c.biancheng.net/view/479.html" target="_blank" rel="noopener">http://c.biancheng.net/view/479.html</a></p>
<p>DFS主要靠回溯法</p>
<p>BFS则是在每一层都把所有可能全部记录了下来</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//solution 2</span></span><br><span class="line">        <span class="comment">//bp</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="comment">//遍历每一层节点</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                    que.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=NU</span><br><span class="line">                    que.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>修改juypter工作目录</title>
    <url>/%E4%BF%AE%E6%94%B9juypter%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>juypter notebook默认工作环境是在c盘，这里就解决这个问题</p>
<a id="more"></a>

<p>1.打开anocoda的console，然后在里面输入jupyter notebook –generate-config，就可以在<code>C:\Users\hp\.jupyter</code>下生成jupyter_notebook_config.py文件</p>
<p>2.打开该文件，然后在里面搜索<code>c.NotebookApp.notebook_dir</code>，将注释去掉，改为<code>c.NotebookApp.notebook_dir = &#39;你想要默认打开的文件夹&#39;</code></p>
<p>3.最后，在juypter notebook的快捷方式的属性界面，属性-&gt;目标，去掉最后的 %USERPROFILE%</p>
<p>完成以上步骤之后，即可修改juypter notebook的工作界面</p>
]]></content>
      <categories>
        <category>juypter</category>
      </categories>
      <tags>
        <tag>juypter</tag>
      </tags>
  </entry>
  <entry>
    <title>unity_following_light</title>
    <url>/unity-following-light/</url>
    <content><![CDATA[<p>简单的unity操作</p>
<a id="more"></a>

<hr>
<p>添加一个材质球，选择diffuse，然后将这个材质球赋给背景。在没有光源的条件下，背景就变黑了。</p>
<img src="/unity-following-light/1595866821021.png" class="" width="1595866821021">

<p>如果想调整背景的明暗程度，在window-&gt;rendering-&gt;light setting中，更改ambient color（环境光）</p>
<img src="/unity-following-light/1595866911162.png" class="" width="1595866911162">

<p>然后在人物下新建一个子文件的点光源，即可实现跟随</p>
<img src="/unity-following-light/1595867006419.png" class="" width="1595867006419">

<p>但是光源在这个时候是不显示的，这是因为此时光源Z坐标为0，将其设置为-1，即可让光源到离摄像机更近的平面上，也就可以看见光源了。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>lights</tag>
      </tags>
  </entry>
  <entry>
    <title>deep-learning-tutorial</title>
    <url>/deep-learning-tutorial/</url>
    <content><![CDATA[<p>总结一下deep learning的学习路线</p>
<a id="more"></a>

<h1 id="一、kaggle-learning"><a href="#一、kaggle-learning" class="headerlink" title="一、kaggle learning"></a>一、kaggle learning</h1><h3 id="1-titanic："><a href="#1-titanic：" class="headerlink" title="1.titanic："></a>1.titanic：</h3><p><a href="https://www.kaggle.com/alexisbcook/titanic-tutorial" target="_blank" rel="noopener">https://www.kaggle.com/alexisbcook/titanic-tutorial</a></p>
<h3 id="2-intro-to-machine-learning："><a href="#2-intro-to-machine-learning：" class="headerlink" title="2.intro to machine learning："></a>2.intro to machine learning：</h3><p><a href="https://www.kaggle.com/learn/intro-to-machine-learning" target="_blank" rel="noopener">https://www.kaggle.com/learn/intro-to-machine-learning</a></p>
<ol>
<li><p>talk about lack of data：<a href="https://www.kaggle.com/learn-forum/60581" target="_blank" rel="noopener">https://www.kaggle.com/learn-forum/60581</a></p>
<p>when the data was not new, you should consider the reason that cause this and determine whether it will affect the prediction results.</p>
</li>
</ol>
<h3 id="3-intermideate-machine-learning"><a href="#3-intermideate-machine-learning" class="headerlink" title="3.intermideate machine learning"></a>3.intermideate machine learning</h3><p><a href="https://www.kaggle.com/learn/intermediate-machine-learning" target="_blank" rel="noopener">https://www.kaggle.com/learn/intermediate-machine-learning</a></p>
<h3 id="4-deep-learning"><a href="#4-deep-learning" class="headerlink" title="4.deep learning"></a>4.deep learning</h3><p><a href="https://www.kaggle.com/Learn/Deep-Learning" target="_blank" rel="noopener">https://www.kaggle.com/Learn/Deep-Learning</a></p>
<h1 id="二、categories"><a href="#二、categories" class="headerlink" title="二、categories"></a>二、categories</h1><h3 id="1-BP"><a href="#1-BP" class="headerlink" title="1. BP"></a>1. BP</h3><p><a href="https://blog.csdn.net/weixin_39441762/article/details/80446692?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39441762/article/details/80446692?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="2-RBF神经网络-径向基"><a href="#2-RBF神经网络-径向基" class="headerlink" title="2.RBF神经网络(径向基)"></a>2.RBF神经网络(径向基)</h3><p><a href="https://blog.csdn.net/Y_hero/article/details/88985447" target="_blank" rel="noopener">https://blog.csdn.net/Y_hero/article/details/88985447</a></p>
<h3 id="3-CNN"><a href="#3-CNN" class="headerlink" title="3.CNN"></a>3.CNN</h3><ol>
<li>LeNet-5</li>
</ol>
<p><a href="https://blog.csdn.net/weixin_42398658/article/details/84392845" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42398658/article/details/84392845</a></p>
<img src="/deep-learning-tutorial/20181123193922202.png" class="" title="img">

<h3 id="4-激励函数"><a href="#4-激励函数" class="headerlink" title="4.激励函数"></a>4.激励函数</h3><p>将线性关系转化为非线性关系，往往是对数据进行升维</p>
<p><a href="https://blog.csdn.net/tyhj_sf/article/details/79932893" target="_blank" rel="noopener">https://blog.csdn.net/tyhj_sf/article/details/79932893</a></p>
<h3 id="5-logistic-regression"><a href="#5-logistic-regression" class="headerlink" title="5. logistic regression"></a>5. logistic regression</h3><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49123419" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49123419</a></p>
<p>解决的问题：二分类问题</p>
<p>高纬度解决方案：进行mapFeature操作，将变量升纬</p>
<h3 id="6-random-forest-tree"><a href="#6-random-forest-tree" class="headerlink" title="6. random forest tree"></a>6. random forest tree</h3><p><a href="https://blog.csdn.net/edogawachia/article/details/79357844" target="_blank" rel="noopener">https://blog.csdn.net/edogawachia/article/details/79357844</a></p>
<h1 id="三、example"><a href="#三、example" class="headerlink" title="三、example"></a>三、example</h1><h3 id="1-titanic"><a href="#1-titanic" class="headerlink" title="1. titanic"></a>1. titanic</h3><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49797143</a> (<strong>recommend</strong>)</p>
<h3 id="2-naive-NPL"><a href="#2-naive-NPL" class="headerlink" title="2.naive NPL"></a>2.naive NPL</h3><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/50545650" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/50545650</a></p>
]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorchStarter</title>
    <url>/pytorchStarter/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pytorch+anoconda+pycharm安装</title>
    <url>/pytorchSet/</url>
    <content><![CDATA[<p>pytorch+anoconda+pycharm安装</p>
<a id="more"></a>

<h1 id="anoconda安装"><a href="#anoconda安装" class="headerlink" title="anoconda安装"></a>anoconda安装</h1><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2.命令"></a>2.命令</h3><ol>
<li><p>创建虚拟空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n nlp python&#x3D;3.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove -n nlp --all</span><br></pre></td></tr></table></figure>
</li>
<li><p>将镜像源恢复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda activate nlp</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看安装列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看已有虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda-env list</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="2-Cuda"><a href="#2-Cuda" class="headerlink" title="2.Cuda"></a>2.Cuda</h1><p><a href="https://blog.csdn.net/weixin_44455154/article/details/105322330?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44455154/article/details/105322330?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase</a></p>
<p>pytorch的cuda支持版本一定要和已有cuda版本对应</p>
<h3 id="1-查看显卡支持的cuda最高版本"><a href="#1-查看显卡支持的cuda最高版本" class="headerlink" title="1. 查看显卡支持的cuda最高版本"></a>1. 查看显卡支持的cuda最高版本</h3><p><a href="https://blog.csdn.net/qq_39499621/article/details/92801092" target="_blank" rel="noopener">https://blog.csdn.net/qq_39499621/article/details/92801092</a></p>
<img src="/pytorchSet/20190508103705372.png" class="" title="img">

<h3 id="2-安装cuda"><a href="#2-安装cuda" class="headerlink" title="2.安装cuda"></a>2.安装cuda</h3><ol>
<li><p>cuda安装地址：<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit-archive</a></p>
</li>
<li><p>cuda安装选项</p>
<p>其中要保证本地已安装的driver components的版本高于cuda安装包中的版本</p>
<img src="/pytorchSet/20170823095519479.png" class="" title="cuda 2">
</li>
<li><p>安装对应版本的cudnn</p>
<p><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></p>
<p>下载之后将文件解压并且复制到cuda的对应目录下</p>
</li>
<li><p>设置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机上点右键，打开属性-&gt;高级系统设置-&gt;环境变量，可以看到系统中多了CUDA_PATH和CUDA_PATH_V8_0两个环境变量，接下来，还要在系统中添加以下几个环境变量：</span><br><span class="line">CUDA_SDK_PATH &#x3D; C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0(这是默认安装位置的路径，经自定义路径后，我的路径为D:\NVIDIA\CUDA Samples)</span><br><span class="line">CUDA_LIB_PATH &#x3D; %CUDA_PATH%\lib\x64</span><br><span class="line">CUDA_BIN_PATH &#x3D; %CUDA_PATH%\bin</span><br><span class="line">CUDA_SDK_BIN_PATH &#x3D; %CUDA_SDK_PATH%\bin\win64</span><br><span class="line">CUDA_SDK_LIB_PATH &#x3D; %CUDA_SDK_PATH%\common\lib\x64</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在系统变量 PATH 的末尾添加：</span><br><span class="line">%CUDA_LIB_PATH%;%CUDA_BIN_PATH%;%CUDA_SDK_LIB_PATH%;%CUDA_SDK_BIN_PATH%;</span><br><span class="line">再添加如下4条（默认安装路径）：</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\lib\x64；</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\bin；</span><br><span class="line">C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0\common\lib\x64；</span><br><span class="line">C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0\bin\win64；</span><br></pre></td></tr></table></figure>
</li>
<li><p>检验安装</p>
<ol>
<li><pre><code>nvcc -V
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   2. 用CUDA内置的deviceQuery.exe 和 bandwithTest.exe：</span><br><span class="line">      首先win+R启动cmd，cd到安装目录下的 &#96;...\extras\demo_suite&#96;,然后分别执行&#96;bandwidthTest.exe&#96;和&#96;deviceQuery.exe&#96;</span><br><span class="line"></span><br><span class="line"># 3.安装pytorch</span><br><span class="line"></span><br><span class="line">清华镜像：&lt;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;pytorch&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">之后要使用&#96;&#96; conda install --offline&#96;&#96;命令进行安装</span><br><span class="line"></span><br><span class="line">pytorch的cuda对应版本要一直，cudnn版本高于pytorch的对应cudnn版本即可</span><br><span class="line"></span><br><span class="line">之后要安装一些必备包</span><br></pre></td></tr></table></figure>
conda install numpy mkl cffi pillow
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
conda install nb_conda
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">检验：</span><br></pre></td></tr></table></figure>
import torch
import torchvision</code></pre></li>
</ol>
</li>
</ol>
<h1 id="4-pycharm"><a href="#4-pycharm" class="headerlink" title="4. pycharm"></a>4. pycharm</h1><p>2019pro下载安装：<a href="https://www.52pojie.cn/thread-1111202-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1111202-1-1.html</a></p>
<p>setting-&gt;project-&gt;interpreter中选择pytorch虚拟目录下的python.exe，即可完成配置</p>
<h1 id="5-cuda的卸载"><a href="#5-cuda的卸载" class="headerlink" title="5.cuda的卸载"></a>5.cuda的卸载</h1><p><a href="https://www.zhihu.com/question/52174028" target="_blank" rel="noopener">https://www.zhihu.com/question/52174028</a></p>
<p>除了红框的都卸载</p>
<img src="/pytorchSet/1593926686128.png" class="" width="1593926686128">

]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pytorch</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>BigIntegerRealize</title>
    <url>/BigIntegerRealize/</url>
    <content><![CDATA[<p>要求实现大整数的加减乘除，开方，幂运算，实现ui界面，文本输入输出</p>
<a id="more"></a>

<p>首先，类内存储<strong>字符串</strong>和<strong>负数标记位</strong></p>
<p>然后申明一个reverse函数用于翻转字符串</p>
<p>然后要声明一个compare函数用于比较大整数的大小</p>
<p>最后要声明一个leftclear函数，用于清除字符串左边多余的0</p>
<h1 id="1-加法"><a href="#1-加法" class="headerlink" title="1. 加法"></a>1. 加法</h1><p>补0，注意进位，其他的从右向左相加即可（可翻转字符串后再运算）</p>
<h1 id="2-减法"><a href="#2-减法" class="headerlink" title="2. 减法"></a>2. 减法</h1><p>先比较大小，根据大小不同分别运算</p>
<p>然后补0，同样注意进位</p>
<h1 id="3-乘法"><a href="#3-乘法" class="headerlink" title="3. 乘法"></a>3. 乘法</h1><p>每次相乘在后面添加响应数目的0，然后相加的到结果</p>
<h1 id="4-除法"><a href="#4-除法" class="headerlink" title="4. 除法"></a>4. 除法</h1><h1 id="5-幂运算"><a href="#5-幂运算" class="headerlink" title="5. 幂运算"></a>5. 幂运算</h1><p>这里不好使用快速幂运算，就直接乘就好了</p>
<p>快速幂：</p>
<h1 id="6-开方"><a href="#6-开方" class="headerlink" title="6. 开方"></a>6. 开方</h1><p>使用二分法进行开放</p>
<ol>
<li><p>一般数值的二分法</p>
</li>
<li><p>大整数二分法</p>
</li>
</ol>
<h1 id="7-界面"><a href="#7-界面" class="headerlink" title="7.界面"></a>7.界面</h1><p>使用的qt做的</p>
<h1 id="1-读取文本文件"><a href="#1-读取文本文件" class="headerlink" title="1.读取文本文件"></a>1.读取文本文件</h1><pre><code>//定义文件对话框类
QFileDialog *fileDialog = new QFileDialog(this);
//定义文件对话框标题
fileDialog-&gt;setWindowTitle(QStringLiteral(&quot;选中文件&quot;));
//设置默认文件路径
fileDialog-&gt;setDirectory(&quot;.&quot;);
//设置文件过滤器
fileDialog-&gt;setNameFilter(tr(&quot;File(*.*)&quot;));
//设置可以选择多个文件,默认为只能选择一个文件QFileDialog::ExistingFiles
fileDialog-&gt;setFileMode(QFileDialog::ExistingFiles);
//设置视图模式
fileDialog-&gt;setViewMode(QFileDialog::Detail);
//打印所有选择的文件的路径
QStringList fileNames;
if (fileDialog-&gt;exec()) {
    fileNames = fileDialog-&gt;selectedFiles();
}</code></pre>]]></content>
      <categories>
        <category>school</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Ntop</title>
    <url>/Ntop/</url>
    <content><![CDATA[<p>从10000个人中，选择10个分数最高的人，并列出排名</p>
<a id="more"></a>

<h1 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h1><p>topN问题，基本都是使用堆排序来解决</p>
<p>升序问题使用大顶堆，降序问题使用小顶堆</p>
<p>解决流程为</p>
<h1 id="2-堆排序详解："><a href="#2-堆排序详解：" class="headerlink" title="2.堆排序详解："></a>2.堆排序详解：</h1><p> <a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<h1 id="3-解题流程"><a href="#3-解题流程" class="headerlink" title="3.解题流程"></a>3.解题流程</h1><p>所以这道题就使用小顶堆</p>
<p>c++的库里有heap和priority_queue两个队的库可以用来解决这个问题</p>
<ol>
<li>构建无序数组</li>
<li>将无序数组转化成小顶堆</li>
<li>比较输入数字和小顶堆顶部数字的大小<ol>
<li>如果小，就压入堆，并重新排序</li>
<li>如果大，就抛弃</li>
</ol>
</li>
</ol>
<h3 id="1-compare函数"><a href="#1-compare函数" class="headerlink" title="1.compare函数"></a>1.compare函数</h3><p>本题要绑定姓名和数字值，所以构建一个简单的结构体来存储姓名和数字</p>
<p>但这样的话需要声明一个compare函数用来比较这个结构体的大小</p>
<h3 id="2-文本读取"><a href="#2-文本读取" class="headerlink" title="2. 文本读取"></a>2. 文本读取</h3><p><a href="https://blog.csdn.net/limingandritchie/article/details/94559319" target="_blank" rel="noopener">https://blog.csdn.net/limingandritchie/article/details/94559319</a></p>
<h3 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3.迭代器"></a>3.迭代器</h3><p>注意单向迭代器不能<code>--</code>，所以要使用反向迭代器</p>
<ol>
<li><p>正向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator j = v.<span class="built_in">begin</span>(); j != v.<span class="built_in">end</span>(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h1><h3 id="1-heap"><a href="#1-heap" class="headerlink" title="1.heap"></a>1.heap</h3><h3 id="2-priority-queue"><a href="#2-priority-queue" class="headerlink" title="2. priority_queue"></a>2. priority_queue</h3>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>vim_command</title>
    <url>/vim-command/</url>
    <content><![CDATA[<img src="/vim-command/66696-5bc30a92ae0f73a6.webp" class="" title="img">

<a id="more"></a>

<h1 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h1><p><a href="https://www.cnblogs.com/wayneliu007/p/10322453.html" target="_blank" rel="noopener">https://www.cnblogs.com/wayneliu007/p/10322453.html</a></p>
<h3 id="1-全匹配"><a href="#1-全匹配" class="headerlink" title="1. 全匹配"></a>1. 全匹配</h3><p>从上往下： /string</p>
<p>从下往上： ?string</p>
<h3 id="2-模糊匹配（正则表达式）"><a href="#2-模糊匹配（正则表达式）" class="headerlink" title="2. 模糊匹配（正则表达式）"></a>2. 模糊匹配（正则表达式）</h3><p>. ：通配一个字符, 匹配string 时/str..g</p>
<p>* : 通配多个字符, 匹配string 时/str*g</p>
<h3 id="3-其他查找"><a href="#3-其他查找" class="headerlink" title="3.其他查找"></a>3.其他查找</h3><ol>
<li>shift + *: 光标停留在要查的单词上时,快速选中单词, 通过n查找下一个单词</li>
</ol>
<h3 id="4-取消高亮搜索"><a href="#4-取消高亮搜索" class="headerlink" title="4.取消高亮搜索"></a>4.取消高亮搜索</h3><p> :noh</p>
<h1 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2. 跳转"></a>2. 跳转</h1><ol>
<li>shift+g: 跳转到文件末尾</li>
<li>gg : 跳转到文件头</li>
<li>行数+gg: 跳转到指定行</li>
</ol>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo_hover_style_realize</title>
    <url>/hexo-hover-style-realize/</url>
    <content><![CDATA[<p>很喜欢hexo的文字悬浮样式，所以扒下来实现了一下</p>
<img src="/hexo-hover-style-realize/1590585162697.png" class="" width="1590585162697">

<a id="more"></a>

<p>首先，通过chrome分析，可以发现hexo的底部横线动画是在::before元素上的</p>
<p><strong>分析发现颜色控制是</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">black</span>;</span><br></pre></td></tr></table></figure>

<p><strong>位置控制是（左右）</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: 50%;</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">bottom</span>: 0;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br></pre></td></tr></table></figure>

<p>其中transform-origin控制的是偏移量，默认为50%，也就是从文字的中部出现</p>
<p>设置为0时，会从最左边出现</p>
<p>设置为100%时，会从最右边出现</p>
<p><strong>粗细控制是</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 2<span class="selector-tag">px</span>;</span><br><span class="line">content: '';</span><br></pre></td></tr></table></figure>

<p><strong>动画控制是</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(0);</span><br><span class="line"><span class="selector-tag">width</span>: 100%;</span><br><span class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">transition-delay</span>: 0<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 0<span class="selector-class">.2s</span>;</span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">ease-in-out</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后总体显示代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.test</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">  transform-origin: -1;</span><br><span class="line">  transform: scaleX(0);</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: black;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  transition-delay: 0s;</span><br><span class="line"><span class="css">  <span class="selector-tag">transition-duration</span>: 0<span class="selector-class">.2s</span>;</span></span><br><span class="line">  transition-timing-function: ease-in-out;</span><br><span class="line">  content: '';</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  height: 2px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.test</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">  transform: scaleX(1);</span><br><span class="line">  visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.test</span>&#123;</span></span><br><span class="line">  position: relative;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span>&#123;</span></span><br><span class="line">  margin: 0 400px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>This is a long Test<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>biliBara_el-scrollbar</title>
    <url>/biliBara-el-scrollbar/</url>
    <content><![CDATA[<p>element-ui中的el-scrollbar的使用总结</p>
<a id="more"></a>

<p>借鉴：<br><a href="https://segmentfault.com/a/1190000015068613" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015068613</a><br><a href="https://segmentfault.com/a/1190000019325694?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019325694?utm_source=tag-newest</a></p>
<p>#1.工作原理：<br>总的来说el-scrollbar就是一个wrapper，包裹住要使用scroll的区域。而包裹el-scrollbar的元素要设置成overflow: hidden</p>
<img src="/biliBara-el-scrollbar/17071720-c586a0d4ecb2a289.png" class="" title="图片.png">
<p>#2.使用<br>设置el-scrollbar的父元素（比如#app，html和body）以及el-scrollbar本身</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#app</span>, <span class="selector-tag">html</span>, <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-component__scroll</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要应用横轴的话还要加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.el-scrollbar &gt;&gt;&gt; .el-scrollbar__wrap</span><br><span class="line">  overflow-x: hidden</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>biliBara</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-build</title>
    <url>/hexo-build/</url>
    <content><![CDATA[<p>记录hexo的搭建过程以及插件的安装过程</p>
<a id="more"></a>

<p>总体的搭建过程看</p>
<p><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></p>
<p>以下是各种插件</p>
<h1 id="1-hexo命令"><a href="#1-hexo命令" class="headerlink" title="1. hexo命令"></a>1. hexo命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<h1 id="2-插入图片（和typora结合）"><a href="#2-插入图片（和typora结合）" class="headerlink" title="2. 插入图片（和typora结合）"></a>2. 插入图片（和typora结合）</h1><p><a href="https://www.cnblogs.com/cocowool/p/hexo-image-link.html" target="_blank" rel="noopener">https://www.cnblogs.com/cocowool/p/hexo-image-link.html</a></p>
<p>因为hexo的资源根目录在source处，typora默认的相对路径不能帮助hexo索引到图片，需要插件搞定</p>
<ol>
<li><p>hexo配置</p>
<p>在_config.yml中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用hexo插件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>设置typora</p>
<img src="/hexo-build/39469-20200316225054107-484234981.png" class="" title="img">

</li>
</ol>
<h1 id="3-live2d插件"><a href="#3-live2d插件" class="headerlink" title="3. live2d插件"></a>3. live2d插件</h1><p><a href="https://www.jianshu.com/p/4b61d8702cfa" target="_blank" rel="noopener">https://www.jianshu.com/p/4b61d8702cfa</a></p>
<ol>
<li><p>npm安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
</li>
<li><p>config配置（hexo不是主题文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  scriptFrom: <span class="built_in">local</span></span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: <span class="literal">false</span></span><br><span class="line">  debug: <span class="literal">false</span></span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-shizuku</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建文件夹</p>
<p>下载完之后，在Hexo根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中，然后编辑配置文件中的<code>model.use</code>项，将其修改为live2d_models文件夹中的模型文件夹名称。</p>
</li>
</ol>
<h1 id="4-next主题（评论系统）"><a href="#4-next主题（评论系统）" class="headerlink" title="4. next主题（评论系统）"></a>4. next主题（评论系统）</h1><p><a href="https://blog.csdn.net/jiunian_2761/article/details/97388997" target="_blank" rel="noopener">https://blog.csdn.net/jiunian_2761/article/details/97388997</a></p>
<h1 id="5-next主题（访问人数）"><a href="#5-next主题（访问人数）" class="headerlink" title="5. next主题（访问人数）"></a>5. next主题（访问人数）</h1><p><a href="https://blog.csdn.net/qq_43751489/article/details/102990376" target="_blank" rel="noopener">https://blog.csdn.net/qq_43751489/article/details/102990376</a></p>
<h1 id="6-next主题（字数统计，阅读时长）"><a href="#6-next主题（字数统计，阅读时长）" class="headerlink" title="6. next主题（字数统计，阅读时长）"></a>6. next主题（字数统计，阅读时长）</h1><p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93670772" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/93670772</a></p>
<h1 id="7-next主题（canvas-next）"><a href="#7-next主题（canvas-next）" class="headerlink" title="7.next主题（canvas_next）"></a>7.next主题（canvas_next）</h1><p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/95000707" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/95000707</a></p>
<ol>
<li><p>进入next文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载canvas_next</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件配置</p>
<p>在next的config文件中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#39;0,0,0&#39; # RGB values, use &#39;,&#39; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 99 # the number of lines</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
