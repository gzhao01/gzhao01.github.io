<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BigIntegerRealize</title>
    <url>/2020/06/22/BigIntegerRealize/</url>
    <content><![CDATA[<p>要求实现大整数的加减乘除，开方，幂运算，实现ui界面，文本输入输出</p>
<a id="more"></a>

<p>首先，类内存储<strong>字符串</strong>和<strong>负数标记位</strong></p>
<p>然后申明一个reverse函数用于翻转字符串</p>
<p>然后要声明一个compare函数用于比较大整数的大小</p>
<p>最后要声明一个leftclear函数，用于清除字符串左边多余的0</p>
<h1 id="1-加法"><a href="#1-加法" class="headerlink" title="1. 加法"></a>1. 加法</h1><p>补0，注意进位，其他的从右向左相加即可（可翻转字符串后再运算）</p>
<h1 id="2-减法"><a href="#2-减法" class="headerlink" title="2. 减法"></a>2. 减法</h1><p>先比较大小，根据大小不同分别运算</p>
<p>然后补0，同样注意进位</p>
<h1 id="3-乘法"><a href="#3-乘法" class="headerlink" title="3. 乘法"></a>3. 乘法</h1><p>每次相乘在后面添加响应数目的0，然后相加的到结果</p>
<h1 id="4-除法"><a href="#4-除法" class="headerlink" title="4. 除法"></a>4. 除法</h1><h1 id="5-幂运算"><a href="#5-幂运算" class="headerlink" title="5. 幂运算"></a>5. 幂运算</h1><p>这里不好使用快速幂运算，就直接乘就好了</p>
<p>快速幂：</p>
<h1 id="6-开方"><a href="#6-开方" class="headerlink" title="6. 开方"></a>6. 开方</h1><p>使用二分法进行开放</p>
<ol>
<li><p>一般数值的二分法</p>
</li>
<li><p>大整数二分法</p>
</li>
</ol>
<h1 id="7-界面"><a href="#7-界面" class="headerlink" title="7.界面"></a>7.界面</h1><p>使用的qt做的</p>
<h1 id="1-读取文本文件"><a href="#1-读取文本文件" class="headerlink" title="1.读取文本文件"></a>1.读取文本文件</h1><pre><code>//定义文件对话框类
QFileDialog *fileDialog = new QFileDialog(this);
//定义文件对话框标题
fileDialog-&gt;setWindowTitle(QStringLiteral(&quot;选中文件&quot;));
//设置默认文件路径
fileDialog-&gt;setDirectory(&quot;.&quot;);
//设置文件过滤器
fileDialog-&gt;setNameFilter(tr(&quot;File(*.*)&quot;));
//设置可以选择多个文件,默认为只能选择一个文件QFileDialog::ExistingFiles
fileDialog-&gt;setFileMode(QFileDialog::ExistingFiles);
//设置视图模式
fileDialog-&gt;setViewMode(QFileDialog::Detail);
//打印所有选择的文件的路径
QStringList fileNames;
if (fileDialog-&gt;exec()) {
    fileNames = fileDialog-&gt;selectedFiles();
}</code></pre>]]></content>
      <categories>
        <category>school</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>connect to host github.com port 22 Operation timed out</title>
    <url>/2020/08/07/FatalgitConnection/</url>
    <content><![CDATA[<p>hexo push到git时报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Operation timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这是因为防火墙的原因，把访问端口屏蔽了。</p>
<p><a href="https://stackoverflow.com/questions/7953806/github-ssh-via-public-wifi-port-22-blocked/8081292#8081292" target="_blank" rel="noopener">https://stackoverflow.com/questions/7953806/github-ssh-via-public-wifi-port-22-blocked/8081292#8081292</a></p>
<p>Try this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim ~&#x2F;.ssh&#x2F;config</span><br></pre></td></tr></table></figure>

<p>Add</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日练习：二叉树的最大深度</title>
    <url>/2020/07/30/LeetCode-104%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>给定二叉树，求其最大深度</p>


<a id="more"></a>

<h1 id="解法一：递归（DFS）"><a href="#解法一：递归（DFS）" class="headerlink" title="解法一：递归（DFS）"></a>解法一：递归（DFS）</h1>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//solution 1</span></span><br><span class="line">        <span class="comment">//recursion</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">NULL</span> ?<span class="number">0</span>:<span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="解法二：BFS搜索"><a href="#解法二：BFS搜索" class="headerlink" title="解法二：BFS搜索"></a>解法二：BFS搜索</h1><h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h3><p><strong>queue库:</strong></p>
<p><a href="http://c.biancheng.net/view/479.html" target="_blank" rel="noopener">http://c.biancheng.net/view/479.html</a></p>


<p><strong>BFS和DFS：</strong></p>
<p><a href="http://c.biancheng.net/view/479.html" target="_blank" rel="noopener">http://c.biancheng.net/view/479.html</a></p>
<p>DFS主要靠回溯法</p>
<p>BFS则是在每一层都把所有可能全部记录了下来</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//solution 2</span></span><br><span class="line">        <span class="comment">//bp</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="comment">//遍历每一层节点</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                TreeNode* cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                    que.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=NU</span><br><span class="line">                    que.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>Ntop</title>
    <url>/2020/06/22/Ntop/</url>
    <content><![CDATA[<p>从10000个人中，选择10个分数最高的人，并列出排名</p>
<a id="more"></a>

<h1 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1.问题分析"></a>1.问题分析</h1><p>topN问题，基本都是使用堆排序来解决</p>
<p>升序问题使用大顶堆，降序问题使用小顶堆</p>
<p>解决流程为</p>
<h1 id="2-堆排序详解："><a href="#2-堆排序详解：" class="headerlink" title="2.堆排序详解："></a>2.堆排序详解：</h1><p> <a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<h1 id="3-解题流程"><a href="#3-解题流程" class="headerlink" title="3.解题流程"></a>3.解题流程</h1><p>所以这道题就使用小顶堆</p>
<p>c++的库里有heap和priority_queue两个队的库可以用来解决这个问题</p>
<ol>
<li>构建无序数组</li>
<li>将无序数组转化成小顶堆</li>
<li>比较输入数字和小顶堆顶部数字的大小<ol>
<li>如果小，就压入堆，并重新排序</li>
<li>如果大，就抛弃</li>
</ol>
</li>
</ol>
<h3 id="1-compare函数"><a href="#1-compare函数" class="headerlink" title="1.compare函数"></a>1.compare函数</h3><p>本题要绑定姓名和数字值，所以构建一个简单的结构体来存储姓名和数字</p>
<p>但这样的话需要声明一个compare函数用来比较这个结构体的大小</p>
<h3 id="2-文本读取"><a href="#2-文本读取" class="headerlink" title="2. 文本读取"></a>2. 文本读取</h3><p><a href="https://blog.csdn.net/limingandritchie/article/details/94559319" target="_blank" rel="noopener">https://blog.csdn.net/limingandritchie/article/details/94559319</a></p>
<h3 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3.迭代器"></a>3.迭代器</h3><p>注意单向迭代器不能<code>--</code>，所以要使用反向迭代器</p>
<ol>
<li><p>正向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator j = v.<span class="built_in">begin</span>(); j != v.<span class="built_in">end</span>(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h1><h3 id="1-heap"><a href="#1-heap" class="headerlink" title="1.heap"></a>1.heap</h3><h3 id="2-priority-queue"><a href="#2-priority-queue" class="headerlink" title="2. priority_queue"></a>2. priority_queue</h3>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>biliBara_el-scrollbar</title>
    <url>/2020/05/25/biliBara-el-scrollbar/</url>
    <content><![CDATA[<p>element-ui中的el-scrollbar的使用总结</p>
<a id="more"></a>

<p>借鉴：<br><a href="https://segmentfault.com/a/1190000015068613" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015068613</a><br><a href="https://segmentfault.com/a/1190000019325694?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019325694?utm_source=tag-newest</a></p>
<p>#1.工作原理：<br>总的来说el-scrollbar就是一个wrapper，包裹住要使用scroll的区域。而包裹el-scrollbar的元素要设置成overflow: hidden</p>
<img src="/2020/05/25/biliBara-el-scrollbar/17071720-c586a0d4ecb2a289.png" class="" title="图片.png">
<p>#2.使用<br>设置el-scrollbar的父元素（比如#app，html和body）以及el-scrollbar本身</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#app</span>, <span class="selector-tag">html</span>, <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-component__scroll</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要应用横轴的话还要加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.el-scrollbar &gt;&gt;&gt; .el-scrollbar__wrap</span><br><span class="line">  overflow-x: hidden</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>biliBara</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>biliBara_liveStreaming</title>
    <url>/2020/05/27/biliBara-liveStreaming/</url>
    <content><![CDATA[<p>记录实现对b站直播间弹幕的爬取和统计过程</p>
<p>网页浏览如下：</p>
<p><a href="http://47.96.227.33:8084/" target="_blank" rel="noopener">http://47.96.227.33:8084/</a></p>
<a id="more"></a>

<h1 id="1-分析包"><a href="#1-分析包" class="headerlink" title="1. 分析包"></a>1. 分析包</h1><h3 id="1-使用chrome"><a href="#1-使用chrome" class="headerlink" title="1.使用chrome"></a>1.使用chrome</h3><p>使用chrome对包的preview一个一个查看后，发现一个gethistory的包符合要查找的对象</p>
<img src="/2020/05/27/biliBara-liveStreaming/1590517175355.png" class="" width="1590517175355">

<p>点开headers进行分析</p>
<p>发现是post请求，所以需要headers和request body</p>
<p>也就复制headers和form data部分</p>
<h3 id="2-使用fiddle-optional"><a href="#2-使用fiddle-optional" class="headerlink" title="2. 使用fiddle(optional)"></a>2. 使用fiddle(optional)</h3><p>因为fiddle默认无法获取https请求，所以要先对fiddle进行设置</p>
<p>打开tools-&gt;option，设置成这样</p>
<img src="/2020/05/27/biliBara-liveStreaming/1590517433674.png" class="" width="1590517433674">

<p>再打开actions，点击trust root certificate，关闭并保存</p>
<p>然后使用find查找gethistory，并拖入composer里</p>
<p>最后可以发现fiddle获得的信息和chrome相同</p>
<img src="/2020/05/27/biliBara-liveStreaming/1590517308512.png" class="" width="1590517308512">

<p>那么requests请求的代码可以表示为</p>
<p>（<strong>！！！注意：</strong> post请求要有headers和data）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line">url = <span class="string">"https://api.live.bilibili.com/xlive/web-room/v1/dM/gethistory"</span></span><br><span class="line"><span class="comment"># headers</span></span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="string">'accept'</span>: <span class="string">'application/json, text/plain, */*'</span>,</span><br><span class="line"><span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line"><span class="string">'accept-language'</span>: <span class="string">'en'</span>,</span><br><span class="line"><span class="string">'content-length'</span>: <span class="string">'107'</span>,</span><br><span class="line"><span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line"><span class="string">'cookie'</span>: <span class="string">r"_uuid=D16D0A02-421C-2253-9AD8-FADD9A976C1144289infoc; CURRENT_FNVAL=16; buvid3=A3D7CCA8-0D9B-43D8-B56A-614F12447787155833infoc; LIVE_BUVID=AUTO8315677851506285; rpdid=|(YuJm~|)lJ0J'ulY~~)lu)|; stardustvideo=1; sid=ih8yqv5n; laboratory=1-1; im_notify_type_6692208=0; LIVE_PLAYER_TYPE=2; dy_spec_agreed=1; DedeUserID=6692208; DedeUserID__ckMd5=c56ad702aa91db1e; SESSDATA=c04b7a1f%2C1603258212%2C356e9*41; bili_jct=2f70ab6c72811e66d8aa2c213b66527c; CURRENT_QUALITY=116; bsource=seo_baidu; deviceFingerprint=76d922916b398d424d70e37a93a1c417; kfcSource=Mdynamic; msource=Mdynamic; bp_t_offset_6692208=393673472539036962; _dfcaptcha=587eada633263e36dac94ac17ca97527; bp_video_offset_6692208=393691816342365508; Hm_lvt_8a6e55dbd2870f0f5bc9194cddf32a02=1590502278,1590503295; Hm_lpvt_8a6e55dbd2870f0f5bc9194cddf32a02=1590503295; PVID=14"</span>,</span><br><span class="line"><span class="string">'origin'</span>: <span class="string">'https://live.bilibili.com'</span>,</span><br><span class="line"><span class="string">'referer'</span>: <span class="string">'https://live.bilibili.com/21129786'</span>,</span><br><span class="line"><span class="string">'sec-fetch-dest'</span>: <span class="string">'empty'</span>,</span><br><span class="line"><span class="string">'sec-fetch-mode'</span>: <span class="string">'cors'</span>,</span><br><span class="line"><span class="string">'sec-fetch-site'</span>: <span class="string">'same-site'</span>,</span><br><span class="line"><span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#formdata</span></span><br><span class="line">formdata=&#123;</span><br><span class="line"><span class="string">'roomid'</span>: <span class="string">'21129786'</span>,</span><br><span class="line"><span class="string">'csrf_token'</span>: <span class="string">'2f70ab6c72811e66d8aa2c213b66527c'</span>,</span><br><span class="line"><span class="string">'csrf'</span>: <span class="string">'2f70ab6c72811e66d8aa2c213b66527c'</span></span><br><span class="line">    &#125;</span><br><span class="line">headers2 = &#123;</span><br><span class="line"><span class="string">'Host'</span>: <span class="string">'api.live.bilibili.com:443'</span>,</span><br><span class="line"><span class="string">'Proxy-Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line"><span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">resp = requests.post(url, headers=headers, data=formdata)</span><br></pre></td></tr></table></figure>

<p>但是返回结果之中有编码</p>
<img src="/2020/05/27/biliBara-liveStreaming/1590517726858.png" class="" width="1590517726858">

<p>查看chrome中的元素后发现这是&gt;的unicode编码</p>
<p>那么接着添加上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp.encoding = <span class="string">"unicode_escape"</span></span><br></pre></td></tr></table></figure>

<p>最后编码也就显示正常了</p>
<h1 id="2-Websocket分析"><a href="#2-Websocket分析" class="headerlink" title="2. Websocket分析"></a>2. Websocket分析</h1><h3 id="1-站在巨人的肩膀上（偷懒）"><a href="#1-站在巨人的肩膀上（偷懒）" class="headerlink" title="1. 站在巨人的肩膀上（偷懒）"></a>1. 站在巨人的肩膀上（偷懒）</h3><p>b站的websocket已经有人写成了接口，也就是bilibili-live-ws, 可以使用npm安装</p>
<p><a href="https://github.com/simon300000/bilibili-live-ws" target="_blank" rel="noopener">https://github.com/simon300000/bilibili-live-ws</a></p>
<p>使用express的测试代码如下</p>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> LiveWS = <span class="built_in">require</span>(<span class="string">'bilibili-live-ws'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="built_in">require</span>(<span class="string">'nodejs-websocket'</span>);</span><br><span class="line"></span><br><span class="line"> app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// res.send('Hello World!')</span></span><br><span class="line"></span><br><span class="line">    connection.on(<span class="string">"text"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(str)</span><br><span class="line">      <span class="keyword">const</span> live = <span class="keyword">new</span> LiveWS(<span class="number">21129786</span>)</span><br><span class="line">      live.on(<span class="string">'open'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Connection is established'</span>))</span><br><span class="line">      <span class="comment">// Connection is established</span></span><br><span class="line">      live.on(<span class="string">'live'</span>, () =&gt; &#123;</span><br><span class="line">        live.on(<span class="string">'heartbeat'</span>, online=&gt;&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"heartbeat"</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(online)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;) </span><br><span class="line">      live.on(<span class="string">"msg"</span>, (data)=&gt;&#123;</span><br><span class="line">        <span class="comment">//返回给前端</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data"</span>)</span><br><span class="line">        data = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">        connection.sendText(data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data suc"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure>

<p>打开控制台之后，就能接收到b站直播房间推送的json消息了。</p>
<p>但是这里的数据只能在nodejs中使用，原生的html和vue都不能使用，浏览器会报错</p>
<p>这是因为nodejs使用的websocket和原生的websocket是不一样的</p>
<p>所以就要用websocket把nodejs和前端连接起来了</p>
<p><strong>和连接前端</strong></p>
<p>nodejs的websocket包是nodejs-websocket</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i nodejs-websocket -S</span><br></pre></td></tr></table></figure>

<p>代码改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> LiveWS = <span class="built_in">require</span>(<span class="string">'bilibili-live-ws'</span>)<span class="comment">// import pack</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="built_in">require</span>(<span class="string">'nodejs-websocket'</span>); <span class="comment">//import pack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.get('/', (req, res) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">// res.send('Hello World!')</span></span><br><span class="line">  <span class="keyword">const</span> server = ws.createServer(<span class="function"><span class="params">connection</span> =&gt;</span> &#123;</span><br><span class="line">    connection.on(<span class="string">"text"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(str)</span><br><span class="line">      <span class="keyword">const</span> live = <span class="keyword">new</span> LiveWS(<span class="number">21129786</span>)</span><br><span class="line">      live.on(<span class="string">'open'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Connection is established'</span>))</span><br><span class="line">      <span class="comment">// Connection is established</span></span><br><span class="line">      live.on(<span class="string">'live'</span>, () =&gt; &#123;</span><br><span class="line">        live.on(<span class="string">'heartbeat'</span>, online=&gt;&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"heartbeat"</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(online)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;) </span><br><span class="line">      live.on(<span class="string">"msg"</span>, (data)=&gt;&#123;</span><br><span class="line">        <span class="comment">//返回给前端</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data"</span>)</span><br><span class="line">        <span class="comment">//转化为json格式</span></span><br><span class="line">        data = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">        connection.sendText(data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"return data suc"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).listen(port) <span class="comment">//监听端口3000</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`))</span></span><br></pre></td></tr></table></figure>

<p>前端接收的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">      <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:3000"</span>)</span><br><span class="line">      ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ws open"</span>)</span><br><span class="line">        ws.send(<span class="string">"vue send message"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ws.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"receive msh"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样子一登录到vue页面，就会和后台建立websocket连接，之后后台就会和b站直播建立连接，最后反向将消息推送到前段之中。</p>
<p>这里要注意的是在后端要进项数据的转化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; JSON.stringify(data)</span><br></pre></td></tr></table></figure>

<p>否则浏览器会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first argument must be one of type string or Buffer.</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/mn6364/p/10698056.html" target="_blank" rel="noopener">https://www.cnblogs.com/mn6364/p/10698056.html</a></p>
<h3 id="2-协议分析"><a href="#2-协议分析" class="headerlink" title="2.协议分析"></a>2.协议分析</h3><p>网上也有一些协议的分析</p>
<p><a href="https://blog.csdn.net/xfgryujk/article/details/80306776" target="_blank" rel="noopener">https://blog.csdn.net/xfgryujk/article/details/80306776</a></p>
<p><a href="http://www.lyyyuna.com/2016/03/14/bilibili-danmu01/" target="_blank" rel="noopener">http://www.lyyyuna.com/2016/03/14/bilibili-danmu01/</a></p>
<p>下面这个讲的比较详细，也有相关node代码的教程</p>
<p><a href="https://github.com/lovelyyoshino/Bilibili-Live-API/blob/master/API.WebSocket.md" target="_blank" rel="noopener">https://github.com/lovelyyoshino/Bilibili-Live-API/blob/master/API.WebSocket.md</a></p>
<h3 id="3-websocket教程"><a href="#3-websocket教程" class="headerlink" title="3. websocket教程"></a>3. websocket教程</h3><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>
<h3 id="4-抓包"><a href="#4-抓包" class="headerlink" title="4. 抓包"></a>4. 抓包</h3><p>websocket可以使用wireshark或者fiddler进行抓包</p>
<h5 id="1-fiddler抓包"><a href="#1-fiddler抓包" class="headerlink" title="1. fiddler抓包"></a>1. fiddler抓包</h5><p>因为fiddler只能抓取http和https，websocket只有第一次握手是http协议，所以内容都集中在第一次握手的包里了。</p>
<p>直接在fiddler中搜索websocket，就会出现sub包</p>
<img src="/2020/05/27/biliBara-liveStreaming/1590707236199.png" class="" width="1590707236199">

<p>点击sub包就会出现右边的内容</p>
<p>发现第一个包是连接时发送的包</p>
<img src="/2020/05/27/biliBara-liveStreaming/1590707331539.png" class="" width="1590707331539">

<p>发送一个测试弹幕，但发现内容加密了</p>
<img src="/2020/05/27/biliBara-liveStreaming/1590707452590.png" class="" width="1590707452590">

<p>只好再用wireshark</p>
<h5 id="2-wireshark"><a href="#2-wireshark" class="headerlink" title="2. wireshark"></a>2. wireshark</h5>]]></content>
      <categories>
        <category>biliBara</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
        <tag>web</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>blender烘焙（multiple-into-one）</title>
    <url>/2020/07/25/blender-bake-multiple-into-one/</url>
    <content><![CDATA[<p>本文是讲解将多物体的多材质烘焙到一个贴图上的方法。</p>
<p>要说明的是，这里小白一个，首先可以先看一下视频，如果做不出来再看本文，因为本文只是指出了要注意的细节，此外如有错误也欢迎指出和讨论..<br><a href="https://www.youtube.com/watch?v=9airvjDaVh4&list=PLj6G-3M0NXNXGGPSPXBTC1H04NPxk96Eo&index=18&t=0s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=9airvjDaVh4&amp;list=PLj6G-3M0NXNXGGPSPXBTC1H04NPxk96Eo&amp;index=18&amp;t=0s</a></p>
<a id="more"></a>

<h1 id="1-页面布局"><a href="#1-页面布局" class="headerlink" title="1.页面布局"></a>1.页面布局</h1><p>blender烘焙需要用到shader、UV editor以及3dviewport界面，将界面布置好更有利于操作</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-263c377d587b4a51.png" class="" title="图片.png">
<h1 id="2-烘焙前的准备"><a href="#2-烘焙前的准备" class="headerlink" title="2.烘焙前的准备"></a>2.烘焙前的准备</h1><p>烘焙需要准备三点</p>
<ol>
<li>一个全新的UV贴图</li>
<li>图像用来保存烘焙机结果</li>
<li>一个Image Texture节点用来指定导出到的图像</li>
</ol>
<h3 id="1-创建新图像"><a href="#1-创建新图像" class="headerlink" title="1.创建新图像"></a>1.创建新图像</h3><p>首先要创建一个新的图像，要注意的是这个<strong>图像要进行save as和save两步操作</strong>，让其保存在电脑的硬盘上，否则最后的烘焙会报”circular depandancy…”的信息，这个信息就是没找到需要导出的图像而导致图像载入到自己身上。原因大概是因为，不这样做，blender会无法检测到新图像。</p>
<h3 id="2-UV展开"><a href="#2-UV展开" class="headerlink" title="2.UV展开"></a>2.UV展开</h3><p>进行UV展开前，先新建一个UV贴图，并将该新贴图选定。</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-7a4a06a4528bfd41.png" class="" title="图片.png">
<p>然后进入edit模式，按u键进行UV展开。</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-52ffa5918c59dc3b.png" class="" title="图片.png">
<p>UV展开这里因为是高模，可以选择unwrap或者smart UV project。二者的区别在于，smart UV project可以进行个性化的展开。此外，低模也可以选择lightmap pack。<br>然后就可以发现，图片上出现了UV展开的节点，其实这里这些UV节点就保存到了刚刚新建的UV贴图里面了。</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-9a9c11a5dbc295e9.png" class="" title="图片.png">
<h3 id="3-node节点设置"><a href="#3-node节点设置" class="headerlink" title="3.node节点设置"></a>3.node节点设置</h3><p>之后在每个材质的shader界面里，新增一个image texture节点，该节点的图片就指向你要导出的那个图片。<br><strong>注意</strong>：</p>
<ol>
<li>该节点要给每个要导出的材质添加</li>
<li>该节点必须要激活（active）！！！，也就是有白色边框 <img src="/2020/07/25/blender-bake-multiple-into-one/17071720-001343e738e56ff2.png" class="" title="图片.png">
 因为这样子操作非常麻烦，所以我写了一个脚本给每个模型的每个材质都添加这个节点，只要白get后的图片名称改成自己的即可。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.data.objects:</span><br><span class="line">    <span class="keyword">for</span> material <span class="keyword">in</span> obj.data.materials:</span><br><span class="line">        tochangeNode = material.node_tree.nodes.new(<span class="string">"ShaderNodeTexImage"</span>)</span><br><span class="line">        tochangeNode.image = bpy.data.images.get(<span class="string">"kokoro2"</span>) //change name here </span><br><span class="line">        tochangeNode.location = Vector((<span class="number">377</span>,<span class="number">-141</span>))</span><br><span class="line">//active the node</span><br><span class="line">        material.node_tree.nodes.active = tochangeNode</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="3-开始烘焙"><a href="#3-开始烘焙" class="headerlink" title="3.开始烘焙"></a>3.开始烘焙</h1><p>烘焙必须在cycle下进行</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-48304b0d4f8277a2.png" class="" title="图片.png">
<p>比较常用的烘焙模式为combined,diffuse,normal模式。<br>combined模式就是讲光影效果、阴影效果等等全部烘焙到贴图上。<br>diffuse可以选择只烘焙材质的颜色。<br>normal是法线贴图，可以给贴图丰富细节的同时又不消耗性能。<br>这里要导出到unity中，所以选择diffuse和normal模式</p>
<h3 id="1-diffuse"><a href="#1-diffuse" class="headerlink" title="1.diffuse"></a>1.diffuse</h3><p>按下面的选项勾选，margin在贴图烘焙重叠时，可以改的小一些。此外如果是多个物体烘焙需要勾选selected to active，我这里用ctrl+j合并了物体，所以不能勾选。</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-80df83722164165b.png" class="" title="图片.png">

<h3 id="2-normal"><a href="#2-normal" class="headerlink" title="2.normal"></a>2.normal</h3><p>因为要新建个图片烘焙，所以这里用另一个脚本更改节点的图片名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for obj in bpy.data.objects:</span><br><span class="line">    for material in obj.data.materials:</span><br><span class="line">        tochangeNode &#x3D; material.node_tree.nodes[-1]</span><br><span class="line">        tochangeNode.image &#x3D; bpy.data.images.get(&quot;kokoro_normal&quot;)</span><br></pre></td></tr></table></figure>

<p>最后烘焙结束后，要记住点击save保存，烘焙才会生效</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-abee8e933c37ff58.png" class="">

<h1 id="4-其他设定"><a href="#4-其他设定" class="headerlink" title="4.其他设定"></a>4.其他设定</h1><p>复制刚才的模型，并且删除所有模型，将刚刚的贴图制作成材质来测试一下烘焙效果。发现hair、eyelash、eyeball都全黑了。</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-91b11c63053de14a.png" class="" title="图片.png">
<p>再看贴图，这是因为本该透明的部分被黑色填充的结果。这个问题可以用gloss烘焙来解决。</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-23a8308842ba6637.png" class="" title="图片.png">

<p>按照之前的步骤，再进行gloss烘焙，得到的就是alpha通道的结果。白色代表要显示的部分，黑色的代表透明部分。</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-9563b93276465948.png" class="">
<p>打开ps将diffuse和gloss贴图导入。<br>给diffuse贴图添加一个蒙版，然后点击gloss贴图ctrl+a全选，ctrl+c复制，按住alt键点击多出来的蒙版，然后ctrl+v粘贴。最后就会得到两者合并的结果</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-7834a1b7165fa29b.png" class="" title="图片.png">
<p>然后到处PNG格式图片（PNG支持alpha通道）</p>
<p>回到blender，如图所示设置，即可完成结果</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-01b9981002df842e.png" class="" title="图片.png">
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-3ec35fd8263aab9b.png" class="" title="图片.png">

<h1 id="5-导入unity"><a href="#5-导入unity" class="headerlink" title="5.导入unity"></a>5.导入unity</h1><p>将模型导出为fbx格式，如图所示勾选，即可将材质放入导出的fbx文件中</p>
<img src="/2020/07/25/blender-bake-multiple-into-one/17071720-224fb2c541ece681.png" class="" title="图片.png">
<p>在unity中打开，但发现人物的眼睛、睫毛、头发仍然存在刚才的问题。<br>这是因为render mode中选择了opaque模式，这个模式是不考虑alpha通道的，之后选择cutoff模式即可。<br>不过这种模式下，发现睫毛和头发部分表现效果并不理想。解决方法是将这两个部分单独拎出来烘焙，然后选择fade效果。此外如果眼睛部分选择transparent效果，还可以实现眼睛的反光。</p>
<p>参考：<br><a href="https://blender.stackexchange.com/questions/44525/cycles-bake-script-error-circular-dependency" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/44525/cycles-bake-script-error-circular-dependency</a><br><a href="https://blender.stackexchange.com/questions/47052/what-is-the-difference-between-unwrap-and-smart-uv-project" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/47052/what-is-the-difference-between-unwrap-and-smart-uv-project</a><br><a href="https://blenderartists.org/t/texture-bake-alpha/407849/5" target="_blank" rel="noopener">https://blenderartists.org/t/texture-bake-alpha/407849/5</a></p>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>blender</tag>
        <tag>unity</tag>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>deep-learning-tutorial</title>
    <url>/2020/07/07/deep-learning-tutorial/</url>
    <content><![CDATA[<p>总结一下deep learning的学习路线</p>
<a id="more"></a>

<h1 id="一、kaggle-learning"><a href="#一、kaggle-learning" class="headerlink" title="一、kaggle learning"></a>一、kaggle learning</h1><h3 id="1-titanic："><a href="#1-titanic：" class="headerlink" title="1.titanic："></a>1.titanic：</h3><p><a href="https://www.kaggle.com/alexisbcook/titanic-tutorial" target="_blank" rel="noopener">https://www.kaggle.com/alexisbcook/titanic-tutorial</a></p>
<h3 id="2-intro-to-machine-learning："><a href="#2-intro-to-machine-learning：" class="headerlink" title="2.intro to machine learning："></a>2.intro to machine learning：</h3><p><a href="https://www.kaggle.com/learn/intro-to-machine-learning" target="_blank" rel="noopener">https://www.kaggle.com/learn/intro-to-machine-learning</a></p>
<ol>
<li><p>talk about lack of data：<a href="https://www.kaggle.com/learn-forum/60581" target="_blank" rel="noopener">https://www.kaggle.com/learn-forum/60581</a></p>
<p>when the data was not new, you should consider the reason that cause this and determine whether it will affect the prediction results.</p>
</li>
</ol>
<h3 id="3-intermideate-machine-learning"><a href="#3-intermideate-machine-learning" class="headerlink" title="3.intermideate machine learning"></a>3.intermideate machine learning</h3><p><a href="https://www.kaggle.com/learn/intermediate-machine-learning" target="_blank" rel="noopener">https://www.kaggle.com/learn/intermediate-machine-learning</a></p>
<h3 id="4-deep-learning"><a href="#4-deep-learning" class="headerlink" title="4.deep learning"></a>4.deep learning</h3><p><a href="https://www.kaggle.com/Learn/Deep-Learning" target="_blank" rel="noopener">https://www.kaggle.com/Learn/Deep-Learning</a></p>
<h1 id="二、categories"><a href="#二、categories" class="headerlink" title="二、categories"></a>二、categories</h1><h3 id="1-BP"><a href="#1-BP" class="headerlink" title="1. BP"></a>1. BP</h3><p><a href="https://blog.csdn.net/weixin_39441762/article/details/80446692?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39441762/article/details/80446692?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="2-RBF神经网络-径向基"><a href="#2-RBF神经网络-径向基" class="headerlink" title="2.RBF神经网络(径向基)"></a>2.RBF神经网络(径向基)</h3><p><a href="https://blog.csdn.net/Y_hero/article/details/88985447" target="_blank" rel="noopener">https://blog.csdn.net/Y_hero/article/details/88985447</a></p>
<h3 id="3-CNN"><a href="#3-CNN" class="headerlink" title="3.CNN"></a>3.CNN</h3><ol>
<li>LeNet-5</li>
</ol>
<p><a href="https://blog.csdn.net/weixin_42398658/article/details/84392845" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42398658/article/details/84392845</a></p>
<img src="/2020/07/07/deep-learning-tutorial/20181123193922202.png" class="" title="img">

<h3 id="4-激励函数"><a href="#4-激励函数" class="headerlink" title="4.激励函数"></a>4.激励函数</h3><p>将线性关系转化为非线性关系，往往是对数据进行升维</p>
<p><a href="https://blog.csdn.net/tyhj_sf/article/details/79932893" target="_blank" rel="noopener">https://blog.csdn.net/tyhj_sf/article/details/79932893</a></p>
<h3 id="5-logistic-regression"><a href="#5-logistic-regression" class="headerlink" title="5. logistic regression"></a>5. logistic regression</h3><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49123419" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49123419</a></p>
<p>解决的问题：二分类问题</p>
<p>高纬度解决方案：进行mapFeature操作，将变量升纬</p>
<h1 id="三、example"><a href="#三、example" class="headerlink" title="三、example"></a>三、example</h1><h3 id="1-titanic"><a href="#1-titanic" class="headerlink" title="1. titanic"></a>1. titanic</h3><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49797143</a> (<strong>recommend</strong>)</p>
<h3 id="2-naive-NPL"><a href="#2-naive-NPL" class="headerlink" title="2.naive NPL"></a>2.naive NPL</h3><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/50545650" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/50545650</a></p>
]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo-build</title>
    <url>/2020/05/25/hexo-build/</url>
    <content><![CDATA[<p>记录hexo的搭建过程以及插件的安装过程</p>
<a id="more"></a>

<p>总体的搭建过程看</p>
<p><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></p>
<p>以下是各种插件</p>
<h1 id="1-hexo命令"><a href="#1-hexo命令" class="headerlink" title="1. hexo命令"></a>1. hexo命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<h1 id="2-插入图片（和typora结合）"><a href="#2-插入图片（和typora结合）" class="headerlink" title="2. 插入图片（和typora结合）"></a>2. 插入图片（和typora结合）</h1><p><a href="https://www.cnblogs.com/cocowool/p/hexo-image-link.html" target="_blank" rel="noopener">https://www.cnblogs.com/cocowool/p/hexo-image-link.html</a></p>
<p>因为hexo的资源根目录在source处，typora默认的相对路径不能帮助hexo索引到图片，需要插件搞定</p>
<ol>
<li><p>hexo配置</p>
<p>在_config.yml中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用hexo插件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>设置typora</p>
<img src="/2020/05/25/hexo-build/39469-20200316225054107-484234981.png" class="" title="img">

</li>
</ol>
<h1 id="3-live2d插件"><a href="#3-live2d插件" class="headerlink" title="3. live2d插件"></a>3. live2d插件</h1><p><a href="https://www.jianshu.com/p/4b61d8702cfa" target="_blank" rel="noopener">https://www.jianshu.com/p/4b61d8702cfa</a></p>
<ol>
<li><p>npm安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
</li>
<li><p>config配置（hexo不是主题文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  scriptFrom: <span class="built_in">local</span></span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: <span class="literal">false</span></span><br><span class="line">  debug: <span class="literal">false</span></span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-shizuku</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建文件夹</p>
<p>下载完之后，在Hexo根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中，然后编辑配置文件中的<code>model.use</code>项，将其修改为live2d_models文件夹中的模型文件夹名称。</p>
</li>
</ol>
<h1 id="4-next主题（评论系统）"><a href="#4-next主题（评论系统）" class="headerlink" title="4. next主题（评论系统）"></a>4. next主题（评论系统）</h1><p><a href="https://blog.csdn.net/jiunian_2761/article/details/97388997" target="_blank" rel="noopener">https://blog.csdn.net/jiunian_2761/article/details/97388997</a></p>
<h1 id="5-next主题（访问人数）"><a href="#5-next主题（访问人数）" class="headerlink" title="5. next主题（访问人数）"></a>5. next主题（访问人数）</h1><p><a href="https://blog.csdn.net/qq_43751489/article/details/102990376" target="_blank" rel="noopener">https://blog.csdn.net/qq_43751489/article/details/102990376</a></p>
<h1 id="6-next主题（字数统计，阅读时长）"><a href="#6-next主题（字数统计，阅读时长）" class="headerlink" title="6. next主题（字数统计，阅读时长）"></a>6. next主题（字数统计，阅读时长）</h1><p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93670772" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/93670772</a></p>
<h1 id="7-next主题（canvas-next）"><a href="#7-next主题（canvas-next）" class="headerlink" title="7.next主题（canvas_next）"></a>7.next主题（canvas_next）</h1><p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/95000707" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/95000707</a></p>
<ol>
<li><p>进入next文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载canvas_next</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件配置</p>
<p>在next的config文件中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#39;0,0,0&#39; # RGB values, use &#39;,&#39; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 99 # the number of lines</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo_hover_style_realize</title>
    <url>/2020/05/27/hexo-hover-style-realize/</url>
    <content><![CDATA[<p>很喜欢hexo的文字悬浮样式，所以扒下来实现了一下</p>
<img src="/2020/05/27/hexo-hover-style-realize/1590585162697.png" class="" width="1590585162697">

<a id="more"></a>

<p>首先，通过chrome分析，可以发现hexo的底部横线动画是在::before元素上的</p>
<p><strong>分析发现颜色控制是</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">black</span>;</span><br></pre></td></tr></table></figure>

<p><strong>位置控制是（左右）</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: 50%;</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">bottom</span>: 0;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br></pre></td></tr></table></figure>

<p>其中transform-origin控制的是偏移量，默认为50%，也就是从文字的中部出现</p>
<p>设置为0时，会从最左边出现</p>
<p>设置为100%时，会从最右边出现</p>
<p><strong>粗细控制是</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 2<span class="selector-tag">px</span>;</span><br><span class="line">content: '';</span><br></pre></td></tr></table></figure>

<p><strong>动画控制是</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(0);</span><br><span class="line"><span class="selector-tag">width</span>: 100%;</span><br><span class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">transition-delay</span>: 0<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 0<span class="selector-class">.2s</span>;</span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">ease-in-out</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后总体显示代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.test</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">  transform-origin: -1;</span><br><span class="line">  transform: scaleX(0);</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: black;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  transition-delay: 0s;</span><br><span class="line"><span class="css">  <span class="selector-tag">transition-duration</span>: 0<span class="selector-class">.2s</span>;</span></span><br><span class="line">  transition-timing-function: ease-in-out;</span><br><span class="line">  content: '';</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  height: 2px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.test</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">  transform: scaleX(1);</span><br><span class="line">  visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.test</span>&#123;</span></span><br><span class="line">  position: relative;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span>&#123;</span></span><br><span class="line">  margin: 0 400px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>This is a long Test<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next-SEO设置</title>
    <url>/2020/08/09/hexo-next-SEO%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>对hexo进行百度和google的seo设置和优化</p>
<a id="more"></a>

<p>参考如下：</p>
<p><a href="https://croook.github.io/2019/10/11/hexo_baidu_verify/" target="_blank" rel="noopener">https://croook.github.io/2019/10/11/hexo_baidu_verify/</a></p>
<p>首先要分别打开百度站长和google search console</p>
<h1 id="百度SEO"><a href="#百度SEO" class="headerlink" title="百度SEO"></a>百度SEO</h1><h3 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h3><p>验证方式有三种，常用的方式有两种</p>
<p>第一种是CNAME验证，这种验证方式需要有域名；第二种方式是html验证，这种方式不需要有域名。</p>
<h5 id="CNAME验证："><a href="#CNAME验证：" class="headerlink" title="CNAME验证："></a>CNAME验证：</h5><p>在阿里云DNS解析里面添加记录</p>
<img src="/2020/08/09/hexo-next-SEO%E8%AE%BE%E7%BD%AE/1596919828051.png" class="" width="1596919828051">

<p><strong>主机记录</strong>就是百度给你的那一长串子，而<strong>记录值</strong>则是ziyuan.baidu.com，<strong>记录类型</strong>选择CNAME即可。</p>
<hr>
<h5 id="HTML验证："><a href="#HTML验证：" class="headerlink" title="HTML验证："></a>HTML验证：</h5><p>在<strong>next的config文件里</strong>查找如下记录</p>
<img src="/2020/08/09/hexo-next-SEO%E8%AE%BE%E7%BD%AE/1596920200169.png" class="" width="1596920200169">

<p>将百度的提供的编码添加进去，<strong>clean之后</strong>重新生成和提交，头文件中就会出现需要的标签。</p>
<p>具体的设置可以看source/layout/partial/head下面的head.swig中的<code>if theme.baidu_site_verification</code></p>
<img src="/2020/08/09/hexo-next-SEO%E8%AE%BE%E7%BD%AE/3.png" class="" title="img">

<h3 id="2-推送"><a href="#2-推送" class="headerlink" title="2.推送"></a>2.推送</h3><p>百度的推送方法有三种api推送、sitemap推送、手动推送。因为github屏蔽了百度的爬虫，所以这里需要借助api推送。</p>
<p>在那之前可以打开next的baidu自动推送功能</p>
<h5 id="1-next推送功能"><a href="#1-next推送功能" class="headerlink" title="1.next推送功能"></a>1.next推送功能</h5><p>在next的config文件下，搜索baidu_push，改为true。然后generate一下，就会在layout/third…中看到baidu_push.swig</p>
<hr>
<h5 id="2-api推送"><a href="#2-api推送" class="headerlink" title="2.api推送"></a>2.api推送</h5><hr>
<h5 id="3-sitemap"><a href="#3-sitemap" class="headerlink" title="3.sitemap"></a>3.sitemap</h5>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo美化</title>
    <url>/2020/08/07/hexo%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>对hexo的next主题进行进一步的个性化</p>
<a id="more"></a>

<h1 id="1-创建自定义文件"><a href="#1-创建自定义文件" class="headerlink" title="1.创建自定义文件"></a>1.创建自定义文件</h1><p>在next的config文件下，搜索如下文件，将注释取消。</p>
<img src="/2020/08/07/hexo%E7%BE%8E%E5%8C%96/1596784778759.png" class="" width="1596784778759">

<p>然后在<strong>hexo根目录</strong>的source下创建<strong>_data</strong>文件夹，里面存放styles.styl文件。</p>
<p>之后就可以在这个文件里添加自己想要添加的css代码（可以是styl格式）</p>
<h1 id="2-自定义整理"><a href="#2-自定义整理" class="headerlink" title="2.自定义整理"></a>2.自定义整理</h1><p><a href="https://www.jianshu.com/p/5017abb0d0a2" target="_blank" rel="noopener">https://www.jianshu.com/p/5017abb0d0a2</a></p>
<p><a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">https://io-oi.me/tech/hexo-next-optimization/</a></p>
<p><a href="https://sunderarmor.ink/2019/06/20/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/#more" target="_blank" rel="noopener">https://sunderarmor.ink/2019/06/20/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/#more</a></p>
<h3 id="1-滚动条设置"><a href="#1-滚动条设置" class="headerlink" title="1.滚动条设置"></a>1.滚动条设置</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 更好的侧边滚动条</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:increment</span>,<span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:decrement</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-corner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span>,<span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat <span class="number">0</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">15px</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">30px</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-添加自定义图标（bilibili、简书等）"><a href="#2-添加自定义图标（bilibili、简书等）" class="headerlink" title="2.添加自定义图标（bilibili、简书等）"></a>2.添加自定义图标（bilibili、简书等）</h3><p><a href="https://blog.dlzhang.com/posts/32/" target="_blank" rel="noopener">https://blog.dlzhang.com/posts/32/</a></p>
<p>这里可以使用阿里矢量库，在里面搜索相关的图标，添加至购物车，然后下载代码。</p>
<p>将其中的<strong>iconfont.css</strong>的代码复制粘贴在styles.styl里面，此时就可以在hexo中使用<code>&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</code>进行引用了。</p>
<p>但如果想在侧边栏隐形，需要进一步修改</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;<span class="attribute">font-family</span>: <span class="string">"iconfont"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'iconfont.eot?t=1596739855011'</span>); <span class="comment">/* IE9 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'iconfont.eot?t=1596739855011#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAUEAAsAAAAACdQAAAS4AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCDHAqHCIVTATYCJAMQCwoABCAFhG0HUBtNCFGULk6N7Edh3LaEI5xZSilVQyl4tvV9vdPGw39rr/fNzC4H0CUKULLi46OiiqQqFLBqpatTZSP+1bTtU9t4Zseny1e0pqq/u+wlm/TN0sbjNMqAkCAcg2xqKN3+k4m5wFVpp+YXtT/unf5R54HNZ1kuYy0ba1DUBRiNrYHtiVEgBThAIg3AYm8Yu4k8yPMEeqsCs6uLu0dYU4BpgXjFhYG1hFapIIVWUResLeK7Spu+pm/gm/f++C+LNZIqA3Ovn5zncPSz/n074xPcLYrgDWeGsomMPaAQzwqtDywG/j2Leit6ySHQQnNiqJ7538GTicjfirQV//IISSZqQDoKxH1JPjAeZhD85mCQ+B2slXm8PN9iHsQuQNwZ7EHoVEq1cbh3sLxatePJ6kLzMTk2ZmaUynmGI5zk4iJbIAQbJOKNY14CtZVcV5u5mtelSDpRxtvWJygIr9HC+Upz+CtIGUyCTlew459QNTUkSLRBGEar4K4gdXRE6JU8PLCNFo4fc5WPY5gEbGnj5UWZEOY0gKEw/GTfB0OZvQBEMABwpE0A8Sk8fut18s77wQff++/jQLWQondFNZdPvVL3ulQznXfvgWBVkyBG1PFCQsIHqx4nm3lVqySHtrjL6wGk1XBhXtRUwR8uizWG/jZRhLcvRDEKLPSGvmXXOnAuL3htY2YAUPD+6XWM5erm7CCCEkNzWxD60Imua+EszeN8FLxHOrltShAlZsNaOgDA2692IgjRFRn7aTgAAEQNUbnlrQf1PDQd5gGnFcJkCdTCWnFGhQ7RuuhGHcnkNcXhrW154UVVFvVhvfDq2aKfMsNKNL5T2yxmkjERNsK3Q39XM3IIKJgN6fQE93RZiDW5duvekt9/e/TtNsXDp3lfVdtAwowrdts3yKSDKrPpTDon3GI4x1nAkKHCv+UvjlvilVK6L0uYBIooAFH8EVVMjPoIsiibCKN7NheiSI4PuwUlXWFLKn2ZomM/P8DIVixn9vTeM6PzlLObWewo4qZHc3rLwSDz4wNqJdHyGB0ldCixDLRkMMbIPBvloiWlMvW30gH8r80UtfxJfzawIIlduXIZfXRbokJi29nZXySmIlrERyS6IkZEgbf4OztXDv3xReG2qlwQ/++7qsAfKKj5pITtEoc3x2WpPOrNjQVsuZ45T+oy77gE2ABwol0o7982Dg7rX34OZTX6dxo+7aonHuJf73gFE7xAfsMvw2vM+7d4DUuKLQC6Ukwh5jqJxQcdrypVr8cfFWbe3xDypcbJhNZSBEljBbLWGlqIe1AZ7EOtdQq9XZebBwvEoigddnxyEGZ9QTLtB2SzftBC/IXKsn+ozcYi9G6Cc8/BRvCGpZBRytF+ILu+88igG37qPRUvjZG4wCM/k0zswjRK0qFL6kiGWDC9FpmqRy99ixfcZdQ0PQ7SV+Q0KlWHeRz7ohtFrm9hwyVBDEVyyPqAmNPreFpZbWRef48UXjQMqShqMT8jYsL9o1QkaYBeSrtGRZdyzeRVIaOUhzzRa6ELzkwa6O+hoXhUhTgqUnbwDuZioZxvKo2ml7d3uAl6YM8SKXKUqDQv2HRT+bJVUDIdGjoW19B2BDeMRSGydQQA'</span>) <span class="built_in">format</span>(<span class="string">'woff2'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'iconfont.woff?t=1596739855011'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'iconfont.ttf?t=1596739855011'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>), <span class="comment">/* chrome, firefox, opera, Safari, Android, iOS 4.2+ */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'iconfont.svg?t=1596739855011#iconfont'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>); <span class="comment">/* iOS 4.1- */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:inherit;</span><br><span class="line">  <span class="attribute">font-style</span>:normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-jianshu</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e506"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-zhihu-circle</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e712"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-bilibili-line</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e75d"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是第10行到第16行的修改。这样就可以使用使用了。</p>
<img src="/2020/08/07/hexo%E7%BE%8E%E5%8C%96/1596785254999.png" class="" width="1596785254999">

<h3 id="3-域名绑定"><a href="#3-域名绑定" class="headerlink" title="3.域名绑定"></a>3.域名绑定</h3><ol>
<li><p>在hexo的source下添加CNAME文件（无后缀），在里面写上自己的域名，如：<a href="http://www.gzhao01.top">www.gzhao01.top</a></p>
</li>
<li><p>在github设置中，custom domain下面设置该域名</p>
</li>
<li><p>ping一下自己的项目部署网址，得到ip地址</p>
</li>
<li><p>在阿里云的域名服务中添加两个解析记录分别是www和@记录。</p>
<img src="/2020/08/07/hexo%E7%BE%8E%E5%8C%96/1596786571292.png" class="" width="1596786571292">

</li>
</ol>
<h3 id="4-SSL证书"><a href="#4-SSL证书" class="headerlink" title="4.SSL证书"></a>4.SSL证书</h3><p>如果是部署在github上的，只要在setting界面勾选enfore https即可。</p>
<h3 id="5-设置置顶"><a href="#5-设置置顶" class="headerlink" title="5.设置置顶"></a>5.设置置顶</h3><ol>
<li><p>插件的安装和卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在文章中加入top，top的值越大，权重越大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo Next主题设置文章置顶</span><br><span class="line">id: a1</span><br><span class="line">date: 2020-01-03 17:26:01</span><br><span class="line">categories: Hexo</span><br><span class="line">tags: Next主题</span><br><span class="line">top: 999</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置置顶标志</p>
<p>在next/layout/_macro/post.swig中的添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class&#x3D;&quot;fas fa-thumbtack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;font color&#x3D;&quot;999&quot;&gt;pin top&lt;&#x2F;font&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>位置如下：</p>
<img src="/2020/08/07/hexo%E7%BE%8E%E5%8C%96/1596921149652.png" class="" width="1596921149652">

</li>
</ol>
<p>最终的效果如下：</p>
<img src="/2020/08/07/hexo%E7%BE%8E%E5%8C%96/1596919102715.png" class="" width="1596919102715">

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100:两数之和</title>
    <url>/2020/07/31/leetcode-top100-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<img src="/2020/07/31/leetcode-top100-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/1596191333136.png" class="" width="1596191333136">

<a id="more"></a>

<h1 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1.暴力解法"></a>1.暴力解法</h1><p>时间复杂度：$O（n²）$</p>
<p>空间复杂度：$O（1）$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    res.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-两遍哈希表"><a href="#2-两遍哈希表" class="headerlink" title="2.两遍哈希表"></a>2.两遍哈希表</h1><h3 id="1-前置知识："><a href="#1-前置知识：" class="headerlink" title="1.前置知识："></a>1.前置知识：</h3><p><a href="https://blog.csdn.net/qq_21997625/article/details/84672775" target="_blank" rel="noopener">https://blog.csdn.net/qq_21997625/article/details/84672775</a></p>
<p>unordered_map</p>
<p>c++里有map和unordered_map，其中map是个红黑树，里面所有的元素都是有序的；而unordered_map里面所有的元素都是无序的，实现的是一个哈希表。</p>
<h3 id="2-思路和代码："><a href="#2-思路和代码：" class="headerlink" title="2.思路和代码："></a>2.思路和代码：</h3><p>哈希表的查找时近似于$O(1)$的，除非查找时出现了冲突，那么就会变成$O(n)$。</p>
<p>这里的思路是进行两次迭代。第一次中，将数值和索引存入哈希表；第二遍迭代中，检查每个元素对应的数值<code>target-nums[i]</code>是否存在于哈希表中。需要注意的就是两个数字不能重复，即可。</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="comment">//存入hash表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = i; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(target-nums[i])&amp;&amp;<span class="built_in">map</span>[target-nums[i]]!=i)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(<span class="built_in">map</span>[target-nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-排序-双指针"><a href="#3-排序-双指针" class="headerlink" title="3.排序+双指针"></a>3.排序+双指针</h1><p>首先将数组排序，需要消耗$O(n\log(n))$的时间，然后使用双指针，遍历排序后的数组找到需要的值。</p>
<p>时间：$O(n\log(n))$</p>
<p>空间：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; </span><br><span class="line">        tmp = nums;</span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//双指针遍历</span></span><br><span class="line">        <span class="keyword">int</span> n=tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]+tmp[j]&lt;target) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]+tmp[j]&gt;target) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了相等的值</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//遍历原数组寻找参数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                <span class="comment">//找到了第一个值</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;n&amp;&amp;nums[k]==tmp[i])&#123;</span><br><span class="line">                    res.push_back(k);</span><br><span class="line">                    i=n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到了第二个值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;n&amp;&amp;nums[k]==tmp[j])&#123;</span><br><span class="line">                    res.push_back(k);</span><br><span class="line">                    j=n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//全找到</span></span><br><span class="line">                <span class="keyword">if</span>(i==n&amp;&amp;j==n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>一个报错：</strong></p>
<p><a href="https://blog.csdn.net/zhangpeterx/article/details/88775434" target="_blank" rel="noopener">https://blog.csdn.net/zhangpeterx/article/details/88775434</a></p>
<p>在写的过程中遇到一个报错：Heap-buffer-overflow。意思是访问了非法地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array[-1];&#x2F;&#x2F;非法地址</span><br></pre></td></tr></table></figure>

<p>原因时因为条件判断的过程中，顺序出了错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;         if(i&lt;j)&#123;</span><br><span class="line">&#x2F;&#x2F;             &#x2F;&#x2F;遍历原数组寻找参数</span><br><span class="line">&#x2F;&#x2F;             for(int k&#x3D;0;k&lt;n;k++)&#123;</span><br><span class="line">&#x2F;&#x2F;                 &#x2F;&#x2F;找到了第一个值</span><br><span class="line">				   &#x2F;&#x2F;顺序出错</span><br><span class="line">&#x2F;&#x2F;                 if(nums[k]&#x3D;&#x3D;tmp[i]&amp;&amp;i&lt;n)&#123;</span><br><span class="line">&#x2F;&#x2F;                     res.push_back(k);</span><br><span class="line">&#x2F;&#x2F;                     i&#x3D;n;</span><br><span class="line">&#x2F;&#x2F;                 &#125;</span><br><span class="line">&#x2F;&#x2F;                 &#x2F;&#x2F;找到了第二个值</span><br><span class="line">&#x2F;&#x2F;                 else if(nums[k]&#x3D;&#x3D;tmp[j]&amp;&amp;j&lt;n)&#123;</span><br><span class="line">&#x2F;&#x2F;                     res.push_back(k);</span><br><span class="line">&#x2F;&#x2F;                     j&#x3D;n;</span><br><span class="line">&#x2F;&#x2F;                 &#125;</span><br><span class="line">&#x2F;&#x2F;                 &#x2F;&#x2F;全找到</span><br><span class="line">&#x2F;&#x2F;                 if(i&#x3D;&#x3D;n&amp;&amp;j&#x3D;&#x3D;n)&#123;</span><br><span class="line">&#x2F;&#x2F;                     return res;</span><br><span class="line">&#x2F;&#x2F;                 &#125;</span><br><span class="line">&#x2F;&#x2F;             &#125;</span><br><span class="line">&#x2F;&#x2F;         &#125;</span><br></pre></td></tr></table></figure>

<p>这里的k的值可以变成n先判断第一个条件<code>nums[k]==tmp[i]</code>，之后才判断第二个条件<code>i&lt;n</code>。</p>
<p>所以调换一下顺序，就可以在判断<code>i&lt;n</code>的时候直接返回false了。</p>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>hash</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100：两数相加</title>
    <url>/2020/08/01/leetcode-top100%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<img src="/2020/08/01/leetcode-top100%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/1596276070612.png" class="" width="1596276070612">

<a id="more"></a>

<p>这一题就是简单的初等运算。</p>
<p>不过要注意的是c++的内存分配机制。</p>
<p><a href="https://www.cnblogs.com/1zhk/articles/5028743.html" target="_blank" rel="noopener">https://www.cnblogs.com/1zhk/articles/5028743.html</a></p>
<p>在c++中，分为栈空间、堆空间。一般的局部变量都分配在栈空间之中，比如<code>ListNode newNode(0);</code>，所以如果写成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">ListNode* l1_cur = l1;</span><br><span class="line"><span class="keyword">while</span>(a--)&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">newNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    l1_cur-&gt;next = &amp;newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么分配出来的结构体的空间会在循环结束的时候被释放，就会导致under-flow的error。</p>
<p>对于堆空间，唯一的分配方法就是使用new，这样直到程序人员自己释放空间之前，分配的空间都会被保存下来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//补全空链，以0填充</span></span><br><span class="line">        ListNode* l1_cur = l1;</span><br><span class="line">        ListNode* l2_cur = l2;</span><br><span class="line">        <span class="keyword">while</span>(l1_cur-&gt;next!=<span class="literal">NULL</span>||l2_cur-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = l1_cur-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(l1_cur-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="function">ListNode <span class="title">newNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">                l1_cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(l2_cur-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="function">ListNode <span class="title">newNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">                l2_cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                l2_cur = l2_cur-&gt;next;</span><br><span class="line">                l1_cur = l1_cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置</span></span><br><span class="line">        l1_cur=l1;</span><br><span class="line">        l2_cur=l2;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">result</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* header = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* pointer = header;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1_cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp = l1_cur-&gt;val + l2_cur-&gt;val + carry;</span><br><span class="line">            <span class="comment">//进位</span></span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                tmp=tmp%<span class="number">10</span>;</span><br><span class="line">                carry=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不进位</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                carry=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">ListNode <span class="title">tmpNode</span><span class="params">(tmp)</span></span>;</span><br><span class="line">            pointer-&gt;next = <span class="keyword">new</span> ListNode(tmp);</span><br><span class="line">            pointer = pointer-&gt;next;</span><br><span class="line">            l1_cur=l1_cur-&gt;next;</span><br><span class="line">            l2_cur=l2_cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一位进位</span></span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            <span class="function">ListNode <span class="title">node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            pointer-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> header-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100：两两交换链表中的节点</title>
    <url>/2020/08/02/leetcode-top100%EF%BC%9A%E4%B8%A4%E8%BE%86%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<img src="/2020/08/02/leetcode-top100%EF%BC%9A%E4%B8%A4%E8%BE%86%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1596369150852.png" class="" width="1596369150852">

<a id="more"></a>

<h1 id="1-递归解法"><a href="#1-递归解法" class="headerlink" title="1.递归解法"></a>1.递归解法</h1><p><a href="https://lyl0724.github.io/2020/01/25/1/" target="_blank" rel="noopener">https://lyl0724.github.io/2020/01/25/1/</a></p>
<p>递归需要三个个条件：</p>
<ol>
<li><p>终止条件：这里就是递归到的节点只剩一个或者是null节点。</p>
</li>
<li><p>返回值：返回值是已经交换后的第一个节点</p>
</li>
<li><p>单次过程：这里单次过程相当于在三个节点中交换前两个：first, second, 后面的节点作为一个整体</p>
<img src="/2020/08/02/leetcode-top100%EF%BC%9A%E4%B8%A4%E8%BE%86%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1596369477110.png" class="" width="1596369477110">

</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!(head-&gt;next))&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* headNext = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(headNext-&gt;next);</span><br><span class="line">        headNext-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> headNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-迭代求解"><a href="#2-迭代求解" class="headerlink" title="2.迭代求解"></a>2.迭代求解</h1><p>过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	first</span><br><span class="line">	↓</span><br><span class="line">-1-&gt;1-&gt;2-&gt;3-&gt;4</span><br><span class="line">↑	   ↑</span><br><span class="line">prev  sec</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* preNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* beforeHeadNode = preNode;</span><br><span class="line">        preNode-&gt;next=head;</span><br><span class="line">        <span class="comment">//还剩两个节点可供交换时</span></span><br><span class="line">        <span class="keyword">while</span>(preNode-&gt;next&amp;&amp;preNode-&gt;next-&gt;next)&#123;</span><br><span class="line">            ListNode* first = preNode-&gt;next;</span><br><span class="line">            ListNode* sec = preNode-&gt;next-&gt;next;</span><br><span class="line">            first-&gt;next = sec-&gt;next;</span><br><span class="line">            sec-&gt;next = first;</span><br><span class="line">            preNode-&gt;next = sec;</span><br><span class="line">            <span class="comment">//更新前节点</span></span><br><span class="line">            preNode = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beforeHeadNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_top100：有效括号</title>
    <url>/2020/08/03/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>本题虽然简单，但有很多有趣的、轻便的解法，值得一看。</p>
<img src="/2020/08/03/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596389567066.png" class="" width="1596389567066">

<a id="more"></a>

<h1 id="1-自己的解法（分类）"><a href="#1-自己的解法（分类）" class="headerlink" title="1.自己的解法（分类）"></a>1.自己的解法（分类）</h1><p>下面三种解法时间复杂度和空间复杂度都是$O(n)$</p>
<p>要注意的是空字符串也是正确的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">char</span> next=<span class="string">' '</span>;</span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            next = s[i];</span><br><span class="line">            <span class="comment">//左括号，则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(next==<span class="string">'('</span>||next==<span class="string">'&#123;'</span>||next==<span class="string">'['</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push(s[i]);</span><br><span class="line">            <span class="comment">//右括号，分情况</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//是如果栈不为空</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">char</span> pop_char = <span class="built_in">stack</span>.top();</span><br><span class="line">                    <span class="built_in">stack</span>.pop();</span><br><span class="line">                    <span class="comment">//栈顶元素不相配，返回false，否则继续循环</span></span><br><span class="line">                    <span class="keyword">switch</span> (next)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">if</span>(pop_char!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span>(pop_char!=<span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'&#125;'</span>: <span class="keyword">if</span>(pop_char!=<span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//栈为空，返回false</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束后，栈为空，返回false；否则为true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-优化代码"><a href="#2-优化代码" class="headerlink" title="2.优化代码"></a>2.优化代码</h1><p>其中empty的判断要在前，否则遇到’]’这种的，会报错，因为此时栈为空，调用top会出错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">char</span> c=<span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])&#123;</span><br><span class="line">                <span class="comment">//左括号</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>: <span class="built_in">stack</span>.push(<span class="string">')'</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'['</span>: <span class="built_in">stack</span>.push(<span class="string">']'</span>);<span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#123;'</span>: <span class="built_in">stack</span>.push(<span class="string">'&#125;'</span>);<span class="keyword">break</span>; </span><br><span class="line">                <span class="comment">//右括号</span></span><br><span class="line">                <span class="keyword">default</span>:&#123;</span><br><span class="line">                    <span class="comment">//empty在前，否则会报错</span></span><br><span class="line">                    <span class="comment">//如果栈为空 或者 栈顶元素不匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">stack</span>.empty()||<span class="built_in">stack</span>.top()!=s[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">stack</span>.pop(); </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2020/08/03/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596394828010.png" class="" width="1596394828010">

<h1 id="3-优化栈"><a href="#3-优化栈" class="headerlink" title="3.优化栈"></a>3.优化栈</h1><p>使用字典来优化代码。注意这里用右括号来当键，左括号来当值。这是因为在整个过程用我们会用右括号来匹配左括号，而字典里查找键的值比较方便，所以这样子写比较方便一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(s.size()==0) return true;</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; brackets&#123;</span><br><span class="line">            &#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;,</span><br><span class="line">            &#123;<span class="string">']'</span>,<span class="string">'['</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//遇到右括号</span></span><br><span class="line">            <span class="keyword">if</span>(brackets.<span class="built_in">find</span>(s[i])!=brackets.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//stack为空 或者 括号间不匹配</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.empty()||brackets[s[i]]!=<span class="built_in">stack</span>.top())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到左括号</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2020/08/03/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596394721849.png" class="" width="1596394721849">

<h1 id="4-从内向外去成对括号（python）"><a href="#4-从内向外去成对括号（python）" class="headerlink" title="4.从内向外去成对括号（python）"></a>4.从内向外去成对括号（python）</h1><img src="/2020/08/03/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596389740129.png" class="" width="1596389740129">

<p>可以发现成对的括号之间构成了一种递归关系：如果括号全部成对，那么无论是小对括号还是大对括号都是成对的。虽然解法效率低，但很简洁。</p>
<blockquote>
<p>从整体表达式中一次删除一个较小的表达式，因为这是一个有效的表达式，我们最后剩留下一个空字符串。</p>
</blockquote>
<img src="/2020/08/03/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596395364511.png" class="" width="1596395364511">

<img src="/2020/08/03/leetcode-top100%EF%BC%9A%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/1596395373951.png" class="" width="1596395373951">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'&#123;&#125;'</span> <span class="keyword">in</span> s o<span class="string">r'[]'</span> <span class="keyword">in</span> s o<span class="string">r'()'</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">'&#123;&#125;'</span>,<span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'[]'</span>,<span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>,<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">''</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode100：相同的树</title>
    <url>/2020/08/07/leetcode100%EF%BC%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<img src="/2020/08/07/leetcode100%EF%BC%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/1596830840744.png" class="" width="1596830840744">

<a id="more"></a>

<h1 id="1-深度优先搜索"><a href="#1-深度优先搜索" class="headerlink" title="1.深度优先搜索"></a>1.深度优先搜索</h1><p>如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。</p>
<p>如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。</p>
<ul>
<li>Time complexity : $\mathcal{O}(N)$, where N is a number of nodes in the tree, since one visits each node exactly once.</li>
<li>Space complexity : $\mathcal{O}(\log(N))$ in the best case of completely balanced tree and $\mathcal{O}(N)$ in the worst case of completely unbalanced tree, to keep a recursion stack.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>||q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span> q == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            q != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; p.val == q.val</span><br><span class="line">            &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">            &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-广度优先搜索"><a href="#2-广度优先搜索" class="headerlink" title="2.广度优先搜索"></a>2.广度优先搜索</h1><p><a href="https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/</a></p>
<blockquote>
<p>使用两个队列分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。</p>
<p>比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；</p>
<p>如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；</p>
<p>如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。</p>
<p>如果搜索结束时两个队列同时为空，则两个二叉树相同。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。</p>
</blockquote>
<p>使用队列，循环直到有一个或者两个队列为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>^q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; pQue,qQue;</span><br><span class="line">        pQue.push(p);</span><br><span class="line">        qQue.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!pQue.empty()&amp;&amp;!qQue.empty())&#123;</span><br><span class="line">            TreeNode* pTop = pQue.front(), *qTop = qQue.front();</span><br><span class="line">            pQue.pop(); qQue.pop();</span><br><span class="line">            <span class="comment">//如果两个值相同，下一步</span></span><br><span class="line">            <span class="comment">//不相同，false</span></span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;val!=qTop-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//左右子树，不全为null的，false</span></span><br><span class="line">            <span class="comment">//全为null下一步</span></span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;left==<span class="literal">nullptr</span>^qTop-&gt;left==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;right==<span class="literal">nullptr</span>^qTop-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//左右子树，全不是null的，分别推入队列</span></span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;left&amp;&amp;qTop-&gt;left)&#123;</span><br><span class="line">                pQue.push(pTop-&gt;left);</span><br><span class="line">                qQue.push(qTop-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pTop-&gt;right&amp;&amp;qTop-&gt;right)&#123;</span><br><span class="line">                pQue.push(pTop-&gt;right);</span><br><span class="line">                qQue.push(qTop-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pQue.empty()&amp;&amp;qQue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2020/08/02/leetcode21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[

<a id="more"></a>

<p>本题使用递归处理，具体流程可以参考：</p>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/</a></p>
<p><strong>时间复杂度：</strong>$O(m+n)$</p>
<blockquote>
<p>给出一个递归算法，其时间复杂度 ${\mathcal{O}(T)}$ 通常是递归调用的数量（记作 ${R}$） 和计算的时间复杂度的乘积（表示为 ${\mathcal{O}(s)})$的乘积：${\mathcal{O}(T) = R * \mathcal{O}(s)}O(T)=R∗O(s)$</p>
</blockquote>
<p>设n，m为两个链表的长度。本题的递归调用数量，最坏情况下为$O(m+n)$，每次计算需要耗费$O(1)$的时间。所以空间复杂度为$O(m+n)$</p>
<p><strong>空间复杂度：</strong>$O(m+n)$</p>
<p>在递归结束前，已经调用了$O(m+n)$次该函数，所以也调用了那么多的栈帧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode215：数组中的第K个最大元素</title>
    <url>/2020/08/09/leetcode215%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h1><p>调用priority_queue，要注意的是，默认为大顶堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a&gt;b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// auto cmp = [&amp;](const int&amp; a, const int&amp; b)&#123;</span></span><br><span class="line">        <span class="comment">//     return a&gt;b;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">// priority_queue&lt;int, vector&lt;int&gt;,decltype(cpm)&gt; que(cmp);</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            que.push(INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top=que.top();</span><br><span class="line">            <span class="keyword">if</span>(top&lt;nums[i])&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">                que.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>手写：</p>
<h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h1>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>topN</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode230：二叉搜索树中第k个小的元素</title>
    <url>/2020/08/08/leetcode230%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<img src="/2020/08/08/leetcode230%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/1596900100511.png" class="" width="1596900100511">

<a id="more"></a>

<h1 id="1-中序遍历递归"><a href="#1-中序遍历递归" class="headerlink" title="1.中序遍历递归"></a>1.中序遍历递归</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> kth;</span><br><span class="line">        findKth(root,k, kth);</span><br><span class="line">        <span class="keyword">return</span> kth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findKth</span><span class="params">(TreeNode*root, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span>&amp; kth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        findKth(root-&gt;left,k,kth);</span><br><span class="line">        <span class="keyword">if</span>(--k==<span class="number">0</span>) kth = root-&gt;val;</span><br><span class="line">        findKth(root-&gt;right,k,kth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-中序遍历迭代"><a href="#2-中序遍历迭代" class="headerlink" title="2.中序遍历迭代"></a>2.中序遍历迭代</h1><p>注意<code>root=stack.top();</code>不要写错，即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=<span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">//=======操作=============</span></span><br><span class="line">            <span class="keyword">if</span>(--k==<span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="comment">//=========================</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-中序遍历morris"><a href="#3-中序遍历morris" class="headerlink" title="3.中序遍历morris"></a>3.中序遍历morris</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root, *prev = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//========操作============</span></span><br><span class="line">                <span class="keyword">if</span>(--k==<span class="number">0</span>) <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">                <span class="comment">//=======================</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;right)&#123;</span><br><span class="line">                    prev=prev-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                prev-&gt;right=cur;</span><br><span class="line">                TreeNode* tmp = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                tmp-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode3：无重复字符的最长子串</title>
    <url>/2020/08/06/leetcode3%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<img src="/2020/08/06/leetcode3%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/1596712159058.png" class="" width="1596712159058">

<a id="more"></a>

<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/</a></p>
<p>滑动窗口问题要注意空集。</p>
<ul>
<li><code>int[26]</code> for Letters ‘a’ - ‘z’ or ‘A’ - ‘Z’</li>
<li><code>int[128]</code> for ASCII</li>
<li><code>int[256]</code> for Extended ASCII</li>
</ul>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><blockquote>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(2n) = O(n). In the worst case each character will be visited twice by i and j.</li>
<li>Space complexity : O(min(m, n)). Same as the previous approach. We need O(k)space for the sliding window, where k is the size of the <code>Set</code>. The size of the Set is upper bounded by the size of the string n and the size of the charset/alphabet m.</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = INT_MIN,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dic[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dic,<span class="number">0</span>,<span class="keyword">sizeof</span>(dic));</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//如果下一个字符的不存在集合里</span></span><br><span class="line">            <span class="keyword">if</span>(!dic[s[r]])&#123;</span><br><span class="line">                dic[s[r++]]++;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen,r-l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果下一个字符存在集合里</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dic[s[l++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hashmap[<span class="number">130</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">//双指针滑动窗口</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//当前判断是否重复的串为s[i..j]</span></span><br><span class="line">        hashmap[s[j]]++;</span><br><span class="line">        <span class="keyword">while</span>(hashmap[s[j]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            hashmap[s[i++]]--;  <span class="comment">//i指针右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;<span class="built_in">max</span>)</span><br><span class="line">            <span class="built_in">max</span> = j-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2、优化的滑动窗口"><a href="#2、优化的滑动窗口" class="headerlink" title="2、优化的滑动窗口"></a>2、优化的滑动窗口</h1><blockquote>
<p>The reason is that if $s[j]$ have a duplicate in the range $[i, j)$ with index $j’$, we don’t need to increase ii little by little. We can skip all the elements in the range $[i,j′] $and let $i$ to be $j’ + 1$directly.</p>
</blockquote>
<blockquote>
<ul>
<li>Time complexity : O(n). Index j will iterate n times.</li>
<li>Space complexity (HashMap) : O(min(m, n)). Same as the previous approach.</li>
<li>Space complexity (Table): O(m). mm is the size of the charset.</li>
</ul>
</blockquote>
<blockquote>
<p>the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">     <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">         <span class="keyword">if</span> (map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">             j = Math.max(j,map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         map.put(s.charAt(i),i);</span><br><span class="line">         max = Math.max(max,i-j+<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> max;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-另一种滑动窗口"><a href="#3-另一种滑动窗口" class="headerlink" title="3.另一种滑动窗口"></a>3.另一种滑动窗口</h1><blockquote>
<p>我们不妨以示例一中的字符串 \texttt{abcabcbb}abcabcbb 为例，找出 从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<p>$以 \texttt{(a)bcabcbb} 开始的最长字符串为 \texttt{(abc)abcbb}；\<br>以 \texttt{a(b)cabcbb} 开始的最长字符串为 \texttt{a(bca)bcbb}；\<br>以 \texttt{ab(c)abcbb} 开始的最长字符串为 \texttt{ab(cab)cbb}；\<br>以 \texttt{abc(a)bcbb} 开始的最长字符串为 \texttt{abc(abc)bb}；\<br>以 \texttt{abca(b)cbb} 开始的最长字符串为 \texttt{abca(bc)bb}；\<br>以 \texttt{abcab(c)bb} 开始的最长字符串为 \texttt{abcab(cb)b}；\<br>以 \texttt{abcabc(b)b} 开始的最长字符串为 \texttt{abcabc(b)b}；\<br>以 \texttt{abcabcb(b)} 开始的最长字符串为 \texttt{abcabcb(b)}。$<br>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 $r_k$ 。那么当我们选择第 k+1个字符作为起始位置时，首先从 k+1 到 $r_k$<br>的字符显然是不重复的，并且由于少了原本的第 k个字符，我们可以尝试继续增大 r_kr，直到右侧出现了重复字符为止。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = INT_MIN,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dic[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dic,<span class="number">0</span>,<span class="keyword">sizeof</span>(dic));</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;s.<span class="built_in">size</span>();l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l) dic[s[l<span class="number">-1</span>]]--;</span><br><span class="line">            <span class="keyword">while</span>(dic[s[r]]==<span class="number">0</span>&amp;&amp;r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen,r-l+<span class="number">1</span>);</span><br><span class="line">                dic[s[r]]++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode53：最大子序和</title>
    <url>/2020/08/06/leetcode53%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<img src="/2020/08/06/leetcode53%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/1596702245700.png" class="" width="1596702245700">

<a id="more"></a>

<p><a href="https://blog.csdn.net/zwzsdy/article/details/80029796" target="_blank" rel="noopener">https://blog.csdn.net/zwzsdy/article/details/80029796</a></p>
<h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h1><blockquote>
<p>设sum[i]为<strong>以第i个元素结尾且和最大</strong>的连续子数组。假设对于元素i，所有以它前面的元素结尾的子数组的长度都已经求得，那么以第i个元素结尾且和最大的连续子数组实际上，要么是以第i-1个元素结尾且和最大的连续子数组加上这个元素，要么是只包含第i个元素，即sum[i]<br>= max(sum[i-1] + a[i], a[i])。可以通过<strong>判断sum[i-1] + a[i]是否大于a[i]来做选择</strong>，而这实际上等价于判断<strong>sum[i-1]是否大于0</strong>。由于每次运算只需要前一次的结果，因此并不需要像普通的动态规划那样保留之前所有的计算结果，只需要保留上一次的即可，因此算法的时间和空间复杂度都很小</p>
</blockquote>
<img src="/2020/08/06/leetcode53%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/1596701867094.png" class="" width="1596701867094">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre_sum=<span class="number">0</span>;<span class="comment">//sum用0初始化</span></span><br><span class="line">        <span class="keyword">int</span> maxRes = INT_MIN;<span class="comment">//求最大用最小值初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur:nums)&#123;</span><br><span class="line">            pre_sum = <span class="built_in">max</span>(pre_sum+cur,cur);</span><br><span class="line">            maxRes = <span class="built_in">max</span>(maxRes,pre_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-扫描法"><a href="#2-扫描法" class="headerlink" title="2.扫描法"></a>2.扫描法</h1><p>和动态规划差不多，如果之前的数字之和小于零，就抛弃前面的和；如果不小于零，就继续累加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>, maxSum=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; cur: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum&lt;<span class="number">0</span>) curSum=cur;</span><br><span class="line">            <span class="keyword">else</span> curSum+=cur;</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum,curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-分治法"><a href="#3-分治法" class="headerlink" title="3.分治法"></a>3.分治法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode76：最小覆盖子串</title>
    <url>/2020/08/03/leetcode76%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<img src="/2020/08/03/leetcode76%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/1596540796924.png" class="" width="1596540796924">

<p>要注意的是，这里的字符串可以有重复字符，比如”AABC”，A要计数两次。</p>
<a id="more"></a>

<h1 id="1-使用哈希表（慢）"><a href="#1-使用哈希表（慢）" class="headerlink" title="1.使用哈希表（慢）"></a>1.使用哈希表（慢）</h1><ol>
<li><p>要考虑两者之一为空串时，返回空串</p>
</li>
<li><p>同时当S=”a”,T=”aa”时，返回空串</p>
</li>
<li><p>当S=“ab”，T=“a”时候，要考虑到T为单个字符</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt,t_cnt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p: t_cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[p.first]&lt;p.second) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>||t==<span class="string">""</span>||s.<span class="built_in">size</span>()&lt;t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//左指针，右指针，最小子字符的长度，结果的左指针</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>,min_len=INT_MAX,res_left=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计T的每个字符个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c:t)&#123;</span><br><span class="line">            t_cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左指针移动</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;<span class="keyword">int</span>(s.<span class="built_in">size</span>()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(t_cnt.<span class="built_in">find</span>(s[right])!=t_cnt.<span class="built_in">end</span>())&#123;</span><br><span class="line">                cnt[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//右指针移动</span></span><br><span class="line">            <span class="keyword">while</span>(check() &amp;&amp; left&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min_len&gt;right-left)&#123;</span><br><span class="line">                    res_left = left;</span><br><span class="line">                    min_len=right-left;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(t_cnt.<span class="built_in">find</span>(s[left])!=t_cnt.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    cnt[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右指针没移动，则返回空串，比如S=“ab”，T=“a”</span></span><br><span class="line">        <span class="keyword">if</span>(min_len==INT_MAX) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substr(res_left,min_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-使用数组"><a href="#2-使用数组" class="headerlink" title="2.使用数组"></a>2.使用数组</h1><p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: O(|S| + |T|)O(∣S∣+∣T∣) where |S| and |T| represent the lengths of strings SS and TT. In the worst case we might end up visiting every element of string SS twice, once by left pointer and once by right pointer. |T|∣T∣ represents the length of string TT.</li>
<li>Space Complexity: O(|S| + |T|)O(∣S∣+∣T∣). |S|∣S∣ when the window size is equal to the entire string SS. |T|∣T∣ when TT has all unique characters.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dic[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dic,<span class="number">0</span>,<span class="keyword">sizeof</span>(dic));</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,minLen=INT_MAX,minL=<span class="number">0</span>,remaining=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:t)&#123;</span><br><span class="line">            dic[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//右指针向右</span></span><br><span class="line">            <span class="comment">//非t的字符，此时变为负数</span></span><br><span class="line">            <span class="keyword">if</span>(--dic[s[r++]]&gt;=<span class="number">0</span>) remaining--;</span><br><span class="line">            <span class="keyword">while</span>(remaining==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-l&lt;minLen) &#123;</span><br><span class="line">                    minL=l;</span><br><span class="line">                    minLen=r-l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左指针向右</span></span><br><span class="line">                <span class="comment">//属于t的字符，此时才会大于0</span></span><br><span class="line">                <span class="keyword">if</span>(++dic[s[l++]]&gt;<span class="number">0</span>) remaining++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX?s.substr(minL,minLen):<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode7：整数翻转</title>
    <url>/2020/08/06/leetcode7%EF%BC%9A%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/</url>
    <content><![CDATA[<img src="/2020/08/06/leetcode7%EF%BC%9A%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/1596699696045.png" class="" width="1596699696045">

<a id="more"></a>

<img src="/2020/08/06/leetcode7%EF%BC%9A%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/1596699677897.png" class="" width="1596699677897">

<h1 id="1-手算"><a href="#1-手算" class="headerlink" title="1.手算"></a>1.手算</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev&gt;INT_MAX/<span class="number">10</span>||(rev==INT_MAX/<span class="number">10</span>&amp;&amp;pop&gt;<span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev&lt;INT_MIN/<span class="number">10</span>||(rev==INT_MIN/<span class="number">10</span>&amp;&amp;pop&lt;<span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev*<span class="number">10</span>+pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-代码算"><a href="#2-代码算" class="headerlink" title="2.代码算"></a>2.代码算</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev &gt; Integer.MAX_VALUE / <span class="number">10</span> || (rev == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>))&#123;</span><br><span class="line">                rev = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rev &lt; Integer.MIN_VALUE / <span class="number">10</span> || (rev == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; x &lt; Integer.MIN_VALUE % <span class="number">10</span>))&#123;</span><br><span class="line">                rev = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode94：二叉树的中序遍历-binarytree-inorder-traversal</title>
    <url>/2020/08/08/leetcode94%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-binarytree-inorder-traversal/</url>
    <content><![CDATA[<img src="/2020/08/08/leetcode94%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-binarytree-inorder-traversal/1596841508109.png" class="" width="1596841508109">

<a id="more"></a>

<h1 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h1><ul>
<li>Time complexity : O(n). The time complexity is O(n) because the recursive function is $T(n)=2⋅T(n/2)+1$.</li>
<li>Space complexity : The worst case space required is O(n), and in the average case it’s $O(\log n)$ where n is number of nodes.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root-&gt;left);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        inorderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h1><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/solution/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span> || !<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="comment">//左节点</span></span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//中间节点</span></span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            <span class="comment">//右节点</span></span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-morris法"><a href="#3-morris法" class="headerlink" title="3.morris法"></a>3.morris法</h1><h3 id="1-算法"><a href="#1-算法" class="headerlink" title="1.算法"></a>1.算法</h3><p>Step 1: Initialize current as root</p>
<p>Step 2: While current is not NULL,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If current does not have left child</span><br><span class="line"></span><br><span class="line">    a. Add current’s value</span><br><span class="line"></span><br><span class="line">    b. Go to the right, i.e., current &#x3D; current.right</span><br><span class="line"></span><br><span class="line">Else</span><br><span class="line"></span><br><span class="line">    a. In current&#39;s left subtree, make current the right child of the rightmost node</span><br><span class="line"></span><br><span class="line">    b. Go to this left child, i.e., current &#x3D; current.left</span><br></pre></td></tr></table></figure>

<p>cur用来表示当前节点，prev用来选取当前节点的左节点的右子树最右边节点</p>
<h3 id="2-图形"><a href="#2-图形" class="headerlink" title="2.图形"></a>2.图形</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     3</span><br><span class="line"> &#x2F; \   &#x2F;</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>

<p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current’s left subtree is</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = cuurent.left (current = 2). The tree now looks like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       &#x2F;</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<p>For current 2, which has left child 4, we can continue with thesame process as we did above</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       &#x2F;</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* prev=root, *cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="comment">//如果cur有左节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//cur的左节点中的 右子树中的 最右边的节点</span></span><br><span class="line">                prev = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;right)&#123;</span><br><span class="line">                    prev=prev-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cur移动到该节点右边</span></span><br><span class="line">                prev-&gt;right = cur;</span><br><span class="line">                TreeNode* tmp =cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                tmp-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果cur没有左节点</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//node操作</span></span><br><span class="line">                <span class="comment">//======================</span></span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                <span class="comment">//======================</span></span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-复杂度"><a href="#4-复杂度" class="headerlink" title="4.复杂度"></a>4.复杂度</h3><ul>
<li>Time complexity : O(n). To prove that the time complexity is O(n), the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is O(nlogn), because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs O(n) time. <strong>Because a binary Tree with n nodes has n−1 edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is O(n).</strong></li>
<li>Space complexity : O(n). Arraylist of size n is used.</li>
</ul>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode98：验证二叉树-BST-validation</title>
    <url>/2020/08/08/leetcode98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91-BFS-validation/</url>
    <content><![CDATA[<img src="/2020/08/08/leetcode98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91-BFS-validation/1596833289221.png" class="" width="1596833289221">

<a id="more"></a>

<h1 id="1-中序遍历（递归）"><a href="#1-中序遍历（递归）" class="headerlink" title="1.中序遍历（递归）"></a>1.中序遍历（递归）</h1><p>二叉搜索树（binary search tree），如果按照中序遍历的话，就会得到一个从小到大排列的数组。那么只要检验当前节点的值是否比上一个节点小。如果全部符合就是一个BST，否则就不是。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//left node</span></span><br><span class="line">        <span class="keyword">bool</span> leftVal = isValidBST(root-&gt;left);</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//right node</span></span><br><span class="line">        <span class="keyword">bool</span> rightVal = isValidBST(root-&gt;right);</span><br><span class="line">        <span class="comment">//左节点和右节点，只要有一个不能用返回false，如果都能用就是true</span></span><br><span class="line">        <span class="keyword">return</span> leftVal&amp;&amp;rightVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种写法，一般来说if中含有return，就是一种筛选的情况，不返回的话，下面的语句都要在一种筛选的情况后运行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//只要左节点不符合就直接返回false</span></span><br><span class="line">        <span class="comment">//如果左节点符合就继续判断，看右节点是否符合</span></span><br><span class="line">        <span class="comment">//所以这里不能写成return isValidBST()</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//左节点已经验证过，此时右节点必须为true</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h1><p>The idea above could be implemented as a recursion. One compares the node value with its upper and lower limits if they are available. Then one repeats the same step recursively for left and right subtrees.</p>
<ul>
<li>Time complexity : $\mathcal{O}(N)$ since we visit each node exactly once.</li>
<li>Space complexity : $\mathcal{O}(N)$ since we keep up to the entire tree.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* <span class="built_in">min</span>, TreeNode* <span class="built_in">max</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//左子树比前一个节点大，return false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span> !=<span class="literal">NULL</span> &amp;&amp; root-&gt;val &gt;= <span class="built_in">max</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//右子树比父节点小，return false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> !=<span class="literal">NULL</span> &amp;&amp; root-&gt;val &lt;= <span class="built_in">min</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left,<span class="built_in">min</span>,root)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;right,root,<span class="built_in">max</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>简化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* <span class="built_in">min</span>=<span class="literal">NULL</span>, TreeNode* <span class="built_in">max</span> = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>!=<span class="literal">NULL</span>&amp;&amp;root-&gt;val &gt;= <span class="built_in">max</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>!=<span class="literal">NULL</span>&amp;&amp;root-&gt;val &lt;= <span class="built_in">min</span>-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left,<span class="built_in">min</span>,root)&amp;&amp;isValidBST(root-&gt;right,root,<span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-中序遍历（迭代）"><a href="#3-中序遍历（迭代）" class="headerlink" title="3.中序遍历（迭代）"></a>3.中序遍历（迭代）</h1><img src="/2020/08/08/leetcode98%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91-BFS-validation/145_transverse.png" class="" title="postorder">

<ul>
<li>Time complexity : $O(N)$ in the worst case when the tree is BST or the “bad” element is a rightmost leaf.</li>
<li>Space complexity : $O(N)$ to keep <code>stack</code>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">long</span> prev=LONG_MIN;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span> || !<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="comment">//left node</span></span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//inner node</span></span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(prev&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            prev = root-&gt;val;</span><br><span class="line">            <span class="comment">//right node</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>tree</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode总结</title>
    <url>/2020/08/08/leetcode%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>leetcode刷题总结</p>
<a id="more"></a>

<h1 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h1><p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa</a></p>
<p>数据结构基本都是由<strong>链表</strong>和<strong>数组</strong>构成的。算法基本都是为了实现增删改查。</p>
<p>其中链表访问速度慢，但修改速度快。数组的访问速度快，但修改速度慢（插入、删除）。</p>
<p>二叉树的访问：前序、中序、后续</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历的root操作在这里</span></span><br><span class="line">    method(root-&gt;left);</span><br><span class="line">    <span class="comment">//中序遍历的root操作在这里</span></span><br><span class="line">    right(root-&gt;right);</span><br><span class="line">    <span class="comment">//后序遍历的root操作在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method(root-&gt;n1);</span><br><span class="line">    method(root-&gt;n2);</span><br><span class="line">    ...</span><br><span class="line">    method(root-&gt;nn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-自己小结"><a href="#2-自己小结" class="headerlink" title="2.自己小结"></a>2.自己小结</h1><h3 id="1-if和return"><a href="#1-if和return" class="headerlink" title="1.if和return"></a>1.if和return</h3><p>一般来说if中含有return，就是一种筛选的情况，不返回的话，下面的语句都要在一种筛选的情况后运行。</p>
<p>比如：leetcode.98</p>
<p>一下两种情况相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//只要左节点不符合就直接返回false</span></span><br><span class="line">        <span class="comment">//如果左节点符合就继续判断，看右节点是否符合</span></span><br><span class="line">        <span class="comment">//所以这里不能写成return isValidBST()</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//左节点已经验证过，此时右节点必须为true</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//left node</span></span><br><span class="line">        <span class="keyword">bool</span> leftVal = isValidBST(root-&gt;left);</span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="comment">//right node</span></span><br><span class="line">        <span class="keyword">bool</span> rightVal = isValidBST(root-&gt;right);</span><br><span class="line">        <span class="comment">//左节点和右节点，只要有一个不能用返回false，如果都能用就是true</span></span><br><span class="line">        <span class="keyword">return</span> leftVal&amp;&amp;rightVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-树"><a href="#3-树" class="headerlink" title="3.树"></a>3.树</h1><p><a href="https://www.cnblogs.com/bigsai/p/11393609.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigsai/p/11393609.html</a></p>
<p><a href="https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/</a></p>
<h3 id="1-几种遍历"><a href="#1-几种遍历" class="headerlink" title="1.几种遍历"></a>1.几种遍历</h3><p>前序遍历</p>
<img src="/2020/08/08/leetcode%E6%80%BB%E7%BB%93/20190820000853382.png" class="" title="在这里插入图片描述">

<p>中序遍历</p>
<img src="/2020/08/08/leetcode%E6%80%BB%E7%BB%93/1596820407921.png" class="" width="1596820407921">

<p>后序遍历（遍历二叉搜索树得到升序BST）</p>
<img src="/2020/08/08/leetcode%E6%80%BB%E7%BB%93/1596820593086.png" class="" width="1596820593086">

<img src="/2020/08/08/leetcode%E6%80%BB%E7%BB%93/145_transverse.png" class="" title="postorder">

<h3 id="2-BST"><a href="#2-BST" class="headerlink" title="2.BST"></a>2.BST</h3><p><a href="https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/</a></p>
<h3 id="3-inorder-iteration"><a href="#3-inorder-iteration" class="headerlink" title="3. inorder iteration"></a>3. inorder iteration</h3><p><a href="https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        Stack &lt; TreeNode &gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">//=========节点操作============</span></span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            <span class="comment">//============================</span></span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-morris"><a href="#4-morris" class="headerlink" title="4. morris"></a>4. morris</h3><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/solution/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        TreeNode pre;</span><br><span class="line">        <span class="keyword">while</span> (curr != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.left == null) &#123;</span><br><span class="line">                <span class="comment">//=======节点操作=========</span></span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                <span class="comment">//========================</span></span><br><span class="line">                curr = curr.right; <span class="comment">// move to next right node</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// has a left subtree</span></span><br><span class="line">                pre = curr.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != null) &#123; <span class="comment">// find rightmost</span></span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.right = curr; <span class="comment">// put cur after the pre node</span></span><br><span class="line">                TreeNode temp = curr; <span class="comment">// store cur node</span></span><br><span class="line">                curr = curr.left; <span class="comment">// move cur to the top of the new tree</span></span><br><span class="line">                temp.left = null; <span class="comment">// original cur left be null, avoid infinite loops</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-数组、链表"><a href="#4-数组、链表" class="headerlink" title="4.数组、链表"></a>4.数组、链表</h1><h3 id="1-top-n"><a href="#1-top-n" class="headerlink" title="1.top-n"></a>1.top-n</h3><h3 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h3><h1 id="5-回溯法"><a href="#5-回溯法" class="headerlink" title="5.回溯法"></a>5.回溯法</h1><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6.动态规划"></a>6.动态规划</h1><p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie</a></p>
<h3 id="1-通识"><a href="#1-通识" class="headerlink" title="1.通识"></a>1.通识</h3><p>动态规划基本要素：<strong>重叠子问题，最优子结构，状态转移方程</strong>。</p>
<p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p>
<p><strong>重叠子问题：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上使用备忘录，就能解决重叠子问题，省去很多的重复操作，此时时间复杂度也就变成了O(n)</p>
<img src="/2020/08/08/leetcode%E6%80%BB%E7%BB%93/2.jpg" class="" title="img">

<p>也可以使用<strong>table</strong>来记录并进行进一步修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>||N==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">table</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        table[<span class="number">1</span>] = <span class="number">1</span>;table[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            table[i] = table[i<span class="number">-1</span>]+table[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过因为斐波那契的每个状态只和上两个状态有关，就可以进行<strong>状态压缩</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-递归"><a href="#7-递归" class="headerlink" title="7.递归"></a>7.递归</h1><h3 id="1-通识-1"><a href="#1-通识-1" class="headerlink" title="1.通识"></a>1.通识</h3><p>解决递归问题时，最好画递归树，比如斐波那契问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>)+f(n+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<img src="/2020/08/08/leetcode%E6%80%BB%E7%BB%93/1.jpg" class="" title="img">

<p>这里是想求f(20)，那么求f（20）就要解决f(19)和f(18)这两个问题，以此类推，直到终止条件。递归树也就数画了出来。</p>
<h3 id="2-复杂度计算"><a href="#2-复杂度计算" class="headerlink" title="2.复杂度计算"></a>2.复杂度计算</h3><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法极其低效。</p>
]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题：最小区间</title>
    <url>/2020/08/02/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<img src="/2020/08/02/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596366784500.png" class="" width="1596366784500">

<a id="more"></a>

<h1 id="1-最小堆"><a href="#1-最小堆" class="headerlink" title="1.最小堆"></a>1.最小堆</h1><p>解说可以参考：<a href="https://leetcode.com/articles/smallest-range/" target="_blank" rel="noopener">https://leetcode.com/articles/smallest-range/</a></p>
<p>代码可以参考：<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/solution/zui-xiao-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/solution/zui-xiao-qu-jian-by-leetcode-solution/</a></p>
<p>本题的本质就是在每个链表中选择一个数，使得这一组数的最大值减去最小值最小。也就是一个合并链表考虑的问题，将链表”展开“。</p>
<p><strong>红框表示目前堆的最小值在哪</strong></p>
<img src="/2020/08/02/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596367211146.png" class="" width="1596367211146">

<ol>
<li><p>next全为0</p>
</li>
<li><p>将每个链表的第一个元素放入最小堆中，堆顶元素也就是堆中的最小值。同时将堆中的最大值保存。</p>
</li>
<li><p>要想缩小区间有两种方法：增加最小值，减小最大值。</p>
</li>
<li><p>这里的最大值无法减小，所以就选择增加最小值。</p>
</li>
<li><p>然后将next值更新，将最小值的下一个元素放入堆中，重新堆排序。然后找更新后的堆的最小值，如此反复。</p>
<img src="/2020/08/02/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596367489520.png" class="" width="1596367489520">
</li>
<li><p>直到某一个链表的元素全部被遍历完，那么目前的最小值无法进行扩大，流程结束。</p>
<img src="/2020/08/02/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/1596367566755.png" class="" width="1596367566755">

</li>
</ol>
<p><strong>时间复杂度</strong>：$O(nk \log k)$，n为所有列表的平均长度，k为列表的个数，遍历每个列表的每一个格需要$O(nk)$的时间。同时每次的遍历要处理有k个节点的最小堆，需要$O(logk)$</p>
<p><strong>空间复杂度</strong>：$O(k)$，空间复杂度取决于堆的节点个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最终结果的边界，边界在不断缩小，所以初始化范围要大</span></span><br><span class="line">        <span class="keyword">int</span> rangeLeft = <span class="number">0</span>, rangeRight = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//next记录每一行的指向的列，定位到数值</span></span><br><span class="line">        <span class="comment">//此处初始化为0</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[a][next[a]] &gt; nums[b][next[b]];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//que记录当前最小值在哪一行</span></span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; que(cmp);</span><br><span class="line">        <span class="comment">//每次循环变化的边界，max在不断变大，所以max初始化要小</span></span><br><span class="line">        <span class="keyword">int</span> min_val = <span class="number">0</span>,max_val = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">            que.emplace(i);</span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val,nums[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//取出最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> row = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            min_val = nums[row][next[row]];</span><br><span class="line">            <span class="keyword">if</span>(max_val-min_val&lt;rangeRight-rangeLeft)&#123;</span><br><span class="line">                rangeLeft=min_val;</span><br><span class="line">                rangeRight=max_val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有一个链表遍历完了，就终止循环</span></span><br><span class="line">            <span class="keyword">if</span>(next[row]==nums[row].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next[row]++;</span><br><span class="line">            que.emplace(row);</span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val,nums[row][next[row]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;rangeLeft, rangeRight&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些操作：</p>
<p>emplace：<a href="https://blog.csdn.net/weixin_43892298/article/details/105733034" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43892298/article/details/105733034</a></p>
<p>[&amp;] lambda表达式：<a href="https://www.jianshu.com/p/6482fbd3abdf" target="_blank" rel="noopener">https://www.jianshu.com/p/6482fbd3abdf</a></p>
<h1 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h1>]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>slide window</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日练习：字符串相加</title>
    <url>/2020/08/03/leetcode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<img src="/2020/08/03/leetcode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/1596398440298.png" class="" width="1596398440298">

<a id="more"></a>

<h1 id="1-自己"><a href="#1-自己" class="headerlink" title="1.自己"></a>1.自己</h1><p>%取个位，/取十位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        short carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先翻转字符串</span></span><br><span class="line">        reverse(num1.<span class="built_in">begin</span>(),num1.<span class="built_in">end</span>());</span><br><span class="line">        reverse(num2.<span class="built_in">begin</span>(),num2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//补0</span></span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="built_in">size</span>()&gt;num2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=num2.<span class="built_in">size</span>();i&lt;num1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                num2+=<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="built_in">size</span>()&lt;num2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=num1.<span class="built_in">size</span>();i&lt;num2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                num1+=<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpRes = num1[i]-<span class="string">'0'</span>+num2[i]-<span class="string">'0'</span>+carry;</span><br><span class="line">            res+=<span class="keyword">char</span>(tmpRes%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">            carry= (tmpRes&lt;<span class="number">10</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一位进位判定</span></span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            res+=<span class="string">"1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转结果</span></span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-改进"><a href="#2-改进" class="headerlink" title="2.改进"></a>2.改进</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpRes=<span class="number">0</span>, i = num1.<span class="built_in">size</span>()<span class="number">-1</span>, j = num2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmpRes&gt;<span class="number">0</span>||i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//这个位置上有数字，就加上去</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) tmpRes+=num1[i--]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) tmpRes+=num2[j--]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//最终结果加上临时结果的个位</span></span><br><span class="line">            res+=to_string(tmpRes%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//保留临时结果十分位（进位）</span></span><br><span class="line">            tmpRes/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日题目：魔术索引</title>
    <url>/2020/07/31/leetcode%E6%AF%8F%E6%97%A5%E9%A2%98%E7%9B%AE%EF%BC%9A%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>leetcode：二叉树展开为链表</title>
    <url>/2020/08/02/leetcode%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<img src="/2020/08/02/leetcode%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/1596378927495.png" class="" width="1596378927495">

<a id="more"></a>

<h1 id="1-前序遍历（不是原地）"><a href="#1-前序遍历（不是原地）" class="headerlink" title="1.前序遍历（不是原地）"></a>1.前序遍历（不是原地）</h1><p>要注意的是，存在<strong>空节点</strong>或者<strong>只有一个节点</strong>的可能。不考虑的话会报错：out-of-range。</p>
<p>另外题目要求原地（in-place）展开，也就是要求<strong>空间复杂度</strong>为$O(1)$，而这种方法不符合规定。</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="comment">//前序遍历，展开成vector</span></span><br><span class="line">        pre_trav(root, <span class="built_in">list</span>);</span><br><span class="line">        <span class="comment">//考虑空树和单节点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将vector内的指正串会树状图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            TreeNode* prev=<span class="built_in">list</span>.at(i), *cur=<span class="built_in">list</span>.at(i+<span class="number">1</span>);</span><br><span class="line">            prev-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right=cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_trav</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="built_in">list</span>.push_back(root);</span><br><span class="line">            pre_trav(root-&gt;left,<span class="built_in">list</span>);</span><br><span class="line">            pre_trav(root-&gt;right,<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     void flatten(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">//         vector&lt;TreeNode*&gt; l;</span></span><br><span class="line"><span class="comment">//         preorderTraversal(root, l);</span></span><br><span class="line"><span class="comment">//         int n = l.size();</span></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//             TreeNode *prev = l.at(i - 1), *curr = l.at(i);</span></span><br><span class="line"><span class="comment">//             prev-&gt;left = nullptr;</span></span><br><span class="line"><span class="comment">//             prev-&gt;right = curr;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     void preorderTraversal(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) &#123;</span></span><br><span class="line"><span class="comment">//         if (root != NULL) &#123;</span></span><br><span class="line"><span class="comment">//             l.push_back(root);</span></span><br><span class="line"><span class="comment">//             preorderTraversal(root-&gt;left, l);</span></span><br><span class="line"><span class="comment">//             preorderTraversal(root-&gt;right, l);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-先序遍历-前驱节点"><a href="#2-先序遍历-前驱节点" class="headerlink" title="2.先序遍历(前驱节点)"></a>2.先序遍历(前驱节点)</h1><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/</a></p>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 1 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"><span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">//将 2 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">作者：windliang</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>具体过程如下：</p>
<ol>
<li>找出左子树的最右边的节点</li>
<li>将右子树移到左子树最右边节点的右边</li>
<li>将左子树移动到当前节点的右边</li>
<li>当前节点的左边清空</li>
<li>当前指针指向右边的节点，知道当前指针为空</li>
</ol>
<p><strong>时间复杂度</strong>：$O(log(n))$，n为所有节点的个数</p>
<p><strong>空间复杂度</strong>：$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* curNode = root;</span><br><span class="line">        <span class="comment">//当前节点不为空才继续</span></span><br><span class="line">        <span class="keyword">while</span>(curNode)&#123;</span><br><span class="line">            <span class="comment">//当前节点有左子树，才继续</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//左子树中最右边的节点</span></span><br><span class="line">                TreeNode* leftRightMost = curNode-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(leftRightMost-&gt;right)&#123;</span><br><span class="line">                    leftRightMost = leftRightMost-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                leftRightMost-&gt;right = curNode-&gt;right;</span><br><span class="line">                curNode-&gt;right = curNode-&gt;left;</span><br><span class="line">                curNode-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-前序遍历-展开"><a href="#3-前序遍历-展开" class="headerlink" title="3.前序遍历+展开"></a>3.前序遍历+展开</h1><p>这里其实就是前序遍历的时候，将每个遍历到的节点使用一个栈保存下来</p>
<blockquote>
<p>修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则依次将右子节点和左子节点压入栈内（注意入栈顺序）。</p>
<p>展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(root);</span><br><span class="line">        TreeNode* curr=<span class="literal">nullptr</span>, *prev=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            curr = <span class="built_in">stack</span>.top(); <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(prev!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">                prev-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *left = curr-&gt;left, *right=curr-&gt;right;</span><br><span class="line">            <span class="comment">//右先入栈，后出栈</span></span><br><span class="line">            <span class="keyword">if</span>(right!=<span class="literal">nullptr</span>) <span class="built_in">stack</span>.push(right);</span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="literal">nullptr</span>) <span class="built_in">stack</span>.push(left);</span><br><span class="line">            prev=curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>acm</tag>
        <tag>leetcode</tag>
        <tag>binary tree</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch+anoconda+pycharm安装</title>
    <url>/2020/07/05/pytorchSet/</url>
    <content><![CDATA[<p>pytorch+anoconda+pycharm安装</p>
<a id="more"></a>

<h1 id="anoconda安装"><a href="#anoconda安装" class="headerlink" title="anoconda安装"></a>anoconda安装</h1><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2.命令"></a>2.命令</h3><ol>
<li><p>创建虚拟空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n nlp python&#x3D;3.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove -n nlp --all</span><br></pre></td></tr></table></figure>
</li>
<li><p>将镜像源恢复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda activate nlp</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看安装列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看已有虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda-env list</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="2-Cuda"><a href="#2-Cuda" class="headerlink" title="2.Cuda"></a>2.Cuda</h1><p><a href="https://blog.csdn.net/weixin_44455154/article/details/105322330?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44455154/article/details/105322330?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase</a></p>
<p>pytorch的cuda支持版本一定要和已有cuda版本对应</p>
<h3 id="1-查看显卡支持的cuda最高版本"><a href="#1-查看显卡支持的cuda最高版本" class="headerlink" title="1. 查看显卡支持的cuda最高版本"></a>1. 查看显卡支持的cuda最高版本</h3><p><a href="https://blog.csdn.net/qq_39499621/article/details/92801092" target="_blank" rel="noopener">https://blog.csdn.net/qq_39499621/article/details/92801092</a></p>
<img src="/2020/07/05/pytorchSet/20190508103705372.png" class="" title="img">

<h3 id="2-安装cuda"><a href="#2-安装cuda" class="headerlink" title="2.安装cuda"></a>2.安装cuda</h3><ol>
<li><p>cuda安装地址：<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit-archive</a></p>
</li>
<li><p>cuda安装选项</p>
<p>其中要保证本地已安装的driver components的版本高于cuda安装包中的版本</p>
<img src="/2020/07/05/pytorchSet/20170823095519479.png" class="" title="cuda 2">
</li>
<li><p>安装对应版本的cudnn</p>
<p><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></p>
<p>下载之后将文件解压并且复制到cuda的对应目录下</p>
</li>
<li><p>设置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机上点右键，打开属性-&gt;高级系统设置-&gt;环境变量，可以看到系统中多了CUDA_PATH和CUDA_PATH_V8_0两个环境变量，接下来，还要在系统中添加以下几个环境变量：</span><br><span class="line">CUDA_SDK_PATH &#x3D; C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0(这是默认安装位置的路径，经自定义路径后，我的路径为D:\NVIDIA\CUDA Samples)</span><br><span class="line">CUDA_LIB_PATH &#x3D; %CUDA_PATH%\lib\x64</span><br><span class="line">CUDA_BIN_PATH &#x3D; %CUDA_PATH%\bin</span><br><span class="line">CUDA_SDK_BIN_PATH &#x3D; %CUDA_SDK_PATH%\bin\win64</span><br><span class="line">CUDA_SDK_LIB_PATH &#x3D; %CUDA_SDK_PATH%\common\lib\x64</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在系统变量 PATH 的末尾添加：</span><br><span class="line">%CUDA_LIB_PATH%;%CUDA_BIN_PATH%;%CUDA_SDK_LIB_PATH%;%CUDA_SDK_BIN_PATH%;</span><br><span class="line">再添加如下4条（默认安装路径）：</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\lib\x64；</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\bin；</span><br><span class="line">C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0\common\lib\x64；</span><br><span class="line">C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0\bin\win64；</span><br></pre></td></tr></table></figure>
</li>
<li><p>检验安装</p>
<ol>
<li><pre><code>nvcc -V
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   2. 用CUDA内置的deviceQuery.exe 和 bandwithTest.exe：</span><br><span class="line">      首先win+R启动cmd，cd到安装目录下的 &#96;...\extras\demo_suite&#96;,然后分别执行&#96;bandwidthTest.exe&#96;和&#96;deviceQuery.exe&#96;</span><br><span class="line"></span><br><span class="line"># 3.安装pytorch</span><br><span class="line"></span><br><span class="line">清华镜像：&lt;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;pytorch&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">之后要使用&#96;&#96; conda install --offline&#96;&#96;命令进行安装</span><br><span class="line"></span><br><span class="line">pytorch的cuda对应版本要一直，cudnn版本高于pytorch的对应cudnn版本即可</span><br><span class="line"></span><br><span class="line">之后要安装一些必备包</span><br></pre></td></tr></table></figure>
conda install numpy mkl cffi pillow
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
conda install nb_conda
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">检验：</span><br></pre></td></tr></table></figure>
import torch
import torchvision</code></pre></li>
</ol>
</li>
</ol>
<h1 id="4-pycharm"><a href="#4-pycharm" class="headerlink" title="4. pycharm"></a>4. pycharm</h1><p>2019pro下载安装：<a href="https://www.52pojie.cn/thread-1111202-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1111202-1-1.html</a></p>
<p>setting-&gt;project-&gt;interpreter中选择pytorch虚拟目录下的python.exe，即可完成配置</p>
<h1 id="5-cuda的卸载"><a href="#5-cuda的卸载" class="headerlink" title="5.cuda的卸载"></a>5.cuda的卸载</h1><p><a href="https://www.zhihu.com/question/52174028" target="_blank" rel="noopener">https://www.zhihu.com/question/52174028</a></p>
<p>除了红框的都卸载</p>
<img src="/2020/07/05/pytorchSet/1593926686128.png" class="" width="1593926686128">

]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pytorch</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorchStarter</title>
    <url>/2020/07/06/pytorchStarter/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>unity_following_light</title>
    <url>/2020/07/27/unity-following-light/</url>
    <content><![CDATA[<p>简单的unity操作</p>
<a id="more"></a>

<hr>
<p>添加一个材质球，选择diffuse，然后将这个材质球赋给背景。在没有光源的条件下，背景就变黑了。</p>
<img src="/2020/07/27/unity-following-light/1595866821021.png" class="" width="1595866821021">

<p>如果想调整背景的明暗程度，在window-&gt;rendering-&gt;light setting中，更改ambient color（环境光）</p>
<img src="/2020/07/27/unity-following-light/1595866911162.png" class="" width="1595866911162">

<p>然后在人物下新建一个子文件的点光源，即可实现跟随</p>
<img src="/2020/07/27/unity-following-light/1595867006419.png" class="" width="1595867006419">

<p>但是光源在这个时候是不显示的，这是因为此时光源Z坐标为0，将其设置为-1，即可让光源到离摄像机更近的平面上，也就可以看见光源了。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>lights</tag>
      </tags>
  </entry>
  <entry>
    <title>vim_command</title>
    <url>/2020/06/09/vim-command/</url>
    <content><![CDATA[<img src="/2020/06/09/vim-command/66696-5bc30a92ae0f73a6.webp" class="" title="img">

<a id="more"></a>

<h1 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h1><p><a href="https://www.cnblogs.com/wayneliu007/p/10322453.html" target="_blank" rel="noopener">https://www.cnblogs.com/wayneliu007/p/10322453.html</a></p>
<h3 id="1-全匹配"><a href="#1-全匹配" class="headerlink" title="1. 全匹配"></a>1. 全匹配</h3><p>从上往下： /string</p>
<p>从下往上： ?string</p>
<h3 id="2-模糊匹配（正则表达式）"><a href="#2-模糊匹配（正则表达式）" class="headerlink" title="2. 模糊匹配（正则表达式）"></a>2. 模糊匹配（正则表达式）</h3><p>. ：通配一个字符, 匹配string 时/str..g</p>
<p>* : 通配多个字符, 匹配string 时/str*g</p>
<h3 id="3-其他查找"><a href="#3-其他查找" class="headerlink" title="3.其他查找"></a>3.其他查找</h3><ol>
<li>shift + *: 光标停留在要查的单词上时,快速选中单词, 通过n查找下一个单词</li>
</ol>
<h3 id="4-取消高亮搜索"><a href="#4-取消高亮搜索" class="headerlink" title="4.取消高亮搜索"></a>4.取消高亮搜索</h3><p> :noh</p>
<h1 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2. 跳转"></a>2. 跳转</h1><ol>
<li>shift+g: 跳转到文件末尾</li>
<li>gg : 跳转到文件头</li>
<li>行数+gg: 跳转到指定行</li>
</ol>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>修改juypter工作目录</title>
    <url>/2020/07/30/%E4%BF%AE%E6%94%B9juypter%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>juypter notebook默认工作环境是在c盘，这里就解决这个问题</p>
<a id="more"></a>

<p>1.打开anocoda的console，然后在里面输入jupyter notebook –generate-config，就可以在<code>C:\Users\hp\.jupyter</code>下生成jupyter_notebook_config.py文件</p>
<p>2.打开该文件，然后在里面搜索<code>c.NotebookApp.notebook_dir</code>，将注释去掉，改为<code>c.NotebookApp.notebook_dir = &#39;你想要默认打开的文件夹&#39;</code></p>
<p>3.最后，在juypter notebook的快捷方式的属性界面，属性-&gt;目标，去掉最后的 %USERPROFILE%</p>
<p>完成以上步骤之后，即可修改juypter notebook的工作界面</p>
]]></content>
      <categories>
        <category>juypter</category>
      </categories>
      <tags>
        <tag>juypter</tag>
      </tags>
  </entry>
  <entry>
    <title>biliBara</title>
    <url>/2020/05/24/biliBara/</url>
    <content><![CDATA[<p>flask+vue的b站弹幕爬虫统计数据</p>
<img src="/2020/05/24/biliBara/1590339415849.png" class="" width="1590339415849">

<a id="more"></a>

<h1 id="1-FLASK"><a href="#1-FLASK" class="headerlink" title="1.FLASK"></a>1.FLASK</h1><h3 id="1-requirement文件"><a href="#1-requirement文件" class="headerlink" title="1. requirement文件"></a>1. requirement文件</h3><p>生成</p>
<figure class="highlight plain"><figcaption><span>freeze > requirements.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>



<h1 id="2-PYTHON"><a href="#2-PYTHON" class="headerlink" title="2.PYTHON"></a>2.PYTHON</h1><h3 id="1-jieba提词和echarts-wordcloud"><a href="#1-jieba提词和echarts-wordcloud" class="headerlink" title="1.jieba提词和echarts wordcloud"></a>1.jieba提词和echarts wordcloud</h3><p><a href="https://www.jianshu.com/p/8490b46473a5" target="_blank" rel="noopener">https://www.jianshu.com/p/8490b46473a5</a><br>一般词云都是要使用词语的权重，这个权重的计算可以使用jieba提词轻松实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"><span class="comment">#获得一个元祖的数组[("中国", 0.234),("人", 0.4613)]</span></span><br><span class="line">tags = jieba.analyse.extract_tags(content, topK=<span class="number">100</span>, withWeight=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> tex, weight <span class="keyword">in</span> tags:</span><br><span class="line">   tagsList[tex] += int(weight*<span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-flask接受请求的参数"><a href="#2-flask接受请求的参数" class="headerlink" title="2.flask接受请求的参数"></a>2.flask接受请求的参数</h3><p><a href="https://www.cnblogs.com/shangpolu/p/7106922.html" target="_blank" rel="noopener">https://www.cnblogs.com/shangpolu/p/7106922.html</a><br>1.get请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.post请求</span><br><span class="line">&#96;&#96;&#96;request.form.get(&quot;key&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3-python原始爬虫"><a href="#3-python原始爬虫" class="headerlink" title="3.python原始爬虫"></a>3.python原始爬虫</h3><p><a href="https://blog.csdn.net/weixin_41429999/article/details/105781775" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41429999/article/details/105781775</a></p>
<h1 id="3-VUE"><a href="#3-VUE" class="headerlink" title="3.VUE"></a>3.VUE</h1><h3 id="1-vuex，localStorage和sessionStorage"><a href="#1-vuex，localStorage和sessionStorage" class="headerlink" title="1.vuex，localStorage和sessionStorage"></a>1.vuex，localStorage和sessionStorage</h3><p><a href="https://www.cnblogs.com/liangtao999/p/12623617.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangtao999/p/12623617.html</a></p>
<p>veux主要用于页面跳转间的传值，储存在内存之中，页面刷新就会丢失</p>
<p>localStorage会永久储存在浏览器中，不丢失</p>
<p>sessionStorage临时储存在浏览器中，浏览器关闭便会丢失</p>
<h3 id="2-页面无跳闪刷新"><a href="#2-页面无跳闪刷新" class="headerlink" title="2.页面无跳闪刷新"></a>2.页面无跳闪刷新</h3><p><a href="https://blog.csdn.net/weixin_43885417/article/details/91310674" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43885417/article/details/91310674</a></p>
<h3 id="3-echarts"><a href="#3-echarts" class="headerlink" title="3.echarts"></a>3.echarts</h3><p>可以直接卸载mounted之中<br><strong>impotant！</strong>但要注意的是，在使用axiso获取数据时，要将设置项（setOption）放在axios的请求处理之中，否则图表将不会显示数据</p>
<h3 id="4-vue-config-js配置"><a href="#4-vue-config-js配置" class="headerlink" title="4.vue.config.js配置"></a>4.vue.config.js配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const debug &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line"> </span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 访问资源的基本路径，一般不需要进行修改，此处还有疑问，正在验证中</span><br><span class="line">    &#x2F;&#x2F; baseUrl: &#39;&#x2F;&#39;,&lt;br&gt;        publicPath: &#39;&#x2F;&#39;,  &#x2F;&#x2F;publicPath取代了baseUrl</span><br><span class="line">    &#x2F;&#x2F; 打包之后输出文件目录</span><br><span class="line">    outputDir: &#39;dist&#39;,</span><br><span class="line">    assetsDir: &#39;assets&#39;, &#x2F;&#x2F; 打包之后静态资源目录 (js, css, img, fonts)</span><br><span class="line">    &#x2F;&#x2F; eslint-loader 是否在保存的时候检查</span><br><span class="line">    lintOnSave: true,</span><br><span class="line">    &#x2F;&#x2F; use the full build with in-browser compiler?</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;vuejs.org&#x2F;v2&#x2F;guide&#x2F;installation.html#Runtime-Compiler-vs-Runtime-only</span><br><span class="line">    &#x2F;&#x2F; runtimeCompiler: true, &#x2F;&#x2F;关键点在这  原来的 Compiler 换成了 runtimeCompiler</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; webpack配置</span><br><span class="line">    &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-cli&#x2F;blob&#x2F;dev&#x2F;docs&#x2F;webpack.md   webpack链接API，用于生成和修改webapck配置</span><br><span class="line">    chainWebpack: () &#x3D;&gt; &#123;</span><br><span class="line">        if(debug) &#123;</span><br><span class="line">            &#x2F;&#x2F; 本地开发配置</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 生产开发配置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: (config) &#x3D;&gt; &#123; &#x2F;&#x2F; webpack配置，值位对象时会合并配置，为方法时会改写配置</span><br><span class="line">        if(debug) &#123; &#x2F;&#x2F; 开发环境配置</span><br><span class="line">            config.devtool &#x3D; &#39;cheap-module-eval-source-map&#39;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 生产环境配置</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        Object.assign(config, &#123; &#x2F;&#x2F; 开发生产共同配置</span><br><span class="line">            resolve: &#123;</span><br><span class="line">                alias: &#123;</span><br><span class="line">                    &#39;@&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#39;) &#x2F;&#x2F;设置路径别名</span><br><span class="line">                    &#x2F;&#x2F;...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; vue-loader 配置项</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;vue-loader.vuejs.org&#x2F;en&#x2F;options.html</span><br><span class="line">    &#x2F;&#x2F; vueLoader: &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 生产环境是否生成 sourceMap 文件</span><br><span class="line">    productionSourceMap: true,</span><br><span class="line">    &#x2F;&#x2F; css相关配置 配置高于chainWebpack中关于css loader的配置</span><br><span class="line">    css: &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否使用css分离插件 ExtractTextPlugin</span><br><span class="line">        extract: true,</span><br><span class="line">        &#x2F;&#x2F; 开启 CSS source maps?是否在构建样式地图，false将提高构建速度</span><br><span class="line">        sourceMap: false,</span><br><span class="line">        &#x2F;&#x2F; css预设器配置项</span><br><span class="line">        loaderOptions: &#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F; 启用 CSS modules for all css &#x2F; pre-processor files.</span><br><span class="line">        modules: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; use thread-loader for babel &amp; TS in production build</span><br><span class="line">    &#x2F;&#x2F; enabled by default if the machine has more than 1 cores 构建时开启多进程处理babel编译</span><br><span class="line">    parallel: require(&#39;os&#39;).cpus().length &gt; 1,</span><br><span class="line">    &#x2F;&#x2F; 是否启用dll</span><br><span class="line">    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-cli&#x2F;blob&#x2F;dev&#x2F;docs&#x2F;cli-service.md#dll-mode</span><br><span class="line">    &#x2F;&#x2F; dll: false,</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; PWA 插件相关配置</span><br><span class="line">    &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-cli&#x2F;tree&#x2F;dev&#x2F;packages&#x2F;%40vue&#x2F;cli-plugin-pwa</span><br><span class="line">    pwa: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; webpack-dev-server 相关配置</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: true,</span><br><span class="line">        host: &#39;localhost&#39;,</span><br><span class="line">        port: 8084,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">          &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">            target: &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#39;,</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,</span><br><span class="line">            pathRewrite:&#123;</span><br><span class="line">              &quot;^&#x2F;api&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; &#x2F;&#x2F; 设置代理</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的代理设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    host: &#39;localhost&#39;,</span><br><span class="line">    port: 8084,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#39;,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        secure: false,</span><br><span class="line">        pathRewrite:&#123;</span><br><span class="line">          &quot;^&#x2F;api&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; &#x2F;&#x2F; 设置代理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-部署"><a href="#4-部署" class="headerlink" title="4.部署"></a>4.部署</h1><h3 id="1-screen"><a href="#1-screen" class="headerlink" title="1. screen"></a>1. screen</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">screen -S yourname  #新建一个叫yourname的session</span><br><span class="line">screen -ls          #列出当前所有的session</span><br><span class="line">screen -r [yourname&#x2F;scrren-id]  #回到yourname这个session</span><br><span class="line">ctrl+a -&gt; d  #detach当前screen回到原本窗口</span><br><span class="line">ctrel+a -&gt; n #显示下一个窗口（next）</span><br><span class="line">screen -X -s [screenname] #关闭会话</span><br></pre></td></tr></table></figure>

<h3 id="2-Gunicorn"><a href="#2-Gunicorn" class="headerlink" title="2. Gunicorn"></a>2. Gunicorn</h3><p><a href="https://www.cnblogs.com/luyuze95/p/11696534.html" target="_blank" rel="noopener">https://www.cnblogs.com/luyuze95/p/11696534.html</a></p>
<p>Web框架致力于如何生成HTML代码，而Web服务器用于处理和响应HTTP请求。Web框架和Web服务器之间的通信，需要一套双方都遵守的接口协议。WSGI协议就是用来统一这两者的接口的。</p>
<p><strong>1.</strong> 安装gunicorn</p>
<p>要在虚拟状态激活的情况下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install gunicorn   #阿里云自带python2，pip3可以确保调用python3</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> 启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -w 4 -b 127.0.0.1:5000 [app_name]:app</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> 查找gunicorn进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep gunicorn</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/freinds/p/8074651.html" target="_blank" rel="noopener">https://www.cnblogs.com/freinds/p/8074651.html</a></p>
<p>ps-ef用于查看全格式的全部进程，其中“ps”是在抄Linux中是查看进程的命令，“-e”参数代表显示所有进程，“-f”参数代表全格式。</p>
<p>ps命令将某个进程显示出来</p>
<p>grep命令是查找</p>
<p>中间的|是管道命令 是指ps命令与grep同时执行</p>
<p>PS是LINUX下最常用的也是非常强大的进程查看命令</p>
<p>grep命令是查找，是一种强大的文本搜索工具，它能<a href="https://www.baidu.com/s?wd=%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9uWD3PhP9n1b4m1nduAcz0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjfvrHnzPWT3" target="_blank" rel="noopener">使用正则表达式</a>搜索文本，并把匹配的行打印出来。</p>
<p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
<p>以下这条命令是检查java 进程是否存在：ps -ef |grep java</p>
<p>*<em>3. *</em>杀死进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 [id]</span><br></pre></td></tr></table></figure>

<h3 id="3-nginx"><a href="#3-nginx" class="headerlink" title="3.nginx"></a>3.nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload   #重新加载nginx配置</span><br><span class="line">sudo service nginx restart  #启动nginx</span><br></pre></td></tr></table></figure>

<p>nginx的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#networkproject</span><br><span class="line"> server &#123;</span><br><span class="line">    listen       8084 default_server;</span><br><span class="line">    listen       [::]:8084 default_server;</span><br><span class="line">    server_name  47.96.227.33;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">            ## stitp的目录</span><br><span class="line">            # the direction of the stitp project</span><br><span class="line">            root &#x2F;myfiles&#x2F;blibiliBarrage&#x2F;dist;</span><br><span class="line">            index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    # 路径代理</span><br><span class="line">    location &#x2F;api&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">        location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line"></span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>biliBara</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>python</tag>
        <tag>flask</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>titanic logistic prac</title>
    <url>/2020/08/06/titanic_logistic_prac/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49797143</a><br>本篇文章只是进行简单的复原</p>
<a id="more"></a>

<h1 id="1、数据分析"><a href="#1、数据分析" class="headerlink" title="1、数据分析"></a>1、数据分析</h1><p>首先简单的导入数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment">#数据分析</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#科学计算</span></span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br><span class="line"></span><br><span class="line">data_train = pd.read_csv(<span class="string">"../titanic/train.csv"</span>)</span><br><span class="line">data_train</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>C85</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>C123</td>
      <td>S</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>886</th>
      <td>887</td>
      <td>0</td>
      <td>2</td>
      <td>Montvila, Rev. Juozas</td>
      <td>male</td>
      <td>27.0</td>
      <td>0</td>
      <td>0</td>
      <td>211536</td>
      <td>13.0000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>887</th>
      <td>888</td>
      <td>1</td>
      <td>1</td>
      <td>Graham, Miss. Margaret Edith</td>
      <td>female</td>
      <td>19.0</td>
      <td>0</td>
      <td>0</td>
      <td>112053</td>
      <td>30.0000</td>
      <td>B42</td>
      <td>S</td>
    </tr>
    <tr>
      <th>888</th>
      <td>889</td>
      <td>0</td>
      <td>3</td>
      <td>Johnston, Miss. Catherine Helen "Carrie"</td>
      <td>female</td>
      <td>NaN</td>
      <td>1</td>
      <td>2</td>
      <td>W./C. 6607</td>
      <td>23.4500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>889</th>
      <td>890</td>
      <td>1</td>
      <td>1</td>
      <td>Behr, Mr. Karl Howell</td>
      <td>male</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>111369</td>
      <td>30.0000</td>
      <td>C148</td>
      <td>C</td>
    </tr>
    <tr>
      <th>890</th>
      <td>891</td>
      <td>0</td>
      <td>3</td>
      <td>Dooley, Mr. Patrick</td>
      <td>male</td>
      <td>32.0</td>
      <td>0</td>
      <td>0</td>
      <td>370376</td>
      <td>7.7500</td>
      <td>NaN</td>
      <td>Q</td>
    </tr>
  </tbody>
</table>
<p>891 rows × 12 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.info()</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;
RangeIndex: 891 entries, 0 to 890
Data columns (total 12 columns):
 #   Column       Non-Null Count  Dtype  
---  ------       --------------  -----  
 0   PassengerId  891 non-null    int64  
 1   Survived     891 non-null    int64  
 2   Pclass       891 non-null    int64  
 3   Name         891 non-null    object 
 4   Sex          891 non-null    object 
 5   Age          714 non-null    float64
 6   SibSp        891 non-null    int64  
 7   Parch        891 non-null    int64  
 8   Ticket       891 non-null    object 
 9   Fare         891 non-null    float64
 10  Cabin        204 non-null    object 
 11  Embarked     889 non-null    object 
dtypes: float64(2), int64(5), object(5)
memory usage: 83.7+ KB</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.describe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>714.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
      <td>891.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>446.000000</td>
      <td>0.383838</td>
      <td>2.308642</td>
      <td>29.699118</td>
      <td>0.523008</td>
      <td>0.381594</td>
      <td>32.204208</td>
    </tr>
    <tr>
      <th>std</th>
      <td>257.353842</td>
      <td>0.486592</td>
      <td>0.836071</td>
      <td>14.526497</td>
      <td>1.102743</td>
      <td>0.806057</td>
      <td>49.693429</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>0.420000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>223.500000</td>
      <td>0.000000</td>
      <td>2.000000</td>
      <td>20.125000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>7.910400</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>446.000000</td>
      <td>0.000000</td>
      <td>3.000000</td>
      <td>28.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>14.454200</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>668.500000</td>
      <td>1.000000</td>
      <td>3.000000</td>
      <td>38.000000</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>31.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>891.000000</td>
      <td>1.000000</td>
      <td>3.000000</td>
      <td>80.000000</td>
      <td>8.000000</td>
      <td>6.000000</td>
      <td>512.329200</td>
    </tr>
  </tbody>
</table>
</div>



<p>这里只会显示类型为数值的属性<br>可以发现乘客平均生存率0.38,二三等舱人数较多，平均年龄29<br>同时Age字段有数据丢失,embarked有少量数值丢失，Cabin有大量数值丢失</p>
<h1 id="2-各属性乘客分布"><a href="#2-各属性乘客分布" class="headerlink" title="2. 各属性乘客分布"></a>2. 各属性乘客分布</h1><p>下一步就是对各个属性的乘客分布进行大致的把握，这样子对数据也能有个大体的认识</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'KaiTi'</span>] <span class="comment">#字体</span></span><br><span class="line">plt.rcParams[<span class="string">'font.serif'</span>] = [<span class="string">'KaiTi'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment">#改变图片大小</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>) <span class="comment">#图表颜色alpha</span></span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">0</span>)) <span class="comment">#划分成小图</span></span><br><span class="line">data_train.Survived.value_counts().plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.title(<span class="string">u"survived(1 as survived)"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">data_train.Pclass.value_counts().plot(kind=<span class="string">"bar"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line">plt.title(<span class="string">u"乘客等级分布"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line">plt.scatter(data_train.Survived, data_train.Age)</span><br><span class="line">plt.ylabel(<span class="string">u"年龄"</span>)</span><br><span class="line">plt.grid(b=<span class="literal">True</span>, which=<span class="string">'major'</span>, axis=<span class="string">'y'</span>)</span><br><span class="line">plt.title(<span class="string">u"年龄和获救分布(1为获救)"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),colspan=<span class="number">2</span>)</span><br><span class="line">data_train.Age[data_train.Pclass == <span class="number">1</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">data_train.Age[data_train.Pclass == <span class="number">2</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">data_train.Age[data_train.Pclass == <span class="number">3</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"年龄"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"密度"</span>)</span><br><span class="line">plt.title(<span class="string">u"各等级客舱乘客年龄密度分布"</span>)</span><br><span class="line">plt.legend((<span class="string">u"一等"</span>,<span class="string">u"二等"</span>,<span class="string">u"三等"</span>),loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">data_train.Embarked.value_counts().plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.title(<span class="string">u"各登船口岸登船人数"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<img src="/2020/08/06/titanic_logistic_prac/output_7_0.png" class="" title="png">


<p>从上图可以发现，未获救人数较被获救人数多了很多。乘客也普遍分布在三等舱，说明三等舱人数较多，未来要考虑到这个比例问题。各个舱的年龄分布相似，但一等舱年龄偏大。同时S港口登船人数最多。</p>
<h1 id="3-属性与获救结果的关系"><a href="#3-属性与获救结果的关系" class="headerlink" title="3.属性与获救结果的关系"></a>3.属性与获救结果的关系</h1><p>下面就要观察我们关系的获救结果与各个属性之间的大致关系</p>
<h3 id="1-客舱等级"><a href="#1-客舱等级" class="headerlink" title="1.客舱等级"></a>1.客舱等级</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#存活人数</span></span><br><span class="line">Survived_1 = data_train.Pclass[data_train.Survived == <span class="number">1</span>].value_counts()</span><br><span class="line"><span class="comment">#未存活人数</span></span><br><span class="line">Survived_0 = data_train.Pclass[data_train.Survived == <span class="number">0</span>].value_counts()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u'获救'</span>:Survived_1, <span class="string">u'未获救'</span>:Survived_0&#125;)</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>, stacked=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">u"各等式客舱乘客获救情况"</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"客舱等级"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br></pre></td></tr></table></figure>




<pre><code>Text(0, 0.5, &apos;人数&apos;)




&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><img src="/2020/08/06/titanic_logistic_prac/output_9_2.png" class="" title="png">


<p>可以发现，明显一客舱成员获救比例高，而三客舱成员获救比例低。可能是因为人员密集度，社会地位，财富等原因造成这样的差异。</p>
<h3 id="2-性别"><a href="#2-性别" class="headerlink" title="2.性别"></a>2.性别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">Survived_0 = data_train.Sex[data_train.Survived == <span class="number">0</span>].value_counts()</span><br><span class="line">Survived_1 = data_train.Sex[data_train.Survived == <span class="number">1</span>].value_counts()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u'获救'</span>: Survived_1,<span class="string">u'未获救'</span>: Survived_0&#125;)</span><br></pre></td></tr></table></figure>


<pre><code>&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>)</span><br><span class="line">plt.title(<span class="string">u"性别和船舱级别与获救情况"</span>)</span><br><span class="line">plt.xticks([]) <span class="comment">#隐藏坐标轴</span></span><br><span class="line">plt.yticks([]) </span><br><span class="line"></span><br><span class="line"><span class="comment">#high class female</span></span><br><span class="line">ax1=fig.add_subplot(<span class="number">141</span>)</span><br><span class="line">high_female = data_train.Survived[data_train.Sex==<span class="string">'female'</span>][data_train.Pclass!=<span class="number">3</span>].value_counts()</span><br><span class="line">high_female.plot(kind=<span class="string">'bar'</span>,label=<span class="string">"female highClass"</span>, color=<span class="string">'#FA2479'</span>)</span><br><span class="line">ax1.set_xticklabels([<span class="string">u"获救"</span>,<span class="string">u"未获救"</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax1.legend([<span class="string">u"女性/高级舱"</span>],loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#high class male</span></span><br><span class="line">ax2=fig.add_subplot(<span class="number">142</span>)</span><br><span class="line">high_male=data_train.Survived[data_train.Sex==<span class="string">'male'</span>][data_train.Pclass!=<span class="number">3</span>].value_counts()</span><br><span class="line">high_male.plot(kind=<span class="string">'bar'</span>,label=<span class="string">'male highclass'</span>, color=<span class="string">'pink'</span>)</span><br><span class="line">ax2.set_xticklabels([<span class="string">u'获救'</span>,<span class="string">u'未获救'</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax2.legend([<span class="string">u"男性/高级舱"</span>],loc=<span class="string">"best"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#low class female</span></span><br><span class="line">ax3=fig.add_subplot(<span class="number">143</span>)</span><br><span class="line">high_female = data_train.Survived[data_train.Sex==<span class="string">'female'</span>][data_train.Pclass==<span class="number">3</span>].value_counts()</span><br><span class="line">high_female.plot(kind=<span class="string">'bar'</span>,label=<span class="string">"female highClass"</span>, color=<span class="string">'red'</span>)</span><br><span class="line">ax3.set_xticklabels([<span class="string">u"获救"</span>,<span class="string">u"未获救"</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax3.legend([<span class="string">u"女性/高级舱"</span>],loc=<span class="string">'best'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#low class male</span></span><br><span class="line">ax4=fig.add_subplot(<span class="number">144</span>)</span><br><span class="line">high_male=data_train.Survived[data_train.Sex==<span class="string">'male'</span>][data_train.Pclass==<span class="number">3</span>].value_counts()</span><br><span class="line">high_male.plot(kind=<span class="string">'bar'</span>,label=<span class="string">'male highclass'</span>, color=<span class="string">'blue'</span>)</span><br><span class="line">ax4.set_xticklabels([<span class="string">u'获救'</span>,<span class="string">u'未获救'</span>],rotation=<span class="number">0</span>)</span><br><span class="line">ax4.legend([<span class="string">u"男性/高级舱"</span>],loc=<span class="string">"best"</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.legend.Legend at 0x27ae4edfcc8&gt;</code></pre><img src="/2020/08/06/titanic_logistic_prac/output_12_1.png" class="" title="png">


<p>可以发现女性获救比例明显高于男性获救比例。</p>
<h3 id="3-登录的港口"><a href="#3-登录的港口" class="headerlink" title="3.登录的港口"></a>3.登录的港口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha = <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">Survived_0 = data_train.Embarked[data_train.Survived == <span class="number">0</span>].value_counts()</span><br><span class="line">Survived_1 = data_train.Embarked[data_train.Survived == <span class="number">1</span>].value_counts()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u'获救'</span>: Survived_1,<span class="string">u'未获救'</span>: Survived_0&#125;)</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,stacked=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x27ae52aeb08&gt;




&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><img src="/2020/08/06/titanic_logistic_prac/output_14_2.png" class="" title="png">


<p>可以发现S港里未获救人口比例较高</p>
<h3 id="4-家属个数与获救情况"><a href="#4-家属个数与获救情况" class="headerlink" title="4.家属个数与获救情况"></a>4.家属个数与获救情况</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = data_train.groupby([<span class="string">'SibSp'</span>,<span class="string">'Survived'</span>])</span><br><span class="line">df = pd.DataFrame(g.count()[<span class="string">'PassengerId'</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>                PassengerId
SibSp Survived             
0     0                 398
      1                 210
1     0                  97
      1                 112
2     0                  15
      1                  13
3     0                  12
      1                   4
4     0                  15
      1                   3
5     0                   5
8     0                   7</code></pre><h3 id="5-Cabin"><a href="#5-Cabin" class="headerlink" title="5. Cabin"></a>5. Cabin</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.Cabin.value_counts()</span><br></pre></td></tr></table></figure>




<pre><code>B96 B98        4
G6             4
C23 C25 C27    4
F33            3
C22 C26        3
              ..
A19            1
C7             1
D15            1
E77            1
A10            1
Name: Cabin, Length: 147, dtype: int64</code></pre><p>因为没有规律，并且是类别属性，所以可以看看Cabin的有无对于结果的影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无Cabin属性</span></span><br><span class="line">Survived_cabin = data_train.Survived[pd.isnull(data_train.Cabin)].value_counts()</span><br><span class="line"><span class="comment">#有Cabin属性</span></span><br><span class="line">Survived_nocabin = data_train.Survived[pd.notnull(data_train.Cabin)].value_counts()</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u"无cabin"</span>: Survived_cabin,<span class="string">u"有cabin"</span>:Survived_nocabin&#125;).transpose()</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,stacked=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">"cabin有无对获救情况的影响"</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"1为获救，0为未获救"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<pre><code>&lt;Figure size 720x576 with 0 Axes&gt;</code></pre>{% asset_img output_20_1.png png %}


<p>根据上面可以看出，无cabin的获救比例较高<br><strong>这里要注意的是</strong>：<br>看下图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">fig.set(alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无Cabin属性</span></span><br><span class="line">Survived_cabin = data_train.Survived[pd.isnull(data_train.Cabin)].value_counts()</span><br><span class="line"><span class="comment">#有Cabin属性</span></span><br><span class="line">Survived_nocabin = data_train.Survived[pd.notnull(data_train.Cabin)].value_counts()</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">u"无cabin"</span>: Survived_cabin,<span class="string">u"有cabin"</span>:Survived_nocabin&#125;)</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,stacked=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">"不同获救情况的有无cabin比例"</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"1为获救，0为未获救"</span>)</span><br><span class="line">plt.ylabel(<span class="string">u"人数"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<pre><code>&lt;Figure size 720x576 with 0 Axes&gt;</code></pre><img src="/2020/08/06/titanic_logistic_prac/output_22_1.png" class="" title="png">


<p>以上两张图，可以看出，在第二张图中无论是获救还是未获救，无cabin记录的人数占比都较高。但是第一张图却反映出有cabin记录的人获救比例较高。这是为什么？<br>个人理解是因为条件概率问题。可以发现有cabin记录的人数仅为200多人，占比少数。所以假设有个人，那么这个人无论获救没获救，他是有cabin记录的可能性都会较低，因为本身这个群体占比就低。那么假设有另一个人，这个人是获救的人，那么他极可能就是有cabin记录的人，这样也就符合了第一幅图的描述。</p>
<h1 id="4-数据预处理"><a href="#4-数据预处理" class="headerlink" title="4.数据预处理"></a>4.数据预处理</h1><p>数据预处理包括了feature engineer的过程。<br>首先要对缺值进行处理</p>
<h3 id="1-对缺值的处理"><a href="#1-对缺值的处理" class="headerlink" title="1.对缺值的处理"></a>1.对缺值的处理</h3><p>1.缺值样本占比极高<br>一般会选择舍弃该属性，否则可能会对训练结果产生不好的影响<br>2.缺值的占比适中，并且是<strong>非连续值</strong>的属性（比如类属性）<br>一般把NaN作为一个新类，并入之前的类目之中<br>3.缺值样本适中，并且是<strong>连续</strong>的特征值<br>那么一般会定长，使用一个step，将其<strong>离散化</strong>，然后把NaN作为一个类并入其中<br>4.缺值不多<br>可以尝试拟合数值，补充空缺</p>
<p>下面对缺值少的属性进行拟合补缺</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment">#补充缺失的年龄属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_missing_ages</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="comment">#放入数值型属性</span></span><br><span class="line">    age_df = df[[<span class="string">'Age'</span>,<span class="string">'Fare'</span>,<span class="string">'Parch'</span>,<span class="string">'SibSp'</span>,<span class="string">'Pclass'</span>]]</span><br><span class="line">    <span class="comment">#已知年龄和未知年龄的</span></span><br><span class="line">    known_age = age_df[age_df.Age.notnull()].values</span><br><span class="line">    unknown_age = age_df[age_df.Age.isnull()].values</span><br><span class="line">    </span><br><span class="line">    y = known_age[:,<span class="number">0</span>]</span><br><span class="line">    X = known_age[:,<span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    rfr = RandomForestRegressor(random_state=<span class="number">0</span>,n_estimators=<span class="number">2000</span>,n_jobs=<span class="number">-1</span>)</span><br><span class="line">    rfr.fit(X,y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#预测结果</span></span><br><span class="line">    predictedAges =rfr.predict(unknown_age[:,<span class="number">1</span>::])</span><br><span class="line">    </span><br><span class="line">    df.loc[(df.Age.isnull()), <span class="string">'Age'</span>] = predictedAges</span><br><span class="line">    <span class="keyword">return</span> df, rfr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_Cabin_type</span><span class="params">(df)</span>:</span></span><br><span class="line">    df.loc[(df.Cabin.notnull()),<span class="string">'Cabin'</span>] = <span class="string">"Yes"</span></span><br><span class="line">    df.loc[(df.Cabin.isnull()),<span class="string">'Cabin'</span>] = <span class="string">"No"</span></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数内部修改了data_train</span></span><br><span class="line">data_train, rfr = set_missing_ages(data_train)</span><br><span class="line">data_train = set_Cabin_type(data_train)</span><br><span class="line">data_train.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>No</td>
      <td>S</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>Yes</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>No</td>
      <td>S</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>Yes</td>
      <td>S</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>No</td>
      <td>S</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="2-因子化"><a href="#2-因子化" class="headerlink" title="2.因子化"></a>2.因子化</h3><p>特征因子化，举例来说，就是Cabin的取值只能为[‘yes’,’no’]，那么就可以把他展开成两个属性’cabin_yes’和’cabin_no’<br>那么原本取值为’yes’的，在此处’cabin_yes’下为1，’cabin_no’下为0；<br>原本取值为’no’的，在此处’cabin_yse’下为0，’cabin_no’下为1；<br>此处使用’get_dummies’来实现这个效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummies_Cabin = pd.get_dummies(data_train[<span class="string">'Cabin'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Pclass = pd.get_dummies(data_train[<span class="string">'Pclass'</span>],prefix=<span class="string">'Pclass'</span>)</span><br><span class="line">dummies_Sex = pd.get_dummies(data_train[<span class="string">'Sex'</span>],prefix=<span class="string">'Sex'</span>)</span><br><span class="line">dummies_Embarked = pd.get_dummies(data_train[<span class="string">'Embarked'</span>],prefix=<span class="string">'Embarked'</span>)</span><br><span class="line"></span><br><span class="line">df = pd.concat([data_train, dummies_Cabin, dummies_Embarked, dummies_Pclass, dummies_Sex],axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#去除无用属性</span></span><br><span class="line">df.drop([<span class="string">'Name'</span>,<span class="string">'Pclass'</span>,<span class="string">'Sex'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>,<span class="string">'Embarked'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
      <th>Cabin_No</th>
      <th>Cabin_Yes</th>
      <th>Embarked_C</th>
      <th>Embarked_Q</th>
      <th>Embarked_S</th>
      <th>Pclass_1</th>
      <th>Pclass_2</th>
      <th>Pclass_3</th>
      <th>Sex_female</th>
      <th>Sex_male</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>22.000000</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>38.000000</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>35.000000</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>35.000000</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>886</th>
      <td>887</td>
      <td>0</td>
      <td>27.000000</td>
      <td>0</td>
      <td>0</td>
      <td>13.0000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>887</th>
      <td>888</td>
      <td>1</td>
      <td>19.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>888</th>
      <td>889</td>
      <td>0</td>
      <td>16.185117</td>
      <td>1</td>
      <td>2</td>
      <td>23.4500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>889</th>
      <td>890</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>890</th>
      <td>891</td>
      <td>0</td>
      <td>32.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.7500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>891 rows × 16 columns</p>
</div>



<h3 id="3-数据标准化"><a href="#3-数据标准化" class="headerlink" title="3.数据标准化"></a>3.数据标准化</h3><p>经过以上的处理结果，剩下的问题就是Age以及Fare的scale差距过大，需要进行标准化。<br>可以使用scikit-learn里面的preprocessing进行scaling，转化到[-1,1]之间的数值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.preprocessing <span class="keyword">as</span> preprocessing</span><br><span class="line">scaler = preprocessing.StandardScaler()</span><br><span class="line"><span class="comment"># age_scale_param = scaler.fit(df['Age'])</span></span><br><span class="line">df[<span class="string">'Age_scaled'</span>] = scaler.fit_transform(df[<span class="string">'Age'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># fare_scale_param = scaler.fit(df['Fare'])</span></span><br><span class="line">df[<span class="string">'Fare_scaled'</span>] = scaler.fit_transform(df[<span class="string">'Fare'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
      <th>Cabin_No</th>
      <th>Cabin_Yes</th>
      <th>Embarked_C</th>
      <th>Embarked_Q</th>
      <th>Embarked_S</th>
      <th>Pclass_1</th>
      <th>Pclass_2</th>
      <th>Pclass_3</th>
      <th>Sex_female</th>
      <th>Sex_male</th>
      <th>Age_scaled</th>
      <th>Fare_scaled</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>22.000000</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>-0.561377</td>
      <td>-0.502445</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>38.000000</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0.613173</td>
      <td>0.786845</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-0.267740</td>
      <td>-0.488854</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>35.000000</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0.392945</td>
      <td>0.420730</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>35.000000</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.392945</td>
      <td>-0.486337</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>886</th>
      <td>887</td>
      <td>0</td>
      <td>27.000000</td>
      <td>0</td>
      <td>0</td>
      <td>13.0000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>-0.194330</td>
      <td>-0.386671</td>
    </tr>
    <tr>
      <th>887</th>
      <td>888</td>
      <td>1</td>
      <td>19.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>-0.781606</td>
      <td>-0.044381</td>
    </tr>
    <tr>
      <th>888</th>
      <td>889</td>
      <td>0</td>
      <td>16.185117</td>
      <td>1</td>
      <td>2</td>
      <td>23.4500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-0.988244</td>
      <td>-0.176263</td>
    </tr>
    <tr>
      <th>889</th>
      <td>890</td>
      <td>1</td>
      <td>26.000000</td>
      <td>0</td>
      <td>0</td>
      <td>30.0000</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>-0.267740</td>
      <td>-0.044381</td>
    </tr>
    <tr>
      <th>890</th>
      <td>891</td>
      <td>0</td>
      <td>32.000000</td>
      <td>0</td>
      <td>0</td>
      <td>7.7500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.172717</td>
      <td>-0.492378</td>
    </tr>
  </tbody>
</table>
<p>891 rows × 18 columns</p>
</div>



<h1 id="5-逻辑回归建模"><a href="#5-逻辑回归建模" class="headerlink" title="5.逻辑回归建模"></a>5.逻辑回归建模</h1><p>经过了以上的数据预处理之后，就可以将所需的feature抽取出来，转化成numpy格式，使用logistic regression进行建模了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用正则去除所需的属性值</span></span><br><span class="line">train_df = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line">train_np = train_df.values</span><br><span class="line"></span><br><span class="line">y=train_np[:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">X=train_np[:,<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">clf = linear_model.LogisticRegression(C=<span class="number">1.0</span>,penalty=<span class="string">'l1'</span>,solver=<span class="string">"liblinear"</span>,tol=<span class="number">1e-6</span>)</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"></span><br><span class="line">clf</span><br></pre></td></tr></table></figure>




<pre><code>LogisticRegression(penalty=&apos;l1&apos;, solver=&apos;liblinear&apos;, tol=1e-06)</code></pre><p>之后就可以导入测试集，来测试训练出的模型了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_test = pd.read_csv(<span class="string">"../titanic/test.csv"</span>)</span><br><span class="line">data_test.loc[(data_test.Fare.isnull()),<span class="string">'Fare'</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">#对test集进行和train集一样的数据预处理</span></span><br><span class="line">tmp_df = data_test[[<span class="string">'Age'</span>,<span class="string">'Fare'</span>,<span class="string">'Parch'</span>,<span class="string">'SibSp'</span>,<span class="string">'Pclass'</span>]]</span><br><span class="line"><span class="comment">#拟合age</span></span><br><span class="line">null_age = tmp_df[tmp_df.Age.isnull()].values</span><br><span class="line">X = null_age[:,<span class="number">1</span>:]</span><br><span class="line">predictedAges = rfr.predict(X)</span><br><span class="line">data_test.loc[(data_test.Age.isnull()),<span class="string">'Age'</span>] = predictedAges</span><br><span class="line"></span><br><span class="line"><span class="comment">#因子化</span></span><br><span class="line">data_test = set_Cabin_type(data_test)</span><br><span class="line">dummies_Cabin = pd.get_dummies(data_test[<span class="string">'Cabin'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Embarked = pd.get_dummies(data_test[<span class="string">'Embarked'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Sex = pd.get_dummies(data_test[<span class="string">'Sex'</span>],prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">dummies_Pclass = pd.get_dummies(data_test[<span class="string">'Pclass'</span>],prefix=<span class="string">'Pclass'</span>)</span><br><span class="line"></span><br><span class="line">df_test = pd.concat([data_test,dummies_Cabin,dummies_Embarked,dummies_Pclass,dummies_Sex],axis=<span class="number">1</span>)</span><br><span class="line">df_test.drop([<span class="string">'Pclass'</span>,<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>,<span class="string">'Embarked'</span>,<span class="string">'Sex'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#标准化</span></span><br><span class="line">df_test[<span class="string">'Age_scaled'</span>] = scaler.fit_transform(df_test[<span class="string">'Age'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">df_test[<span class="string">'Fare_scaled'</span>] = scaler.fit_transform(df_test[<span class="string">'Fare'</span>].values.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">df_test</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Fare</th>
      <th>Cabin_No</th>
      <th>Cabin_Yes</th>
      <th>Cabin_C</th>
      <th>Cabin_Q</th>
      <th>Cabin_S</th>
      <th>Pclass_1</th>
      <th>Pclass_2</th>
      <th>Pclass_3</th>
      <th>Cabin_female</th>
      <th>Cabin_male</th>
      <th>Age_scaled</th>
      <th>Fare_scaled</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>892</td>
      <td>34.500000</td>
      <td>0</td>
      <td>0</td>
      <td>7.8292</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.307526</td>
      <td>-0.496637</td>
    </tr>
    <tr>
      <th>1</th>
      <td>893</td>
      <td>47.000000</td>
      <td>1</td>
      <td>0</td>
      <td>7.0000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1.256242</td>
      <td>-0.511497</td>
    </tr>
    <tr>
      <th>2</th>
      <td>894</td>
      <td>62.000000</td>
      <td>0</td>
      <td>0</td>
      <td>9.6875</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>2.394702</td>
      <td>-0.463335</td>
    </tr>
    <tr>
      <th>3</th>
      <td>895</td>
      <td>27.000000</td>
      <td>0</td>
      <td>0</td>
      <td>8.6625</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>-0.261704</td>
      <td>-0.481704</td>
    </tr>
    <tr>
      <th>4</th>
      <td>896</td>
      <td>22.000000</td>
      <td>1</td>
      <td>1</td>
      <td>12.2875</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-0.641190</td>
      <td>-0.416740</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>413</th>
      <td>1305</td>
      <td>30.705727</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.019551</td>
      <td>-0.492680</td>
    </tr>
    <tr>
      <th>414</th>
      <td>1306</td>
      <td>39.000000</td>
      <td>0</td>
      <td>0</td>
      <td>108.9000</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0.649064</td>
      <td>1.314641</td>
    </tr>
    <tr>
      <th>415</th>
      <td>1307</td>
      <td>38.500000</td>
      <td>0</td>
      <td>0</td>
      <td>7.2500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.611115</td>
      <td>-0.507017</td>
    </tr>
    <tr>
      <th>416</th>
      <td>1308</td>
      <td>30.705727</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0.019551</td>
      <td>-0.492680</td>
    </tr>
    <tr>
      <th>417</th>
      <td>1309</td>
      <td>25.755877</td>
      <td>1</td>
      <td>1</td>
      <td>22.3583</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>-0.356130</td>
      <td>-0.236263</td>
    </tr>
  </tbody>
</table>
<p>418 rows × 17 columns</p>
</div>



<p>进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Embarked_.*|Sex_.*|Pclass_.*|Cabin_.*'</span>)</span><br><span class="line">predictions = clf.predict(test)</span><br><span class="line">result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>: data_test[<span class="string">'PassengerId'</span>].values,<span class="string">'Survived'</span>:predictions.astype(np.int32)&#125;)</span><br><span class="line">result.to_csv(<span class="string">"../titanic/logistic_regression_prediction.csv"</span>,index=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">"output suc"</span>)</span><br></pre></td></tr></table></figure>

<pre><code>output suc</code></pre><p>之后，就可以在kaggle界面sumbit，最终结果是0.76315</p>
<h1 id="6-逻辑回归模型的优化"><a href="#6-逻辑回归模型的优化" class="headerlink" title="6.逻辑回归模型的优化"></a>6.逻辑回归模型的优化</h1><h3 id="1-关联系数分析"><a href="#1-关联系数分析" class="headerlink" title="1.关联系数分析"></a>1.关联系数分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(&#123;<span class="string">"columns"</span>:list(train_df.columns)[<span class="number">1</span>:], <span class="string">"coef"</span>:list(clf.coef_.T)&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>columns</th>
      <th>coef</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>SibSp</td>
      <td>[-0.34423363130066786]</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Parch</td>
      <td>[-0.1049180394409882]</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Cabin_No</td>
      <td>[-0.20329593023712947]</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Cabin_Yes</td>
      <td>[0.6987933469628373]</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Embarked_C</td>
      <td>[0.0]</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Embarked_Q</td>
      <td>[0.0]</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Embarked_S</td>
      <td>[-0.4172616632645433]</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Pclass_1</td>
      <td>[0.34116702481573935]</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Pclass_2</td>
      <td>[0.0]</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Pclass_3</td>
      <td>[-1.1941332195046448]</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Sex_female</td>
      <td>[2.159866487359889]</td>
    </tr>
    <tr>
      <th>11</th>
      <td>Sex_male</td>
      <td>[-0.47412117296965695]</td>
    </tr>
    <tr>
      <th>12</th>
      <td>Age_scaled</td>
      <td>[-0.5237628634773356]</td>
    </tr>
    <tr>
      <th>13</th>
      <td>Fare_scaled</td>
      <td>[0.084436110718527]</td>
    </tr>
  </tbody>
</table>
</div>



<p>系数为正的特征，和最后结果是一个正相关，反之为负相关<br>可以分析出来:<br>Sex属性，如果是female会极大提高最后获救的概率，而male会很大程度拉低这个概率。</p>
<p>Pclass属性，1等舱乘客最后获救的概率会上升，而乘客等级为3会极大地拉低这个概率。</p>
<p>有Cabin值会很大程度拉升最后获救概率(这里似乎能看到了一点端倪，事实上从最上面的有无Cabin记录的Survived分布图上看出，即使有Cabin记录的乘<br>客也有一部分遇难了，估计这个属性上我们挖掘还不够)</p>
<p>Age是一个负相关，意味着在我们的模型里，年龄越小，越有获救的优先权(还得回原数据看看这个是否合理）<br>有一个登船港口S会很大程度拉低获救的概率，另外俩港口压根就没啥作用(这个实际上非常奇怪，因为我们从之前的统计图上并没有看到S港口的获救率非常低，所以也许可以考虑把登船港口这个feature去掉试试)。<br>船票Fare有小幅度的正相关(并不意味着这个feature作用不大，有可能是我们细化的程度还不够，举个例子，说不定我们得对它离散化，再分至各个乘客等级上？)</p>
<h1 id="7-交叉验证"><a href="#7-交叉验证" class="headerlink" title="7.交叉验证"></a>7.交叉验证</h1><p>这里的交叉验证就是将数据集切割成五份，进行五次验证。</p>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score, train_test_split</span><br><span class="line"></span><br><span class="line"> <span class="comment">#简单看看打分情况</span></span><br><span class="line">clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>,C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</span><br><span class="line">all_data = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line">X = all_data.values[:,<span class="number">1</span>:]</span><br><span class="line">y = all_data.values[:,<span class="number">0</span>]</span><br><span class="line"><span class="comment"># print(cross_validation.cross_val_score(clf, X, y, cv=5))</span></span><br><span class="line">print(cross_val_score(clf, X, y, cv=<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[0.81564246 0.80898876 0.78651685 0.78651685 0.81460674]</code></pre><p>之后再查看一下bad case的情况，试一试用人眼能不能观察出什么规律</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分割数据，按照 训练数据:cv数据 = 7:3的比例</span></span><br><span class="line"><span class="comment"># split_train, split_cv = cross_validation.train_test_split(df, test_size=0.3, random_state=0)</span></span><br><span class="line">split_train, split_cv = train_test_split(df, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">train_df = split_train.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line"><span class="comment"># 生成模型</span></span><br><span class="line">clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>,C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</span><br><span class="line">clf.fit(train_df.values[:,<span class="number">1</span>:], train_df.values[:,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对cross validation数据进行预测</span></span><br><span class="line"></span><br><span class="line">cv_df = split_cv.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</span><br><span class="line">predictions = clf.predict(cv_df.values[:,<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">origin_data_train = pd.read_csv(<span class="string">"../titanic/train.csv"</span>)</span><br><span class="line">bad_cases = origin_data_train.loc[origin_data_train[<span class="string">'PassengerId'</span>].isin(split_cv[predictions != cv_df.values[:,<span class="number">0</span>]][<span class="string">'PassengerId'</span>].values)]</span><br><span class="line">bad_cases.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>23</th>
      <td>24</td>
      <td>1</td>
      <td>1</td>
      <td>Sloper, Mr. William Thompson</td>
      <td>male</td>
      <td>28.00</td>
      <td>0</td>
      <td>0</td>
      <td>113788</td>
      <td>35.5000</td>
      <td>A6</td>
      <td>S</td>
    </tr>
    <tr>
      <th>25</th>
      <td>26</td>
      <td>1</td>
      <td>3</td>
      <td>Asplund, Mrs. Carl Oscar (Selma Augusta Emilia...</td>
      <td>female</td>
      <td>38.00</td>
      <td>1</td>
      <td>5</td>
      <td>347077</td>
      <td>31.3875</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>49</th>
      <td>50</td>
      <td>0</td>
      <td>3</td>
      <td>Arnold-Franchi, Mrs. Josef (Josefine Franchi)</td>
      <td>female</td>
      <td>18.00</td>
      <td>1</td>
      <td>0</td>
      <td>349237</td>
      <td>17.8000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>55</th>
      <td>56</td>
      <td>1</td>
      <td>1</td>
      <td>Woolner, Mr. Hugh</td>
      <td>male</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>19947</td>
      <td>35.5000</td>
      <td>C52</td>
      <td>S</td>
    </tr>
    <tr>
      <th>65</th>
      <td>66</td>
      <td>1</td>
      <td>3</td>
      <td>Moubarek, Master. Gerios</td>
      <td>male</td>
      <td>NaN</td>
      <td>1</td>
      <td>1</td>
      <td>2661</td>
      <td>15.2458</td>
      <td>NaN</td>
      <td>C</td>
    </tr>
    <tr>
      <th>78</th>
      <td>79</td>
      <td>1</td>
      <td>2</td>
      <td>Caldwell, Master. Alden Gates</td>
      <td>male</td>
      <td>0.83</td>
      <td>0</td>
      <td>2</td>
      <td>248738</td>
      <td>29.0000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>81</th>
      <td>82</td>
      <td>1</td>
      <td>3</td>
      <td>Sheerlinck, Mr. Jan Baptist</td>
      <td>male</td>
      <td>29.00</td>
      <td>0</td>
      <td>0</td>
      <td>345779</td>
      <td>9.5000</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>118</th>
      <td>119</td>
      <td>0</td>
      <td>1</td>
      <td>Baxter, Mr. Quigg Edmond</td>
      <td>male</td>
      <td>24.00</td>
      <td>0</td>
      <td>1</td>
      <td>PC 17558</td>
      <td>247.5208</td>
      <td>B58 B60</td>
      <td>C</td>
    </tr>
    <tr>
      <th>139</th>
      <td>140</td>
      <td>0</td>
      <td>1</td>
      <td>Giglio, Mr. Victor</td>
      <td>male</td>
      <td>24.00</td>
      <td>0</td>
      <td>0</td>
      <td>PC 17593</td>
      <td>79.2000</td>
      <td>B86</td>
      <td>C</td>
    </tr>
    <tr>
      <th>165</th>
      <td>166</td>
      <td>1</td>
      <td>3</td>
      <td>Goldsmith, Master. Frank John William "Frankie"</td>
      <td>male</td>
      <td>9.00</td>
      <td>0</td>
      <td>2</td>
      <td>363291</td>
      <td>20.5250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
  </tbody>
</table>
</div>



<p>具体的优化思路有以下几点：<br>Age属性不使用现在的拟合方式，而是根据名称中的『Mr』『Mrs』『Miss』等的平均值进行填充。</p>
<p>Age不做成一个连续值属性，而是使用一个步长进行离散化，变成离散的类目feature。</p>
<p>Cabin再细化一些，对于有记录的Cabin属性，我们将其分为前面的字母部分(我猜是位置和船层之类的信息) 和 后面的数字部分(应该是房间号，有意思的事情是，如果你仔细看看原始数据，你会发现，这个值大的情况下，似乎获救的可能性高一些)。</p>
<p>Pclass和Sex俩太重要了，我们试着用它们去组出一个组合属性来试试，这也是另外一种程度的细化。</p>
<p>单加一个Child字段，Age&lt;=12的，设为1，其余为0(你去看看数据，确实小盆友优先程度很高啊)<br>如果名字里面有『Mrs』，而Parch&gt;1的，我们猜测她可能是一个母亲，应该获救的概率也会提高，因此可以多加一个Mother字段，此种情况下设为1，其余情况下设为0</p>
<p>登船港口可以考虑先去掉试试(Q和C本来就没权重，S有点诡异)</p>
<p>把堂兄弟/兄妹 和 Parch 还有自己 个数加在一起组一个Family_size字段(考虑到大家族可能对最后的结果有影响)<br>Name是一个我们一直没有触碰的属性，我们可以做一些简单的处理，比如说男性中带某些字眼的(‘Capt’, ‘Don’, ‘Major’, ‘Sir’)可以统一到一个Title，女性也一样。</p>
<h1 id="8-learning-curve"><a href="#8-learning-curve" class="headerlink" title="8.learning curve"></a>8.learning curve</h1><p>主要用来判断过拟合和欠拟合问题，其中过拟合的解决办法如下：</p>
<ol>
<li>做一下feature selection，挑出较好的feature的subset来做training</li>
<li>提供更多的数据，从而弥补原始数据的bias问题，学习到的model也会更准确 而对于欠拟合而言，我们通常需要更多的feature，更复杂的模型来提高准确度。<br>种状态分别如下两张图所示：过拟合(overfitting/high variace)，欠拟合(underfitting/high bias)：
这里可以使用sklearn的learning curve来解决问题</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># from sklearn.learning_curve import learning_curve  修改以fix learning_curve DeprecationWarning</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用sklearn的learning_curve得到training_score和cv_score，使用matplotlib画出learning curve</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curve</span><span class="params">(estimator, title, X, y, ylim=None, cv=None, n_jobs=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                        train_sizes=np.linspace<span class="params">(<span class="number">.05</span>, <span class="number">1.</span>, <span class="number">20</span>)</span>, verbose=<span class="number">0</span>, plot=True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    画出data在某模型上的learning curve.</span></span><br><span class="line"><span class="string">    参数解释</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    estimator : 你用的分类器。</span></span><br><span class="line"><span class="string">    title : 表格的标题。</span></span><br><span class="line"><span class="string">    X : 输入的feature，numpy类型</span></span><br><span class="line"><span class="string">    y : 输入的target vector</span></span><br><span class="line"><span class="string">    ylim : tuple格式的(ymin, ymax), 设定图像中纵坐标的最低点和最高点</span></span><br><span class="line"><span class="string">    cv : 做cross-validation的时候，数据分成的份数，其中一份作为cv集，其余n-1份作为training(默认为3份)</span></span><br><span class="line"><span class="string">    n_jobs : 并行的的任务数(默认1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    train_sizes, train_scores, test_scores = learning_curve(</span><br><span class="line">        estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes, verbose=verbose)</span><br><span class="line">    </span><br><span class="line">    train_scores_mean = np.mean(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">    train_scores_std = np.std(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">    test_scores_mean = np.mean(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    test_scores_std = np.std(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> plot:</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.title(title)</span><br><span class="line">        <span class="keyword">if</span> ylim <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            plt.ylim(*ylim)</span><br><span class="line">        plt.xlabel(<span class="string">u"训练样本数"</span>)</span><br><span class="line">        plt.ylabel(<span class="string">u"得分"</span>)</span><br><span class="line">        plt.gca().invert_yaxis()</span><br><span class="line">        plt.grid()</span><br><span class="line">    </span><br><span class="line">        plt.fill_between(train_sizes, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std, </span><br><span class="line">                         alpha=<span class="number">0.1</span>, color=<span class="string">"b"</span>)</span><br><span class="line">        plt.fill_between(train_sizes, test_scores_mean - test_scores_std, test_scores_mean + test_scores_std, </span><br><span class="line">                         alpha=<span class="number">0.1</span>, color=<span class="string">"r"</span>)</span><br><span class="line">        plt.plot(train_sizes, train_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"b"</span>, label=<span class="string">u"训练集上得分"</span>)</span><br><span class="line">        plt.plot(train_sizes, test_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"r"</span>, label=<span class="string">u"交叉验证集上得分"</span>)</span><br><span class="line">    </span><br><span class="line">        plt.legend(loc=<span class="string">"best"</span>)</span><br><span class="line">        </span><br><span class="line">        plt.draw()</span><br><span class="line">        plt.gca().invert_yaxis()</span><br><span class="line">        plt.show()</span><br><span class="line">    </span><br><span class="line">    midpoint = ((train_scores_mean[<span class="number">-1</span>] + train_scores_std[<span class="number">-1</span>]) + (test_scores_mean[<span class="number">-1</span>] - test_scores_std[<span class="number">-1</span>])) / <span class="number">2</span></span><br><span class="line">    diff = (train_scores_mean[<span class="number">-1</span>] + train_scores_std[<span class="number">-1</span>]) - (test_scores_mean[<span class="number">-1</span>] - test_scores_std[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> midpoint, diff</span><br><span class="line"></span><br><span class="line">plot_learning_curve(clf, <span class="string">u"学习曲线"</span>, X, y)</span><br></pre></td></tr></table></figure>


<img src="/2020/08/06/titanic_logistic_prac/output_44_0.png" class="" title="png">





<pre><code>(0.8041289762608517, 0.028972978630723678)</code></pre><h1 id="9-模型融合"><a href="#9-模型融合" class="headerlink" title="9.模型融合"></a>9.模型融合</h1><p>这里可以每次取训练集的一个subset，做训练，这样，我们虽然用的是同一个机器学习算法，但是得到的模型却是不一样的；同时，因为我们没有任何一份子数据集是全的，因此即使出现过拟合，也是在子训练集上出现过拟合，而不是全体数据上，这样做一个融合，可能对最后的结果有一定的帮助。对，这就是常用的Bagging。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line"></span><br><span class="line">train_df = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass.*|Mother|Child|Family|Title'</span>)</span><br><span class="line">train_np = train_df.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># y即Survival结果</span></span><br><span class="line">y = train_np[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># X即特征属性值</span></span><br><span class="line">X = train_np[:, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># fit到BaggingRegressor之中</span></span><br><span class="line">clf = linear_model.LogisticRegression(C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>,solver=<span class="string">"liblinear"</span>)</span><br><span class="line">bagging_clf = BaggingRegressor(clf, n_estimators=<span class="number">20</span>, max_samples=<span class="number">0.8</span>, max_features=<span class="number">1.0</span>, bootstrap=<span class="literal">True</span>, bootstrap_features=<span class="literal">False</span>, n_jobs=<span class="number">-1</span>)</span><br><span class="line">bagging_clf.fit(X, y)</span><br><span class="line"></span><br><span class="line">test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass.*|Mother|Child|Family|Title'</span>)</span><br><span class="line">predictions = bagging_clf.predict(test)</span><br><span class="line">result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>:data_test[<span class="string">'PassengerId'</span>].values, <span class="string">'Survived'</span>:predictions.astype(np.int32)&#125;)</span><br><span class="line">result.to_csv(<span class="string">"../titanic/logistic_regression_bagging_predictions.csv"</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">"../titanic/logistic_regression_bagging_predictions.csv"</span>).head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>892</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>893</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>894</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>895</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>896</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>897</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>898</td>
      <td>1</td>
    </tr>
    <tr>
      <th>7</th>
      <td>899</td>
      <td>0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>900</td>
      <td>1</td>
    </tr>
    <tr>
      <th>9</th>
      <td>901</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



<p>可以发现结果总体上是优于之前的预测的，只是不太稳定</p>
<img src="/2020/08/06/titanic_logistic_prac/1596729100632.png" class="" width="1596729100632">

<p>最后，仍然是别人总结的思路流程图</p>
<img src="/2020/08/06/titanic_logistic_prac/100f3a39031e73bd0a8.jpg" class="" title="用机器学习解决问题的过程">]]></content>
      <categories>
        <category>kaggle</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>kaggle</tag>
      </tags>
  </entry>
</search>
